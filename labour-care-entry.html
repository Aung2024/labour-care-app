<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Labour Care Entry - Mobile Carousel</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root { 
      --primary: #10b981; 
      --secondary: #059669; 
      --danger: #dc2626;
      --warning: #f59e0b;
    }
    
    body { 
      font-family: 'Inter', sans-serif; 
      background: #f0fdf4; 
      margin: 0; 
      padding-bottom: 90px; 
    }
    
    /* Header */
    .header { 
      background: linear-gradient(135deg, var(--primary), var(--secondary)); 
      color: white; 
      padding: 1rem; 
      position: sticky; 
      top: 0; 
      z-index: 100; 
    }
    
    .patient-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
    .patient-name { font-weight: 700; font-size: 1.125rem; }
    
    .stage-info { display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; }
    .stage-time { display: flex; align-items: center; gap: 0.5rem; }
    .stage-label { opacity: 0.9; }
    .stage-value { font-weight: 600; }
    
    /* Time Pills Section - Premium Design */
    .time-pills-section { 
      background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%); 
      padding: 1.25rem; 
      border-bottom: 2px solid #e5e7eb;
      margin-bottom: 1rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    .time-pills-container { 
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 1rem; 
      align-items: center;
      position: relative;
    }
    .time-pills-wrapper { 
      display: flex; 
      gap: 0.75rem; 
      overflow-x: auto;
      overflow-y: visible;
      scrollbar-width: thin;
      scrollbar-color: #cbd5e1 #f1f5f9;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      padding: 0.5rem 0;
      /* Hide scrollbar but keep functionality */
      scrollbar-width: none;
      -ms-overflow-style: none;
      /* Ensure clicks work on all pills */
      position: relative;
      z-index: 1;
      /* Allow pointer events on all children */
      pointer-events: auto;
    }
    .time-pills-wrapper::-webkit-scrollbar {
      display: none;
    }
    /* Position indicator */
    .time-pills-position {
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: #64748b;
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 8px;
      border-radius: 12px;
      font-weight: 500;
      pointer-events: none; /* Don't block clicks */
      z-index: 0; /* Behind pills */
    }
    .time-pill { 
      background: white; 
      color: #475569; 
      border: 2px solid #e2e8f0;
      padding: 0.625rem 1rem; 
      border-radius: 12px; 
      font-weight: 600; 
      font-size: 0.875rem; 
      cursor: pointer; 
      white-space: nowrap; 
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      min-width: 70px;
      text-align: center;
      position: relative;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      /* Ensure pills are always clickable */
      pointer-events: auto;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      z-index: 2;
      flex-shrink: 0; /* Prevent pills from shrinking */
    }
    .time-pill:hover { 
      background: #f8fafc; 
      border-color: var(--primary); 
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(16,185,129,0.15);
    }
    .time-pill.active { 
      background: linear-gradient(135deg, var(--primary), var(--secondary)); 
      color: white; 
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(16,185,129,0.25);
      font-weight: 700;
    }
    .time-pill.second-stage { 
      background: linear-gradient(135deg, #d1fae5, #a7f3d0); 
      color: #065f46; 
      border-color: #6ee7b7;
    }
    .time-pill.second-stage:hover {
      background: linear-gradient(135deg, #a7f3d0, #6ee7b7);
      border-color: #34d399;
      transform: translateY(-2px);
    }
    .time-pill.second-stage.active { 
      background: linear-gradient(135deg, #059669, #047857); 
      color: white; 
      border-color: #059669;
      box-shadow: 0 6px 16px rgba(5,150,105,0.25);
    }
    .time-pill-nav { 
      background: white;
      border: 2px solid #e2e8f0;
      color: #64748b; 
      width: 40px; 
      height: 40px; 
      border-radius: 50%; 
      cursor: pointer; 
      display: flex; 
      align-items: center; 
      justify-content: center;
      font-size: 1.25rem;
      font-weight: 700;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .time-pill-nav:hover { 
      background: var(--primary); 
      color: white;
      border-color: var(--primary);
      transform: scale(1.1);
      box-shadow: 0 4px 8px rgba(16,185,129,0.2);
    }
    .time-pill-nav:disabled { 
      opacity: 0.3; 
      cursor: not-allowed; 
      background: #f1f5f9;
      border-color: #e2e8f0;
      color: #94a3b8;
      transform: none;
      box-shadow: none;
    }
    .time-pill-nav:disabled:hover { 
      background: #f1f5f9;
      border-color: #e2e8f0;
      color: #94a3b8;
      transform: none;
    }
    
    .btn-add-now { background: var(--warning); color: white; border: none; padding: 0.5rem 1rem; border-radius: 8px; font-weight: 600; cursor: pointer; white-space: nowrap; }
    .alerts-chip { background: var(--danger); color: white; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-weight: 700; flex-shrink: 0; }
    
    .mode-toggle { display: flex; gap: 0.5rem; }
    .mode-btn { flex: 1; padding: 0.5rem; border: none; background: rgba(255,255,255,0.2); color: white; border-radius: 8px; font-weight: 600; cursor: pointer; }
    .mode-btn.active { background: white; color: var(--primary); }
    
    /* Entry Card */
    .entry-card { background: white; margin: 1rem; border-radius: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    
    /* Section Cards */
    .section-card { 
      border-bottom: 1px solid #e5e7eb; 
      margin-bottom: 0.5rem;
    }
    .section-card:last-child { border-bottom: none; }
    
    .section-header { 
      padding: 1rem; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      cursor: pointer;
      background: #f8f9fa;
      transition: all 0.2s;
    }
    .section-header:hover { background: #f3f4f6; }
    .section-header h4 { 
      margin: 0; 
      font-size: 1rem; 
      font-weight: 600; 
      color: #1f2937;
    }
    .collapse-icon { 
      transition: transform 0.2s; 
      color: #6b7280;
    }
    .section-card.expanded .collapse-icon { transform: rotate(180deg); }
    
    .section-content { 
      max-height: 0; 
      overflow: hidden; 
      transition: max-height 0.3s ease;
      padding: 0 1rem;
    }
    .section-card.expanded .section-content { 
      max-height: 2000px; 
      padding: 1rem;
    }
    
    .tabs { display: flex; overflow-x: auto; background: #f8f9fa; border-bottom: 1px solid #e5e7eb; scrollbar-width: none; }
    .tabs::-webkit-scrollbar { display: none; }
    .tab { padding: 1rem 1.25rem; border: none; background: transparent; border-bottom: 3px solid transparent; font-weight: 600; white-space: nowrap; cursor: pointer; font-size: 0.875rem; }
    .tab.active { color: var(--primary); border-bottom-color: var(--primary); background: white; }
    .tab-content { padding: 1.5rem; min-height: 300px; }
    .form-field { margin-bottom: 1.25rem; }
    .form-label { display: block; font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem; }
    input, select, textarea { width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem; transition: all 0.2s; font-family: inherit; }
    .form-input { width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem; transition: all 0.2s; font-family: inherit; }
    textarea { min-height: 100px; resize: vertical; }
    input:focus, select:focus, textarea:focus, .form-input:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(16,185,129,0.1); }
    
    /* Footer */
    .footer { position: fixed; bottom: 0; left: 0; right: 0; background: white; padding: 1rem; box-shadow: 0 -2px 8px rgba(0,0,0,0.1); z-index: 100; }
    .footer-btns { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.75rem; }
    .btn-footer { padding: 0.75rem; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .btn-save { background: var(--primary); color: white; }
    .btn-summary { background: #6366f1; color: white; }
    .btn-back-footer { background: #6b7280; color: white; text-decoration: none; display: flex; align-items: center; justify-content: center; }
    .btn-footer:disabled { opacity: 0.5; cursor: not-allowed; }
    
    /* Alerts */
    .alert-value { background: #fef2f2 !important; color: #dc2626 !important; border-color: #dc2626 !important; font-weight: 600 !important; }
    .alert-input { 
      border-color: #dc2626 !important; 
      background-color: #fef2f2 !important; 
      animation: alert-pulse 2s infinite;
    }
    @keyframes alert-pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.4); }
      50% { box-shadow: 0 0 0 4px rgba(220, 38, 38, 0); }
    }
    
    /* Alerts Drawer */
    .drawer { position: fixed; bottom: 0; left: 0; right: 0; background: white; border-radius: 20px 20px 0 0; max-height: 70vh; transform: translateY(100%); transition: transform 0.3s ease; z-index: 1000; box-shadow: 0 -4px 20px rgba(0,0,0,0.15); }
    .drawer.open { transform: translateY(0); }
    .drawer-header { padding: 1.5rem; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; }
    .drawer-header h3 { margin: 0; }
    .drawer-close { background: #f3f4f6; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; }
    .drawer-content { padding: 1.5rem; overflow-y: auto; max-height: calc(70vh - 80px); }
    .alert-item { background: #fef3c7; border-left: 4px solid var(--warning); padding: 1rem; margin-bottom: 0.75rem; border-radius: 8px; }
    
    /* Backdrop */
    .backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3); z-index: 999; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
    .backdrop.active { opacity: 1; pointer-events: all; }
    
    /* Toast */
    .toast { position: fixed; top: 80px; left: 50%; transform: translateX(-50%) translateY(-100px); background: var(--primary); color: white; padding: 1rem 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; transition: all 0.3s ease; z-index: 1500; }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    
    /* Review Timeline */
    .timeline-card { background: white; padding: 1rem; margin: 0.75rem; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
  </style>
</head>
<body>
  <div class="header">
    <div class="patient-info">
      <span class="patient-name" id="patientName">Patient</span>
      <div style="display: flex; gap: 0.5rem; align-items: center;">
        <div class="language-switcher">
          <button class="btn btn-sm" onclick="toggleLanguage()">
            <span id="languageToggle">EN üá¨üáß</span>
          </button>
        </div>
        <div class="alerts-chip" id="alertsChip" onclick="openAlertsDrawer()">‚ö†</div>
      </div>
    </div>
    
    <div class="stage-info" id="stageInfo">
      <div class="stage-time">
        <span class="stage-label">First Stage:</span>
        <span class="stage-value" id="firstStageTime">-</span>
      </div>
      <div class="stage-time" id="secondStageInfo" style="display: none;">
        <span class="stage-label">Second Stage:</span>
        <span class="stage-value" id="secondStageTime">-</span>
      </div>
    </div>
    <!-- Inline second stage time entry (visible only until set) -->
    <div id="secondStageEntryBar" style="display:none; margin-top: 8px; gap: 8px; align-items: center;">
      <label for="secondStageEntryInput" style="color: #fff; margin-right: 8px;">Second stage start</label>
      <input type="time" id="secondStageEntryInput" style="padding: 6px 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.15); color: #fff;">
      <button class="btn btn-sm" id="confirmSecondStageBtn" onclick="confirmSecondStageFromEntry()" style="background:#10b981;color:#fff;border:none;padding:6px 10px;border-radius:6px;">OK</button>
    </div>
  </div>
  
  <!-- Time Pills Section -->
  <div class="time-pills-section">
    <div class="time-pills-container">
      <button class="time-pill-nav" id="timePillsPrev" onclick="scrollTimePills('prev')" aria-label="Previous time">‚Äπ</button>
      <div class="time-pills-wrapper" id="timePillsWrapper"></div>
      <button class="time-pill-nav" id="timePillsNext" onclick="scrollTimePills('next')" aria-label="Next time">‚Ä∫</button>
      <div class="time-pills-position" id="timePillsPosition" style="display: none;"></div>
    </div>
  </div>
  
  <!-- Entry Mode -->
  <div id="entryMode" class="entry-content">
    <div class="entry-card">
      <!-- Sections will be rendered here as vertical foldable cards -->
      <div id="sectionsContainer"></div>
    </div>
  </div>
  
  <!-- Review Mode -->
  <div id="reviewMode" style="display: none;"></div>

  <!-- Footer -->
  <div class="footer">
    <div class="footer-btns">
      <button class="btn-footer btn-save" onclick="saveData()" data-i18n="save">Save</button>
      <button class="btn-footer btn-summary" onclick="openViewSummary()" data-i18n="summary">Summary</button>
      <a href="list.html" class="btn-footer btn-back-footer" data-i18n="back">Back</a>
    </div>
  </div>

  <!-- Alerts Drawer -->
  <div class="backdrop" onclick="closeAlertsDrawer()"></div>
  <div class="drawer" id="alertsDrawer">
    <div class="drawer-header">
      <h3>‚ö† <span data-i18n="clinicalAlerts">Clinical Alerts</span></h3>
      <button class="drawer-close" onclick="closeAlertsDrawer()">‚úï</button>
    </div>
    <div class="drawer-content" id="drawerContent">
      <p style="text-align: center; color: #6b7280;">No alerts at this timepoint</p>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast">‚úì Saved</div>

  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
  <script src="js/firebase.js"></script>
  <script src="js/status-manager.js"></script>
  <script src="languages/language-manager.js"></script>
  <script>
    // Prevent language manager from creating the default switcher
    window.noLanguageSwitcher = true;
    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    const state = {
      patientId: null,
      startTime: null,
      secondStageTime: null,
      activeTimepoint: null,
      timepoints: [],
      mode: 'entry',
      activeTab: 'support',
      data: {},
      isSecondStageActive: false
    };

    let currentIndex = 0;

    // ============================================================================
    // SECTION CONFIGS (from summary.html)
    // ============================================================================
    // Sections in the exact order as summary-view.html: Support, FHR, Baby, Woman, Contractions, Cervix Plot, Descent Plot, Medication, Shared Decision-Making
    const sections = {
      support: [
        { key: 'Companion', label: 'Companion', type: 'select', options: [['Y','Yes'],['N','No'],['D','Declined']] },
        { key: 'Pain_Relief', label: 'Pain Relief', type: 'select', options: [['Y','Yes'],['N','No'],['D','Declined']] },
        { key: 'Oral_fluids', label: 'Oral Fluids', type: 'select', options: [['Y','Yes'],['N','No'],['D','Declined']] },
        { key: 'Mobility', label: 'Mobility', type: 'select', options: [['M','Mobile'],['SP','Supine Position']] }
      ],
      fhr: [
        { key: 'Baseline_FHR', label: 'Baseline FHR (bpm)', type: 'number', min: 60, max: 200 },
        { key: 'FHR_deceleration', label: 'FHR Deceleration', type: 'select', options: [['N','None'],['E','Early'],['L','Late'],['V','Variable']] }
      ],
      baby: [
        { key: 'Amniotic_fluid', label: 'Amniotic Fluid', type: 'select', options: [['I','I'],['C','C'],['M','M'],['M+','M+'],['M++','M++'],['M+++','M+++'],['B','B']] },
        { key: 'Fetal_position', label: 'Fetal Position', type: 'select', options: [['A','A'],['P','P'],['T','T']] },
        { key: 'Caput', label: 'Caput', type: 'select', options: [['0','0'],['+','+'],['++','++'],['+++','+++']] },
        { key: 'Moulding', label: 'Moulding', type: 'select', options: [['0','0'],['+','+'],['++','++'],['+++','+++']] }
      ],
      woman: [
        { key: 'Pulse', label: 'Pulse (bpm)', type: 'number', min: 40, max: 200 },
        { key: 'Systolic_BP', label: 'Systolic BP', type: 'number', min: 60, max: 200 },
        { key: 'Diastolic_BP', label: 'Diastolic BP', type: 'number', min: 40, max: 120 },
        { key: 'Temperature_C', label: 'Temperature (¬∞C)', type: 'number', step: 0.1 },
        { key: 'Urine', label: 'Urine', type: 'select', options: [['-/-','-/-'],['P-','P-'],['P Trace','P Trace'],['P+','P+'],['P++','P++'],['A-','A-'],['A Trace','A Trace'],['A+','A+'],['A++','A++']] }
      ],
      contractions: [
        { key: 'Contractions_per_10_min', label: 'Contractions per 10 min', type: 'number', min: 0, max: 10 },
        { key: 'Duration_of_contractions', label: 'Duration of contractions (sec)', type: 'number', min: 0, max: 120 }
      ],
      cervix: [
        { key: 'Cervix_Plot_10', label: 'Cervix 10cm', type: 'checkbox', options: [['X','Mark']] },
        { key: 'Cervix_Plot_9', label: 'Cervix 9cm', type: 'checkbox', options: [['X','Mark']] },
        { key: 'Cervix_Plot_8', label: 'Cervix 8cm', type: 'checkbox', options: [['X','Mark']] },
        { key: 'Cervix_Plot_7', label: 'Cervix 7cm', type: 'checkbox', options: [['X','Mark']] },
        { key: 'Cervix_Plot_6', label: 'Cervix 6cm', type: 'checkbox', options: [['X','Mark']] },
        { key: 'Cervix_Plot_5', label: 'Cervix 5cm', type: 'checkbox', options: [['X','Mark']] },
        { key: 'Cervix_Plot_P', label: 'Pushing began', type: 'checkbox', options: [['P','Mark']] }
      ],
      descent: [
        { key: 'Descent_Plot_5', label: 'Descent -5', type: 'checkbox', options: [['O','Mark']] },
        { key: 'Descent_Plot_4', label: 'Descent -4', type: 'checkbox', options: [['O','Mark']] },
        { key: 'Descent_Plot_3', label: 'Descent -3', type: 'checkbox', options: [['O','Mark']] },
        { key: 'Descent_Plot_2', label: 'Descent -2', type: 'checkbox', options: [['O','Mark']] },
        { key: 'Descent_Plot_1', label: 'Descent -1', type: 'checkbox', options: [['O','Mark']] },
        { key: 'Descent_Plot_0', label: 'Descent 0', type: 'checkbox', options: [['O','Mark']] }
      ],
      meds: [
        { key: 'Medication_Oxytocin', label: 'Oxytocin (U/L, drops/min)', type: 'text', placeholder: 'e.g. 5 U/L, 20 drops/min' },
        { key: 'Medication_Medicine', label: 'Medicine', type: 'text', placeholder: 'Enter medicine name' },
        { key: 'Medication_IV_Fluids', label: 'IV Fluids', type: 'text', placeholder: 'e.g. NS 500ml' }
      ],
      sdm: [
        { key: 'ASSESSMENT_Womans_condition', label: 'Woman\'s condition', type: 'textarea', placeholder: 'Assessment notes...' },
        { key: 'ASSESSMENT_Babys_condition', label: 'Baby\'s condition', type: 'textarea', placeholder: 'Assessment notes...' },
        { key: 'ASSESSMENT_Labour_progress', label: 'Labour progress', type: 'textarea', placeholder: 'Assessment notes...' },
        { key: 'PLAN', label: 'Plan', type: 'textarea', placeholder: 'Management plan...' },
        { key: 'INITIALS', label: 'Initials', type: 'text', placeholder: 'Your initials' }
      ]
    };

    // Alert thresholds (from summary.html)
    const alertThresholds = {
      'Companion': ['N'],
      'Pain_Relief': ['N'],
      'Oral_fluids': ['N'],
      'Mobility': ['SP'],
      'Baseline_FHR': { min: 110, max: 160 },
      'FHR_deceleration': ['L'],
      'Pulse': { min: 60, max: 120 },
      'Systolic_BP': { min: 80, max: 140 },
      'Diastolic_BP': { min: null, max: 90 },
      'Temperature_C': { min: 35.0, max: 37.5 },
      'Amniotic_fluid': ['M+++', 'B'],
      'Contractions_per_10_min': { min: 2.1, max: 5 },
      'Duration_of_contractions': { min: 20, max: 60 }
    };

    // ============================================================================
    // TIMEPOINT GENERATION (Pure Functions)
    // ============================================================================
    function generateTimepoints(start, secondStage = null) {
      console.log('üïê generateTimepoints:', { start, secondStage });
      
      // Validate input
      if (!start || start.trim() === '') {
        console.error('‚ùå No start time provided');
        return [];
      }
      
      const [sh, sm] = start.split(':').map(Number);
      
      // Validate parsed values
      if (isNaN(sh) || isNaN(sm) || sh < 0 || sh > 23 || sm < 0 || sm > 59) {
        console.error('‚ùå Invalid start time format:', start);
        return [];
      }
      
      const result = [];
      
      // Parse second stage time if provided and valid
      let secondStageMin = null;
      if (secondStage && secondStage.trim() !== '' && secondStage !== 'null' && secondStage !== 'undefined') {
        const [ssh, ssm] = secondStage.split(':').map(Number);
        if (!isNaN(ssh) && !isNaN(ssm) && ssh >= 0 && ssh <= 23 && ssm >= 0 && ssm <= 59) {
          secondStageMin = ssh * 60 + ssm;
        } else {
          console.error('‚ùå Invalid second stage time format:', secondStage);
        }
      }
      
      const startMin = sh * 60 + sm;
      
      // Check if first and second stage times are the same
      const timesAreSame = secondStageMin !== null && secondStageMin === startMin;
      
      // If times are the same, start 3 hours before the start time
      let effectiveStartMin = startMin;
      if (timesAreSame) {
        effectiveStartMin = startMin - (3 * 60); // 3 hours before
        if (effectiveStartMin < 0) {
          effectiveStartMin += 24 * 60; // Wrap around midnight
        }
        console.log('‚ö†Ô∏è First and second stage times are the same - starting 3 hours before:', effectiveStartMin);
      }
      
      // Generate first stage timepoints with BOTH 30-min and 1-hour intervals
      // Stop at second stage time (or endMin if no second stage)
      let currentMin = effectiveStartMin;
      const endMin = startMin + (12 * 60); // 12 hours from actual start
      
      // Determine where to stop first stage generation
      // If second stage exists, stop just before it (or at it if times are same)
      const firstStageEndMin = secondStageMin !== null ? secondStageMin : endMin;
      
      if (secondStageMin !== null && secondStageMin < startMin && !timesAreSame) {
        // If second stage is before start (and not same), skip first stage
        console.log('‚ö†Ô∏è Second stage is before start time, skipping first stage');
      } else {
        // Generate 30-minute intervals (for FHR and Contractions)
        // Stop 30 minutes before second stage (or at endMin if no second stage)
        currentMin = effectiveStartMin;
        const stopBeforeSecondStage = secondStageMin !== null ? Math.max(effectiveStartMin, secondStageMin - 30) : endMin;
        while (currentMin < stopBeforeSecondStage) {
          const totalMins = currentMin % (24 * 60); // Wrap around 24 hours
          const h = Math.floor(totalMins / 60);
          const m = totalMins % 60;
          const timeStr = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
          
          result.push({
            time: timeStr,
            isSecondStage: false,
            interval: '30min'
          });
          
          currentMin += 30;
          
          if (result.length > 100) {
            console.error('‚ùå Too many timepoints generated, breaking loop');
            break;
          }
        }
        
        // Generate 1-hour intervals (for Support, Woman, Baby, Meds, SDM, etc.)
        // Stop at second stage time (or endMin if no second stage)
        // When times are same, stop at secondStageMin (not endMin)
        currentMin = effectiveStartMin;
        let hourCount = 0;
        const stopBeforeSecondStageHourly = secondStageMin !== null ? secondStageMin : endMin;
        while (currentMin < stopBeforeSecondStageHourly) {
          const totalMins = currentMin % (24 * 60);
          const h = Math.floor(totalMins / 60);
          const m = totalMins % 60;
          const timeStr = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
          
          result.push({
            time: timeStr,
            isSecondStage: false,
            interval: '60min'
          });
          
          hourCount++;
          console.log(`  üìÖ Added 1-hour timepoint: ${timeStr} (count: ${hourCount})`);
          
          currentMin += 60;
          
          if (hourCount > 50) {
            console.error('‚ùå Too many 1-hour timepoints, breaking loop');
            break;
          }
        }
        
        console.log(`‚úÖ Generated ${hourCount} 1-hour interval timepoints (stopped at ${stopBeforeSecondStageHourly})`);
      }
      
      // Generate second stage timepoints if applicable
      if (secondStageMin !== null) {
        console.log('üéØ Starting second stage timepoint generation at:', secondStageMin);
        const endSecondStageMin = secondStageMin + (15 * 12); // 12 intervals of 15 min = 3 hours
        
        // Generate 15-minute intervals for second stage (for FHR, Contractions, Cervix)
        currentMin = secondStageMin;
        let secondStage15minCount = 0;
        while (currentMin <= endSecondStageMin) {
          const totalMins = currentMin % (24 * 60); // Wrap around 24 hours
          const h = Math.floor(totalMins / 60);
          const m = totalMins % 60;
          const timeStr = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
          
          const tp = {
            time: timeStr,
            isSecondStage: true,
            interval: '15min'
          };
          
          result.push(tp);
          secondStage15minCount++;
          console.log(`  ‚úÖ Added second stage 15-min pill: ${timeStr} (count: ${secondStage15minCount})`);
          
          currentMin += 15;
        }
        console.log(`‚úÖ Generated ${secondStage15minCount} second stage 15-min timepoints`);
        
        // Mark 15-min intervals at hourly boundaries to also support hourly sections
        // This avoids creating duplicate pills while still supporting all section types
        const hourlyBoundaryTimes = new Set();
        currentMin = secondStageMin;
        while (currentMin <= endSecondStageMin) {
          const totalMins = currentMin % (24 * 60);
          const h = Math.floor(totalMins / 60);
          const m = totalMins % 60;
          const timeStr = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
          hourlyBoundaryTimes.add(timeStr);
          currentMin += 60;
        }
        
        // Update 15-min intervals at hourly boundaries to support both intervals
        result.forEach(tp => {
          if (tp.isSecondStage && tp.interval === '15min' && hourlyBoundaryTimes.has(tp.time)) {
            tp.supportsHourly = true; // Mark as supporting hourly sections
          }
        });
        
        console.log(`‚úÖ Marked ${hourlyBoundaryTimes.size} hourly boundary timepoints to support both intervals`);
      }
      
      // Deduplicate timepoints: keep only unique times, preferring 15min interval (more granular)
      // But if a 15min interval has supportsHourly flag, it can show hourly sections too
      const uniqueTimepoints = [];
      const timeMap = new Map();
      
      // First pass: collect all timepoints
      result.forEach(tp => {
        const timeStr = tp.time || tp;
        if (!timeMap.has(timeStr)) {
          timeMap.set(timeStr, []);
        }
        timeMap.get(timeStr).push(tp);
      });
      
      // Second pass: for each unique time, prefer 15min interval (more granular)
      // Keep the supportsHourly flag if present
      timeMap.forEach((timepoints, timeStr) => {
        // Prefer 15min interval for more granular data entry
        // But preserve supportsHourly flag if present
        const preferred = timepoints.find(tp => tp.interval === '15min') || 
                          timepoints.find(tp => tp.interval === '30min') ||
                          timepoints.find(tp => tp.interval === '60min') ||
                          timepoints[0];
        
        // If there was a 60min version, merge its properties
        const hourlyVersion = timepoints.find(tp => tp.interval === '60min');
        if (hourlyVersion && preferred.interval !== '60min') {
          preferred.supportsHourly = true;
        }
        
        uniqueTimepoints.push(preferred);
      });
      
      // Sort by time
      uniqueTimepoints.sort((a, b) => {
        const timeA = a.time || a;
        const timeB = b.time || b;
        return timeA.localeCompare(timeB);
      });
      
      state.timepoints = uniqueTimepoints;
      state.isSecondStageActive = secondStageMin !== null;
      
      console.log('üìä Total timepoints generated (before dedup):', result.length);
      console.log('üìä Total unique timepoints (after dedup):', uniqueTimepoints.length);
      console.log('üìÖ All unique timepoints:', uniqueTimepoints.map(tp => `${tp.time}${tp.interval ? ` (${tp.interval})` : ''}${tp.isSecondStage ? ' [2nd]' : ''}`));
      return uniqueTimepoints;
    }

    // ============================================================================
    // RENDER FUNCTIONS
    // ============================================================================
    
    // Determine which sections to show based on timepoint interval
    function getIntervalForTimepoint(timepoint) {
      if (!timepoint) return 'unknown';
      
      // Find the timepoint with this time
      const tp = state.timepoints.find(t => (t.time || t) === (timepoint.time || timepoint) || t === timepoint);
      
      if (tp) {
        // If timepoint supports hourly sections (marked at hourly boundaries), return '60min'
        if (tp.supportsHourly) {
          return '60min';
        }
        
        // Check if it has 60-min interval
        if (tp.interval === '60min') {
          return '60min';
        }
        
        // Otherwise return the interval (30min or 15min)
        return tp.interval || (tp.isSecondStage ? '15min' : '30min');
      }
      
      return 'unknown';
    }
    
    // Check if a section should be shown for the current interval
    function shouldShowSection(sectionKey, interval) {
      // Mapping of which sections to show for each interval
      const sectionRules = {
        '15min': ['fhr', 'contractions', 'cervix'], // Show FHR, Contractions, Cervix Plot
        '30min': ['fhr', 'contractions'], // Show FHR and Contractions only
        '60min': ['support', 'fhr', 'baby', 'woman', 'contractions', 'cervix', 'descent', 'meds', 'sdm'] // Show all sections including Medication and SDM (hourly only)
      };
      
      return sectionRules[interval]?.includes(sectionKey) || false;
    }
    
    function renderSections() {
      if (!state.activeTimepoint) {
        document.getElementById('sectionsContainer').innerHTML = '<p style="padding: 2rem; text-align: center; color: #6b7280;">Select a timepoint to begin</p>';
        return;
      }

      const container = document.getElementById('sectionsContainer');
      const timeKey = state.activeTimepoint.replace(':', '_');
      
      // Determine the interval for current timepoint
      const interval = getIntervalForTimepoint(state.activeTimepoint);
      console.log(`üîç Current timepoint interval: ${interval}`);
      
      const sectionNames = {
        'support': languageManager && languageManager.t ? languageManager.t('supportiveCare', 'Supportive Care') : 'Supportive Care',
        'fhr': languageManager && languageManager.t ? languageManager.t('fhr', 'FHR') : 'FHR',
        'baby': languageManager && languageManager.t ? languageManager.t('baby', 'Baby') : 'Baby',
        'woman': languageManager && languageManager.t ? languageManager.t('woman', 'Woman') : 'Woman',
        'contractions': languageManager && languageManager.t ? languageManager.t('contractions', 'Contractions') : 'Contractions',
        'cervix': languageManager && languageManager.t ? languageManager.t('cervixPlot', 'Cervix Plot X') : 'Cervix Plot X',
        'descent': languageManager && languageManager.t ? languageManager.t('descentPlot', 'Descent Plot O') : 'Descent Plot O',
        'meds': languageManager && languageManager.t ? languageManager.t('medication', 'Medication') : 'Medication',
        'sdm': languageManager && languageManager.t ? languageManager.t('sharedDecisionMaking', 'Shared Decision-Making') : 'Shared Decision-Making'
      };

      let html = '';
      
      Object.entries(sections).forEach(([key, fields]) => {
        // Check if this section should be shown for current interval
        if (!shouldShowSection(key, interval)) {
          console.log(`‚è≠Ô∏è Skipping section "${key}" for interval ${interval}`);
          return; // Skip this section
        }
        
        const sectionName = sectionNames[key];
        const sectionHtml = fields.map(f => {
          // Hide pushing marker until second stage is active
          if (f.key === 'Cervix_Plot_P' && !state.isSecondStageActive) {
            return '';
          }
          const inputName = `${f.key}_${timeKey}`;
          const storedValue = state.data[inputName] || '';
          const alertInfo = getAlertInfo(f.key, storedValue);
          
          // Translate field label using languageManager
          const translatedLabel = languageManager && languageManager.t ? languageManager.t(f.key, f.label) : f.label;
          
          if (f.type === 'select') {
            return `
              <div class="form-field">
                <label class="form-label">${translatedLabel} ${alertInfo}</label>
                <select name="${inputName}" class="form-input" onchange="updateValue('${inputName}', this.value); autoSave()">
                  <option value="">${languageManager && languageManager.t ? languageManager.t('formLabels.select', 'Select...') : 'Select...'}</option>
                  ${f.options.map(([v,l]) => `<option value="${v}" ${storedValue === v ? 'selected' : ''}>${l}</option>`).join('')}
                </select>
              </div>
            `;
          } else if (f.type === 'checkbox') {
            const markerValue = f.options && f.options.length > 0 ? f.options[0][0] : 'X'; // Get the marker value (X, O, P)
            const isChecked = storedValue === markerValue;
            return `
              <div class="form-field">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                  <input type="checkbox" name="${inputName}" value="${markerValue}" ${isChecked ? 'checked' : ''} 
                    onchange="updateValue('${inputName}', this.checked ? '${markerValue}' : ''); autoSave()" 
                    style="width: 20px; height: 20px;">
                  <span>${translatedLabel}</span>
                </label>
              </div>
            `;
          } else if (f.type === 'textarea') {
            return `
              <div class="form-field">
                <label class="form-label">${translatedLabel}</label>
                <textarea name="${inputName}" class="form-input" placeholder="${f.placeholder || ''}" onchange="updateValue('${inputName}', this.value); autoSave()">${storedValue}</textarea>
              </div>
            `;
          } else {
            return `
              <div class="form-field">
                <label class="form-label">${translatedLabel} ${alertInfo}</label>
                <input type="${f.type}" name="${inputName}" class="form-input" value="${storedValue}" 
                  ${f.min ? `min="${f.min}"` : ''} ${f.max ? `max="${f.max}"` : ''} ${f.step ? `step="${f.step}"` : ''} 
                  placeholder="${f.placeholder || ''}" onchange="updateValue('${inputName}', this.value); autoSave()">
              </div>
            `;
          }
        }).join('');
        
        html += `
          <div class="section-card" data-section="${key}">
            <div class="section-header" onclick="toggleSection('${key}')">
              <h4>${sectionName}</h4>
              <i class="fas fa-chevron-down collapse-icon"></i>
            </div>
            <div class="section-content">
              ${sectionHtml}
            </div>
          </div>
        `;
      });
      
      container.innerHTML = html;
      
      // Expand first section by default
      if (container.children.length > 0) {
        container.children[0].classList.add('expanded');
      }
      
      // Check alerts and highlight fields after rendering
      setTimeout(() => {
        checkAlerts();
        highlightAlertFields();
      }, 100);
    }
    
    function toggleSection(sectionKey) {
      const section = document.querySelector(`.section-card[data-section="${sectionKey}"]`);
      if (section) {
        section.classList.toggle('expanded');
      }
    }
    
    function renderTab() {
      if (!state.activeTimepoint) {
        document.getElementById('tabContent').innerHTML = '<p style="padding: 2rem; text-align: center; color: #6b7280;">Select a timepoint to begin</p>';
        return;
      }

      const config = sections[state.activeTab];
      const timeKey = state.activeTimepoint.replace(':', '_');
      
      const html = config.map(f => {
        const inputName = `${f.key}_${timeKey}`;
        const storedValue = state.data[inputName] || '';
        const alertInfo = getAlertInfo(f.key, storedValue);
        
        if (f.type === 'select') {
          return `
            <div class="form-field">
              <label class="form-label">${f.label} ${alertInfo}</label>
              <select name="${inputName}" class="form-input" onchange="updateValue('${inputName}', this.value); autoSave()">
                <option value="">Select...</option>
                ${f.options.map(([v,l]) => `<option value="${v}" ${storedValue === v ? 'selected' : ''}>${l}</option>`).join('')}
              </select>
            </div>
          `;
        } else if (f.type === 'checkbox') {
          const markerValue = f.options && f.options.length > 0 ? f.options[0][0] : 'X'; // Get the marker value (X, O, P)
          const isChecked = storedValue === markerValue;
          return `
            <div class="form-field">
              <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                <input type="checkbox" name="${inputName}" value="${markerValue}" ${isChecked ? 'checked' : ''} 
                  onchange="updateValue('${inputName}', this.checked ? '${markerValue}' : ''); autoSave()" 
                  style="width: 20px; height: 20px;">
                <span>${f.label}</span>
              </label>
            </div>
          `;
        } else if (f.type === 'textarea') {
          return `
            <div class="form-field">
              <label class="form-label">${f.label} ${alertInfo}</label>
              <textarea name="${inputName}" class="form-input" placeholder="${f.placeholder || ''}" 
                onblur="updateValue('${inputName}', this.value); autoSave()"
                onchange="updateValue('${inputName}', this.value); autoSave()">${storedValue}</textarea>
            </div>
          `;
        } else {
          const attrs = f.min ? `min="${f.min}" max="${f.max || ''}"` : '';
          const extraAttrs = f.step ? `step="${f.step}"` : '';
          const placeholder = f.placeholder ? `placeholder="${f.placeholder}"` : '';
          return `
            <div class="form-field">
              <label class="form-label">${f.label} ${alertInfo}</label>
              <input type="${f.type}" name="${inputName}" class="form-input ${isAlertValue(f.key, storedValue) ? 'alert-value' : ''}" 
                value="${storedValue}" ${attrs} ${extraAttrs} ${placeholder}
                onblur="updateValue('${inputName}', this.value); autoSave()"
                onchange="updateValue('${inputName}', this.value); autoSave()" 
                oninput="updateValue('${inputName}', this.value)">
            </div>
          `;
        }
      }).join('');
      
      document.getElementById('tabContent').innerHTML = html;
    }

    function renderReviewTimeline() {
      const container = document.getElementById('reviewMode');
      if (!container) return;
      
      if (state.timepoints.length === 0) {
        container.innerHTML = '<p style="padding: 2rem;">No data available</p>';
        return;
      }
      
      container.innerHTML = state.timepoints.map((tp, idx) => {
        const timeKey = tp.replace(':', '_');
        const hasData = Object.keys(state.data).some(k => k.endsWith(timeKey));
        
        if (!hasData && idx > 0) return ''; // Skip empty timepoints except first
        
        return `
          <div style="background: white; padding: 1rem; margin: 0.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <div style="font-weight: 700; margin-bottom: 0.5rem;">${tp}</div>
            <button class="btn" onclick="jumpToTimepoint(${idx})" style="width: 100%; background: var(--primary); color: white; border: none; padding: 0.75rem; border-radius: 8px; cursor: pointer;">
              Open in Entry
            </button>
          </div>
        `;
      }).filter(h => h).join('');
    }

    // ============================================================================
    // NAVIGATION
    // ============================================================================
    function prevTimepoint() { 
      if (currentIndex > 0) {
        currentIndex--;
        state.activeTimepoint = state.timepoints[currentIndex].time || state.timepoints[currentIndex];
        updateUI();
        renderTimePills();
        renderSections();
      }
    }
    
    function nextTimepoint() { 
      if (currentIndex < state.timepoints.length - 1) {
        currentIndex++;
        state.activeTimepoint = state.timepoints[currentIndex].time || state.timepoints[currentIndex];
        updateUI();
        renderTimePills();
        renderSections();
      }
    }

    function jumpToTimepoint(idx) {
      currentIndex = idx;
      state.activeTimepoint = state.timepoints[idx];
      setMode('entry');
      document.getElementById('entryModeBtn').click();
      updateUI();
      renderSections();
    }

    function updateUI() {
      const prevBtn = document.querySelector('.btn-footer.btn-prev');
      const nextBtn = document.querySelector('.btn-footer.btn-next');
      if (prevBtn) prevBtn.disabled = currentIndex === 0;
      if (nextBtn) nextBtn.disabled = currentIndex >= state.timepoints.length - 1;
    }

    // ============================================================================
    // DATA MANAGEMENT
    // ============================================================================
    function updateValue(key, value) {
      state.data[key] = value;
      
      // Immediately check alerts and update UI
      checkAlerts();
      
      // Also visually highlight alert fields in the current section
      highlightAlertFields();
    }
    
    // Highlight alert fields in the UI
    function highlightAlertFields() {
      // Remove all existing alert highlighting
      document.querySelectorAll('.form-input').forEach(input => {
        input.classList.remove('alert-input');
      });
      
      // Check each visible input field for alert values
      document.querySelectorAll('.form-input').forEach(input => {
        const fieldName = input.name || input.id;
        const value = input.value;
        
        if (fieldName && value && value.toString().trim() !== '') {
          let isAlert = false;
          
          // Use the same alert checking logic as checkAlerts()
          if (fieldName.includes('Baseline_FHR')) {
            const fhr = parseInt(value);
            isAlert = !isNaN(fhr) && (fhr < 110 || fhr >= 160);
          } else if (fieldName.includes('Pulse')) {
            const pulse = parseInt(value);
            isAlert = !isNaN(pulse) && (pulse < 60 || pulse >= 120);
          } else if (fieldName.includes('Systolic_BP')) {
            const bp = parseInt(value);
            isAlert = !isNaN(bp) && (bp < 80 || bp >= 140);
          } else if (fieldName.includes('Diastolic_BP')) {
            const bp = parseInt(value);
            isAlert = !isNaN(bp) && bp >= 90;
          } else if (fieldName.includes('Temperature_C')) {
            const temp = parseFloat(value);
            isAlert = !isNaN(temp) && (temp < 35.0 || temp >= 37.5);
          } else if (fieldName.includes('Pain_Relief') && value === 'N') {
            isAlert = true;
          } else if (fieldName.includes('Oral_fluids') && value === 'N') {
            isAlert = true;
          } else if (fieldName.includes('Mobility') && value === 'SP') {
            isAlert = true;
          } else if (fieldName.includes('Companion') && value === 'N') {
            isAlert = true;
          } else if (fieldName.includes('FHR_deceleration') && value === 'L') {
            isAlert = true;
          } else if (fieldName.includes('Amniotic_fluid') && (value === 'M+++' || value === 'B')) {
            isAlert = true;
          } else if (fieldName.includes('Fetal_position') && (value === 'P' || value === 'T')) {
            isAlert = true;
          } else if (fieldName.includes('Caput') && value === '+++') {
            isAlert = true;
          } else if (fieldName.includes('Moulding') && value === '+++') {
            isAlert = true;
          } else if (fieldName.includes('Urine') && (value === 'P++' || value === 'A++')) {
            isAlert = true;
          } else if (fieldName.includes('Contractions_per_10_min')) {
            const contractions = parseInt(value);
            isAlert = !isNaN(contractions) && (contractions < 2 || contractions > 5);
          } else if (fieldName.includes('Duration_of_contractions')) {
            const duration = parseInt(value);
            isAlert = !isNaN(duration) && (duration < 20 || duration > 60);
          }
          
          if (isAlert) {
            input.classList.add('alert-input');
          }
        }
      });
    }

    // Auto-save with debounce
    let autoSaveTimeout = null;
    async function autoSave() {
      clearTimeout(autoSaveTimeout);
      autoSaveTimeout = setTimeout(async () => {
        await saveData(true); // silent save
      }, 1000); // Wait 1 second after last change
    }

    async function saveData(silent = false) {
      if (!state.patientId) {
        if (!silent) alert('No patient ID');
        return;
      }
      
      try {
        const base = firebase.firestore().collection("patients").doc(state.patientId);
        
        // Clean state.data to remove any undefined values
        const cleanedData = {};
        Object.keys(state.data).forEach(key => {
          if (state.data[key] !== undefined) {
            cleanedData[key] = state.data[key];
          }
        });
        
        // Build the data object to save
        const summaryData = {
          ...cleanedData,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          startingTime: state.startTime
        };
        
        // Only include secondStageTime if it exists, is not null, and is not empty
        if (state.secondStageTime && typeof state.secondStageTime === 'string' && state.secondStageTime.trim() !== '') {
          summaryData.secondStageTime = state.secondStageTime;
        }
        
        // Save to summary document (for carousel entry page)
        await base.collection("records").doc("summary").set(summaryData, { merge: true });

        // Also save to startingTime document (for Classic LCG compatibility)
        if (state.startTime) {
          await base.collection("records").doc("startingTime").set({
            startingTime: state.startTime,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
          
          // Update patient status to Labour Care when first stage time is saved
          if (window.StatusManager) {
            const statusUpdated = await StatusManager.checkAndUpdateToLabourCare(state.patientId);
            if (statusUpdated) {
              console.log('‚úÖ Patient status updated to Labour Care');
            }
          }
        }

        // Save second stage if exists (for Classic LCG compatibility)
        if (state.secondStageTime && typeof state.secondStageTime === 'string' && state.secondStageTime.trim() !== '') {
          await base.collection("records").doc("secondStage").set({
            secondStageStartTime: state.secondStageTime,
            isSecondStageActive: true,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
          
          // Update patient status to Postnatal Care when second stage time is saved
          if (window.StatusManager) {
            const statusUpdated = await StatusManager.checkAndUpdateToPostnatalCare(
              state.patientId,
              'Second stage time recorded'
            );
            if (statusUpdated) {
              console.log('‚úÖ Patient status updated to Postnatal Care');
            }
          }
        }
        
        if (!silent) {
          showToast('‚úì Saved');
        }
      } catch (error) {
        console.error('Save error:', error);
        if (!silent) alert('Error saving: ' + error.message);
      }
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => {
        toast.classList.remove('show');
      }, 2000);
    }

    async function loadData() {
      const patientId = getPatientIdFromUrl();
      if (!patientId) return;
      
      state.patientId = patientId;
      
      try {
        // Load patient document
        const patientDoc = await firebase.firestore()
          .collection("patients")
          .doc(patientId)
          .get();
        
        if (patientDoc.exists) {
          const patientData = patientDoc.data();
          // Set patient name in header
          document.getElementById('patientName').textContent = patientData.name || 'Patient';
        }
        

        // Load summary data
        const base = firebase.firestore().collection("patients").doc(patientId);
        const doc = await base.collection("records").doc("summary").get();
        
        // Also try loading from startingTime and secondStage documents (Classic LCG saves here)
        const startingTimeDoc = await base.collection("records").doc("startingTime").get();
        const secondStageDoc = await base.collection("records").doc("secondStage").get();
        
        if (doc.exists || startingTimeDoc.exists || secondStageDoc.exists) {
          const data = doc.exists ? doc.data() : {};
          state.data = data;
          
          // Try multiple sources and field name variations for first stage time
          let loadedStartTime = data.startingTime || data.activeFirstStage_Time;
          if (!loadedStartTime && startingTimeDoc.exists) {
            loadedStartTime = startingTimeDoc.data().startingTime;
          }
          state.startTime = loadedStartTime;
          
          // Try multiple sources and field name variations for second stage time
          let loadedSecondStageTime = data.secondStageTime || data.secondStage_Time;
          if (!loadedSecondStageTime && secondStageDoc.exists) {
            const secondStageData = secondStageDoc.data();
            loadedSecondStageTime = secondStageData.secondStageStartTime;
          }
          
          // Also check if isSecondStageActive is true (Classic LCG sets this)
          if (secondStageDoc.exists && !loadedSecondStageTime) {
            const secondStageData = secondStageDoc.data();
            if (secondStageData.isSecondStageActive && secondStageData.secondStageStartTime) {
              loadedSecondStageTime = secondStageData.secondStageStartTime;
            }
          }
          
          // Ensure secondStageTime is null if not found (not undefined)
          state.secondStageTime = loadedSecondStageTime || null;
          
          console.log('üîç Time loading debug:');
          console.log('  First Stage:', state.startTime);
          console.log('  Second Stage:', state.secondStageTime);
          console.log('  Summary data:', data);
          console.log('  StartingTimeDoc:', startingTimeDoc.exists ? startingTimeDoc.data() : 'none');
          console.log('  SecondStageDoc:', secondStageDoc.exists ? secondStageDoc.data() : 'none');
          console.log('  SecondStageDoc exists:', secondStageDoc.exists);
          if (secondStageDoc.exists) {
            console.log('  SecondStageDoc data:', secondStageDoc.data());
            console.log('  isSecondStageActive:', secondStageDoc.data().isSecondStageActive);
            console.log('  secondStageStartTime:', secondStageDoc.data().secondStageStartTime);
          }
          
          // Display stage times in header
          document.getElementById('firstStageTime').textContent = state.startTime || '-';
          if (state.secondStageTime) {
            document.getElementById('secondStageTime').textContent = state.secondStageTime;
            document.getElementById('secondStageInfo').style.display = 'flex';
            const bar = document.getElementById('secondStageEntryBar');
            if (bar) bar.style.display = 'none';
          } else {
            document.getElementById('secondStageInfo').style.display = 'none';
            const bar = document.getElementById('secondStageEntryBar');
            if (bar) bar.style.display = state.startTime ? 'flex' : 'none';
          }
          
          if (state.startTime) {
            generateTimepoints(state.startTime, state.secondStageTime);
            if (state.timepoints && state.timepoints.length > 0) {
              state.activeTimepoint = state.timepoints[0].time || state.timepoints[0];
              currentIndex = 0;
              updateUI();
              renderTimePills();
              renderSections();
              console.log('‚úÖ Loaded data with', state.timepoints.length, 'timepoints');
            } else {
              console.error('‚ùå No timepoints generated!');
              console.error('  Start time:', state.startTime);
              console.error('  Second stage time:', state.secondStageTime);
              console.error('  State:', state);
            }
          } else {
            console.log('‚ö†Ô∏è No start time found in data, initializing with demo');
            // Demo initialization
            generateTimepoints('08:00');
            state.startTime = '08:00';
            if (state.timepoints.length > 0) {
              state.activeTimepoint = state.timepoints[0].time || state.timepoints[0];
              currentIndex = 0;
              updateUI();
              renderTimePills();
              renderSections();
            }
          }
        } else {
          console.log('‚ö†Ô∏è No summary data found, initializing with demo');
          // Demo initialization
          generateTimepoints('08:00');
          state.startTime = '08:00';
          if (state.timepoints.length > 0) {
            state.activeTimepoint = state.timepoints[0].time || state.timepoints[0];
            currentIndex = 0;
            updateUI();
            renderTimePills();
            renderSections();
          }
        }
      } catch (error) {
        console.error('Load error:', error);
        console.log('‚ö†Ô∏è Error loading data, initializing with demo');
        // Fallback to demo
        try {
          generateTimepoints('08:00');
          state.startTime = '08:00';
          if (state.timepoints.length > 0) {
            state.activeTimepoint = state.timepoints[0].time || state.timepoints[0];
            currentIndex = 0;
            updateUI();
            renderTimePills();
            renderSections();
          }
        } catch (demoError) {
          console.error('Demo initialization error:', demoError);
        }
      }
    }

    // Inline second stage confirmation from entry page (global)
    async function confirmSecondStageFromEntry() {
      const input = document.getElementById('secondStageEntryInput');
      if (!input) return;
      const value = (input.value || '').trim();
      if (!value) { alert('Please select a time'); return; }
      if (!state.startTime) { alert('Please set Active First Stage Start Time first.'); return; }

      // Allow second stage to be at the same time or after first stage (no minimum interval required)
      // Only validate that second stage is not before first stage (unless it's the next day)
      const first = new Date(`2000-01-01T${state.startTime}:00`);
      const second = new Date(`2000-01-01T${value}:00`);
      let diffMin = (second - first) / 60000;
      if (diffMin < 0) diffMin += 1440; // Handle midnight crossing

      state.secondStageTime = value;
      const timeEl = document.getElementById('secondStageTime');
      if (timeEl) timeEl.textContent = value;
      const info = document.getElementById('secondStageInfo');
      if (info) info.style.display = 'flex';
      const bar = document.getElementById('secondStageEntryBar');
      if (bar) bar.style.display = 'none';

      generateTimepoints(state.startTime, state.secondStageTime);
      renderTimePills();
      renderSections();
      await saveData(true);
      // Status update is handled in saveData() function
      showToast('‚úì Second stage set');
    }

    // ============================================================================
    // ALERTS
    // ============================================================================
    function isAlertValue(fieldKey, value) {
      const alert = alertThresholds[fieldKey];
      if (!alert) return false;
      
      if (Array.isArray(alert)) {
        return alert.includes(value);
      } else if (typeof alert === 'object') {
        const num = parseFloat(value);
        if (isNaN(num)) return false;
        if (alert.min !== null && num < alert.min) return true;
        if (alert.max !== null && num > alert.max) return true;
      }
      return false;
    }

    function getAlertInfo(fieldKey, value) {
      const alert = alertThresholds[fieldKey];
      if (!alert) return '';
      
      if (Array.isArray(alert)) {
        return isAlertValue(fieldKey, value) ? '<span style="color: #dc2626;">‚ö†</span>' : '';
      } else {
        return isAlertValue(fieldKey, value) ? '<span style="color: #dc2626;">‚ö†</span>' : '';
      }
    }

    function checkAlerts() {
      // Count alerts across all timepoints by checking field values
      let alertCount = 0;
      
      Object.keys(state.data).forEach(fieldName => {
        const value = state.data[fieldName];
        
        if (value && value.toString().trim() !== '') {
          // Check against WHO LCG alert values
          if (fieldName.includes('Baseline_FHR')) {
            const fhr = parseInt(value);
            if (!isNaN(fhr) && (fhr < 110 || fhr >= 160)) {
              alertCount++;
            }
          } else if (fieldName.includes('Pulse')) {
            const pulse = parseInt(value);
            if (!isNaN(pulse) && (pulse < 60 || pulse >= 120)) {
              alertCount++;
            }
          } else if (fieldName.includes('Systolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && (bp < 80 || bp >= 140)) {
              alertCount++;
            }
          } else if (fieldName.includes('Diastolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && bp >= 90) {
              alertCount++;
            }
          } else if (fieldName.includes('Temperature_C')) {
            const temp = parseFloat(value);
            if (!isNaN(temp) && (temp < 35.0 || temp >= 37.5)) {
              alertCount++;
            }
          } else if (fieldName.includes('Pain_Relief') && value === 'N') {
            alertCount++;
          } else if (fieldName.includes('Oral_fluids') && value === 'N') {
            alertCount++;
          } else if (fieldName.includes('Mobility') && value === 'SP') {
            alertCount++;
          } else if (fieldName.includes('Companion') && value === 'N') {
            alertCount++;
          } else if (fieldName.includes('FHR_deceleration') && value === 'L') {
            alertCount++;
          } else if (fieldName.includes('Amniotic_fluid') && (value === 'M+++' || value === 'B')) {
            alertCount++;
          } else if (fieldName.includes('Fetal_position') && (value === 'P' || value === 'T')) {
            alertCount++;
          } else if (fieldName.includes('Caput') && value === '+++') {
            alertCount++;
          } else if (fieldName.includes('Moulding') && value === '+++') {
            alertCount++;
          } else if (fieldName.includes('Urine') && (value === 'P++' || value === 'A++')) {
            alertCount++;
          } else if (fieldName.includes('Contractions_per_10_min')) {
            const contractions = parseInt(value);
            if (!isNaN(contractions) && (contractions < 2 || contractions > 5)) {
              alertCount++;
            }
          } else if (fieldName.includes('Duration_of_contractions')) {
            const duration = parseInt(value);
            if (!isNaN(duration) && (duration < 20 || duration > 60)) {
              alertCount++;
            }
          }
        }
      });
      
      // Update alerts chip
      const alertsChip = document.getElementById('alertsChip');
      if (alertsChip) {
        alertsChip.textContent = alertCount > 0 ? alertCount : '‚ö†';
        alertsChip.style.backgroundColor = alertCount > 0 ? '#dc2626' : '#6b7280';
      }
      
      console.log(`üîî Alert count: ${alertCount}`);
    }
    
    function showRecommendations() {
      console.log('=== showRecommendations() called ===');
      
      const drawerContent = document.getElementById('drawerContent');
      if (!drawerContent) {
        console.log('‚ùå Drawer content not found');
        return;
      }
      
      console.log('‚úÖ Found drawer content, checking for alerts...');
      
      // Use a Map to track latest value for each field type
      const latestValues = new Map();
      
      // First, group all field values by field type and find the latest timepoint for each
      Object.keys(state.data).forEach(fieldName => {
        const value = state.data[fieldName];
        
        // Extract field base name (remove time suffix like _HH_MM)
        const fieldParts = fieldName.split('_');
        if (fieldParts.length >= 3) {
          // Remove last two parts (time HH_MM)
          const baseFieldName = fieldParts.slice(0, -2).join('_');
          const timeKey = fieldParts.slice(-2).join('_'); // Get HH_MM
          
          // Store with time info
          if (!latestValues.has(baseFieldName)) {
            latestValues.set(baseFieldName, { timeKey, value, fieldName });
          } else {
            // Compare times and keep the latest
            const existing = latestValues.get(baseFieldName);
            if (timeKey > existing.timeKey) {
              latestValues.set(baseFieldName, { timeKey, value, fieldName });
            }
          }
        }
      });
      
      // Use a Map to track unique alerts by field type
      const alertMap = new Map();
      
      // Check only the latest value for each field type
      latestValues.forEach((data, baseFieldName) => {
        const value = data.value;
        const fieldName = data.fieldName;
        
        if (value && value.toString().trim() !== '') {
          // Check if this value should trigger an alert
          let shouldAlert = false;
          let alertType = '';
          
          // Check against WHO LCG alert values
          if (fieldName.includes('Baseline_FHR')) {
            const fhr = parseInt(value);
            if (!isNaN(fhr) && (fhr < 110 || fhr >= 160)) {
              shouldAlert = true;
              alertType = 'FHR';
            }
          } else if (fieldName.includes('Pulse')) {
            const pulse = parseInt(value);
            if (!isNaN(pulse) && (pulse < 60 || pulse >= 120)) {
              shouldAlert = true;
              alertType = 'Pulse';
            }
          } else if (fieldName.includes('Systolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && (bp < 80 || bp >= 140)) {
              shouldAlert = true;
              alertType = 'Systolic BP';
            }
          } else if (fieldName.includes('Diastolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && bp >= 90) {
              shouldAlert = true;
              alertType = 'Diastolic BP';
            }
          } else if (fieldName.includes('Temperature_C')) {
            const temp = parseFloat(value);
            if (!isNaN(temp) && (temp < 35.0 || temp >= 37.5)) {
              shouldAlert = true;
              alertType = 'Temperature C';
            }
          } else if (fieldName.includes('Companion') && value === 'N') {
            shouldAlert = true;
            alertType = 'Companion';
          } else if (fieldName.includes('Pain_Relief') && value === 'N') {
            shouldAlert = true;
            alertType = 'Pain Relief';
          } else if (fieldName.includes('Oral_fluids') && value === 'N') {
            shouldAlert = true;
            alertType = 'Oral Fluids';
          } else if (fieldName.includes('Mobility') && value === 'SP') {
            shouldAlert = true;
            alertType = 'Mobility';
          } else if (fieldName.includes('FHR_deceleration') && value === 'L') {
            shouldAlert = true;
            alertType = 'FHR deceleration';
          } else if (fieldName.includes('Amniotic_fluid') && (value === 'M+++' || value === 'B')) {
            shouldAlert = true;
            alertType = 'Amniotic fluid';
          } else if (fieldName.includes('Fetal_position') && (value === 'P' || value === 'T')) {
            shouldAlert = true;
            alertType = 'Fetal position';
          } else if (fieldName.includes('Caput') && value === '+++') {
            shouldAlert = true;
            alertType = 'Caput';
          } else if (fieldName.includes('Moulding') && value === '+++') {
            shouldAlert = true;
            alertType = 'Moulding';
          } else if (fieldName.includes('Urine') && (value === 'P++' || value === 'A++')) {
            shouldAlert = true;
            alertType = 'Urine';
          } else if (fieldName.includes('Contractions_per_10_min')) {
            const contractions = parseInt(value);
            if (!isNaN(contractions) && (contractions < 2 || contractions > 5)) {
              shouldAlert = true;
              alertType = 'Contractions per 10 min';
            }
          } else if (fieldName.includes('Duration_of_contractions')) {
            const duration = parseInt(value);
            if (!isNaN(duration) && (duration < 20 || duration > 60)) {
              shouldAlert = true;
              alertType = 'Duration of contractions';
            }
          }
          
          if (shouldAlert) {
            alertMap.set(alertType, true);
          }
        }
      });
      
      // Generate recommendations HTML
      console.log(`üìä Unique alert types found: ${alertMap.size}`);
      
      if (alertMap.size > 0) {
        let recommendationsHTML = '<div class="alert alert-info"><strong>üè• Clinical Recommendations:</strong><ul>';
        
        const sortedAlertTypes = Array.from(alertMap.keys()).sort();
        
        sortedAlertTypes.forEach(alertType => {
          let recommendation = '';
          
          switch (alertType) {
            case 'Companion':
              recommendation = 'Encourage companion presence. Supportive care improves birth outcomes and patient satisfaction.';
              break;
            case 'Pain Relief':
              recommendation = 'Review supportive care measures. Ensure adequate pain relief, mobility, and hydration.';
              break;
            case 'Oral Fluids':
              recommendation = 'Encourage oral fluid intake unless contraindicated. Maintain adequate hydration during labour.';
              break;
            case 'Mobility':
              recommendation = 'Encourage upright positions and mobility. Avoid prolonged supine position during labour.';
              break;
            case 'FHR deceleration':
              recommendation = 'Late decelerations detected. Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring.';
              break;
            case 'FHR':
              recommendation = 'Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring if pattern persists.';
              break;
            case 'Amniotic fluid':
              recommendation = 'Monitor for fetal distress. Consider specialist consultation for management.';
              break;
            case 'Fetal position':
              recommendation = 'Monitor labour progress closely. Consider specialist consultation if labour is not progressing.';
              break;
            case 'Caput':
              recommendation = 'Severe caput detected. Monitor for obstructed labour. Consider specialist consultation.';
              break;
            case 'Moulding':
              recommendation = 'Severe moulding detected. Monitor for obstructed labour. Consider specialist consultation.';
              break;
            case 'Urine':
              recommendation = 'High protein or acetone levels detected. Monitor for pre-eclampsia or ketoacidosis. Consider specialist consultation.';
              break;
            case 'Pulse':
              recommendation = 'Monitor maternal pulse. Check for underlying causes and consider cardiovascular assessment.';
              break;
            case 'Systolic BP':
            case 'Diastolic BP':
              recommendation = 'Monitor blood pressure closely. Consider antihypertensive therapy if severe hypertension.';
              break;
            case 'Temperature C':
              recommendation = 'Monitor for signs of infection. Consider antibiotics if infection suspected.';
              break;
            case 'Contractions per 10 min':
            case 'Duration of contractions':
              recommendation = 'Monitor and document progress. Consider specialist consultation if needed.';
              break;
            default:
              recommendation = 'Monitor closely and document findings. Consider specialist consultation if needed.';
          }
          
          recommendationsHTML += `<li><strong>${alertType}:</strong> ${recommendation}</li>`;
        });
        
        recommendationsHTML += '</ul></div>';
        drawerContent.innerHTML = recommendationsHTML;
      } else {
        drawerContent.innerHTML = '<div class="alert alert-success">‚úÖ No active alerts. All parameters within normal ranges.</div>';
      }
      
      console.log('=== showRecommendations() completed ===');
    }

    function getPatientIdFromUrl() {
      const params = new URLSearchParams(window.location.search);
      return params.get('patient');
    }

    // ============================================================================
    // LANGUAGE TOGGLE FUNCTION
    // ============================================================================
    function toggleLanguage() {
      if (typeof languageManager === 'undefined') {
        console.error('Language manager not loaded');
        return;
      }
      const currentLang = localStorage.getItem('preferredLanguage') || 'en';
      const newLang = currentLang === 'en' ? 'my' : 'en';
      languageManager.switchLanguage(newLang);
      
      // Update button text with flag and re-render sections
      setTimeout(() => {
        const toggleBtn = document.getElementById('languageToggle');
        if (toggleBtn) {
          toggleBtn.innerHTML = newLang === 'en' ? 'EN üá¨üáß' : 'MY üá≤üá≤';
        }
        renderSections(); // Re-render to apply new translations
      }, 100);
    }
    
    // Update language toggle button on load
    document.addEventListener('DOMContentLoaded', function() {
      const currentLang = localStorage.getItem('preferredLanguage') || 'en';
      const toggleBtn = document.getElementById('languageToggle');
      if (toggleBtn) {
        toggleBtn.innerHTML = currentLang === 'en' ? 'EN üá¨üáß' : 'MY üá≤üá≤';
      }
    });

    // Listen for language changes to re-render sections
    window.addEventListener('languageChanged', function() {
      if (typeof renderSections === 'function') {
        renderSections();
      }
      // Update button text with flag
      const currentLang = localStorage.getItem('preferredLanguage') || 'en';
      const toggleBtn = document.getElementById('languageToggle');
      if (toggleBtn) {
        toggleBtn.innerHTML = currentLang === 'en' ? 'EN üá¨üáß' : 'MY üá≤üá≤';
      }
    });

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    firebase.auth().onAuthStateChanged(async function(user) {
      if (!user) {
        window.location.href = "login.html";
        return;
      }
      
      await loadData();
      renderTimePills(); // Initial render
    });

    // State for time pills (no pagination needed - shows all)
    let currentPillPage = 0;
    
    // Select timepoint from pills (by index for reliability)
    function selectTimepoint(timeStrOrIndex) {
      let idx = -1;
      
      // If it's a number (index), use it directly
      if (typeof timeStrOrIndex === 'number') {
        idx = timeStrOrIndex;
      } else {
        // Otherwise, search by time string
        idx = state.timepoints.findIndex(tp => {
          const tpTime = tp.time || tp;
          return tpTime === timeStrOrIndex || tp === timeStrOrIndex;
        });
      }
      
      if (idx >= 0 && idx < state.timepoints.length) {
        currentIndex = idx;
        const tp = state.timepoints[idx];
        state.activeTimepoint = tp.time || tp;
        updateUI();
        renderTimePills();
        renderSections();
        // Update navigation buttons after selection
        updateNavigationButtons();
        updatePositionIndicator();
        console.log(`‚úÖ Selected timepoint ${idx}: ${state.activeTimepoint}`);
      } else {
        console.error(`‚ùå Failed to select timepoint: ${timeStrOrIndex}, idx: ${idx}, total: ${state.timepoints.length}`);
      }
    }

    // Render time pills
    function renderTimePills() {
      const wrapper = document.getElementById('timePillsWrapper');
      if (!wrapper) return;
      
      wrapper.innerHTML = '';
      
      const allTimepoints = state.timepoints;
      console.log(`üîç Rendering ${allTimepoints.length} timepoints, currentIndex: ${currentIndex}`);
      
      // Debug: Check for second stage timepoints
      const secondStageTimepoints = allTimepoints.filter(tp => tp.isSecondStage || tp.interval === '15min');
      console.log(`üéØ Found ${secondStageTimepoints.length} second stage timepoints:`, secondStageTimepoints.map(tp => tp.time || tp));
      
      // Show ALL timepoints (no more 5-pill limit)
      // Use scroll to see all
      allTimepoints.forEach((tp, idx) => {
        const timeStr = tp.time || tp;
        // Check if second stage using multiple methods
        const isSecondStage = tp.isSecondStage || (tp.interval === '15min');
        const isActive = idx === currentIndex;
        
        // Debug for second stage pills
        if (isSecondStage) {
          console.log(`  üîµ Second stage pill ${idx}: ${timeStr}, isSecondStage: ${tp.isSecondStage}, interval: ${tp.interval || 'unknown'}`);
        }
        
        if (idx === 0 || idx === 7 || idx === 14 || idx === allTimepoints.length - 1) {
          console.log(`  Pill ${idx}: ${timeStr}, isSecondStage: ${isSecondStage}, interval: ${tp.interval || 'unknown'}, isActive: ${isActive}`);
        }
        
        const pill = document.createElement('button');
        const pillClasses = `time-pill ${isSecondStage ? 'second-stage' : ''} ${isActive ? 'active' : ''}`;
        pill.className = pillClasses;
        pill.textContent = timeStr;
        pill.dataset.index = idx;
        pill.dataset.time = timeStr;
        pill.type = 'button'; // Prevent form submission
        
        // Use index-based selection for reliability
        pill.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log(`üñ±Ô∏è Clicked pill ${idx}: ${timeStr}`);
          selectTimepoint(idx); // Use index instead of time string
        };
        
        // Handle touch events for mobile (only on tap, not scroll)
        let touchStartTime = 0;
        let touchStartY = 0;
        pill.addEventListener('touchstart', (e) => {
          touchStartTime = Date.now();
          touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        pill.addEventListener('touchend', (e) => {
          const touchDuration = Date.now() - touchStartTime;
          const touchEndY = e.changedTouches[0].clientY;
          const touchDistance = Math.abs(touchEndY - touchStartY);
          
          // Only treat as tap if quick (< 300ms) and small movement (< 10px)
          if (touchDuration < 300 && touchDistance < 10) {
            e.preventDefault();
            e.stopPropagation();
            console.log(`üì± Tapped pill ${idx}: ${timeStr}`);
            selectTimepoint(idx);
          }
        }, { passive: false });
        
        // Debug: Log second stage pills
        if (isSecondStage) {
          console.log(`  ‚úÖ Created pill for ${timeStr} with classes: "${pillClasses}"`);
        }
        
        wrapper.appendChild(pill);
      });
      
      // Scroll to active pill (smooth scroll into view if needed)
      setTimeout(() => {
        const activePill = wrapper.querySelector('.time-pill.active');
        if (activePill) {
          activePill.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
      }, 100);
      
      // Update navigation buttons (stop at boundaries)
      updateNavigationButtons();
      
      // Update position indicator
      updatePositionIndicator();
    }
    
    // Update navigation button states (stop at boundaries)
    function updateNavigationButtons() {
      const prevBtn = document.getElementById('timePillsPrev');
      const nextBtn = document.getElementById('timePillsNext');
      
      if (!prevBtn || !nextBtn || !state.timepoints || state.timepoints.length === 0) {
        return; // Buttons not ready yet or no timepoints
      }
      
      const maxIndex = state.timepoints.length - 1;
      
      // Disable prev button at first pill, disable next button at last pill
      prevBtn.disabled = currentIndex === 0;
      nextBtn.disabled = currentIndex >= maxIndex;
    }
    
    // Update position indicator showing current position
    function updatePositionIndicator() {
      const positionEl = document.getElementById('timePillsPosition');
      
      if (!positionEl || !state.timepoints || state.timepoints.length === 0) {
        return;
      }
      
      const current = currentIndex + 1;
      const total = state.timepoints.length;
      positionEl.textContent = `${current} / ${total}`;
      
      // Only show indicator if there are many timepoints
      positionEl.style.display = state.timepoints.length > 5 ? 'block' : 'none';
    }

    // Scroll time pills (stops at first/last - no infinite rotation)
    function scrollTimePills(direction) {
      const maxIndex = state.timepoints.length - 1;
      
      // Stop at boundaries - don't allow going past first or last
      if (direction === 'prev' && currentIndex > 0) {
        selectTimepoint(currentIndex - 1); // Use index directly
      } else if (direction === 'next' && currentIndex < maxIndex) {
        selectTimepoint(currentIndex + 1); // Use index directly
      }
      // If already at boundary, do nothing (buttons will be disabled)
    }

    // Add current timepoint
    function addCurrentTimepoint() {
      const now = new Date();
      const h = now.getHours().toString().padStart(2, '0');
      const m = now.getMinutes().toString().padStart(2, '0');
      const timepoint = `${h}:${m}`;
      
      // Try to find closest existing timepoint
      const closestIdx = state.timepoints.findIndex(tp => {
        const tpTime = tp.time || tp;
        return tpTime >= timepoint;
      });
      
      if (closestIdx >= 0) {
        currentIndex = closestIdx;
        selectTimepoint(state.timepoints[closestIdx].time || state.timepoints[closestIdx]);
      }
    }

    // Open alerts drawer
    function openAlertsDrawer() {
      const drawer = document.getElementById('alertsDrawer');
      const backdrop = document.querySelector('.backdrop');
      if (drawer) drawer.classList.add('open');
      if (backdrop) backdrop.classList.add('active');
      
      // Show recommendations when drawer opens
      showRecommendations();
    }

    // Close alerts drawer
    function closeAlertsDrawer() {
      const drawer = document.getElementById('alertsDrawer');
      const backdrop = document.querySelector('.backdrop');
      if (drawer) drawer.classList.remove('open');
      if (backdrop) backdrop.classList.remove('active');
    }
    
    // Open view summary (like summary.html)
    function openViewSummary() {
      const patientId = getPatientIdFromUrl();
      if (patientId) {
        window.location.href = `summary-view.html?patient=${patientId}`;
      } else {
        alert('No patient ID found');
      }
    }

    // Note: Demo initialization is now handled in loadData() if no data exists
    // Don't initialize here to avoid conflicts with async loading
  </script>
</body>
</html>
