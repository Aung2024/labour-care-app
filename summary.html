<!DOCTYPE html>
<html lang="en">
<head>
  <title>WHO Labour Care Guide - Summary</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link rel="stylesheet" href="languages/language-switcher.css" />
  
  <style>
    /* End Treatment Button Styling */
    .btn-end-treatment {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      color: white;
      border: none;
      box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
    }
    
    .btn-end-treatment:hover {
      background: linear-gradient(135deg, #b91c1c, #991b1b);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(220, 38, 38, 0.4);
    }
    
    /* Resume Treatment Button Styling */
    .btn-resume-treatment {
      background: linear-gradient(135deg, #059669, #047857);
      color: white;
      border: none;
      box-shadow: 0 4px 15px rgba(5, 150, 105, 0.3);
    }
    
    .btn-resume-treatment:hover {
      background: linear-gradient(135deg, #047857, #065f46);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(5, 150, 105, 0.4);
    }
    
    /* End Treatment Modal Styling */
    .end-treatment-modal {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
    }
    
    .end-treatment-modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 0;
      border-radius: 15px;
      width: 90%;
      max-width: 600px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      animation: modalSlideIn 0.3s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-50px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .end-treatment-modal-header {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      color: white;
      padding: 20px 25px;
      border-radius: 15px 15px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .end-treatment-modal-header h3 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 600;
    }
    
    .end-treatment-modal-close {
      color: white;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s;
    }
    
    .end-treatment-modal-close:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    .end-treatment-modal-body {
      padding: 30px 25px;
    }
    
    .end-treatment-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .end-treatment-option {
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      padding: 25px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .end-treatment-option:hover {
      border-color: #3b82f6;
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(59, 130, 246, 0.15);
    }
    
    .end-treatment-option.selected {
      border-color: #3b82f6;
      background: linear-gradient(135deg, #eff6ff, #dbeafe);
      box-shadow: 0 8px 20px rgba(59, 130, 246, 0.2);
    }
    
    .end-treatment-option-icon {
      font-size: 3rem;
      margin-bottom: 15px;
      display: block;
    }
    
    .end-treatment-option.birth .end-treatment-option-icon {
      color: #10b981;
    }
    
    .end-treatment-option.transfer .end-treatment-option-icon {
      color: #f59e0b;
    }
    
    .end-treatment-option.other .end-treatment-option-icon {
      color: #6b7280;
    }
    
    .end-treatment-option h4 {
      margin: 0 0 10px 0;
      font-size: 1.2rem;
      font-weight: 600;
      color: #374151;
    }
    
    .end-treatment-option p {
      margin: 0;
      color: #6b7280;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    
    .end-treatment-modal-footer {
      padding: 20px 25px;
      border-top: 1px solid #e5e7eb;
      display: flex;
      justify-content: flex-end;
      gap: 15px;
    }
    
    .btn-confirm-end-treatment {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .btn-confirm-end-treatment:hover {
      background: linear-gradient(135deg, #b91c1c, #991b1b);
      transform: translateY(-1px);
    }
    
    .btn-confirm-end-treatment:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn-cancel-end-treatment {
      background: #6b7280;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .btn-cancel-end-treatment:hover {
      background: #4b5563;
    }
    
    /* Locked input styling */
    .locked-input {
      background-color: #f8f9fa !important;
      color: #6c757d !important;
      cursor: not-allowed !important;
      border: 1px solid #dee2e6 !important;
      opacity: 0.8 !important;
    }
    
    .lock-indicator {
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      color: #6c757d;
      font-size: 12px;
      pointer-events: none;
      z-index: 10;
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid #dee2e6;
    }
    
    .form-group {
      position: relative;
    }
    
    /* Ensure form groups have relative positioning for lock indicators */
    .form-group .form-control {
      position: relative;
    }
    
    /* Locked input container styling */
    .form-group:has(.locked-input) {
      opacity: 0.9;
    }
    
    .form-group:has(.locked-input) label {
      color: #6c757d;
      font-weight: 500;
    }
    
    /* Badge styling for locked status */
    .badge.bg-secondary {
      background-color: #6c757d !important;
      color: white !important;
    }
    
    /* Hover effect for locked inputs */
    .locked-input:hover {
      background-color: #e9ecef !important;
      border-color: #ced4da !important;
    }
  </style>
  
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
<script src="js/firebase.js"></script>
<script src="languages/language-manager.js"></script>
</head>
<body>
  <!-- Professional Header -->
  <div class="medical-header">
    <div class="header-content">
      <div class="header-left">
        <div class="app-title">üë©‚Äç‚öïÔ∏è <span data-i18n="appTitle">Labour Care Guide</span></div>
        <div class="page-subtitle"><span data-i18n="pageSubtitle">WHO Labour Care Summary Form</span></div>
  </div>
      <div class="header-right">
        <button class="btn btn-outline-light btn-sm" onclick="firebase.auth().signOut(); localStorage.clear(); window.location='login.html';">
          <i class="fas fa-sign-out-alt"></i> <span data-i18n="logout">Logout</span>
        </button>
      </div>
    </div>
  </div>

  <div class="main-container">
    <!-- Patient Information Card -->
    <div class="patient-card">
      <div class="card-header" onclick="togglePatientInfo()" style="cursor: pointer;">
        <h3><i class="fas fa-user-injured"></i> <span data-i18n="patientInformation">Patient Information</span></h3>
        <div class="toggle-icon">
          <i class="fas fa-chevron-down" id="toggleIcon"></i>
        </div>
      </div>
      <div class="patient-form" id="patientForm">
        <div class="form-row">
          <div class="form-group">
            <label for="p_name" data-i18n="patientName">Patient Name</label>
            <input type="text" id="p_name" class="form-control" data-i18n-placeholder="formLabels.enterPatientName" placeholder="Enter patient name">
          </div>
          <div class="form-group">
            <label for="p_age" data-i18n="age">Age</label>
            <input type="number" id="p_age" class="form-control" data-i18n-placeholder="formLabels.enterAge" placeholder="Age">
          </div>
          <div class="form-group">
            <label for="p_parity" data-i18n="parity">Parity</label>
            <input type="number" id="p_parity" class="form-control" data-i18n-placeholder="formLabels.enterParity" placeholder="Parity">
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label for="p_onset" data-i18n="labourOnset">Labour Onset</label>
            <select id="p_onset" class="form-control">
              <option value="" data-i18n="formLabels.selectOnsetType">Select onset type</option>
          <option value="Spontaneous" data-i18n="formLabels.spontaneous">Spontaneous</option>
          <option value="Induced" data-i18n="formLabels.induced">Induced</option>
        </select>
      </div>
          <div class="form-group">
            <label for="p_active" data-i18n="activeLabourDiagnosis">Active Labour Diagnosis</label>
            <input type="date" id="p_active" class="form-control">
    </div>
          <div class="form-group">
            <label for="p_membrane" data-i18n="rupturedMembranes">Ruptured Membranes</label>
            <input type="datetime-local" id="p_membrane" class="form-control">
    </div>
        </div>
        <div class="form-row">
          <div class="form-group full-width">
            <label for="p_risk" data-i18n="riskFactors">Risk Factors</label>
            <textarea id="p_risk" class="form-control" rows="2" data-i18n-placeholder="formLabels.enterRiskFactors" placeholder="Enter any risk factors"></textarea>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label for="startingTime"><strong data-i18n="activeFirstStageStartTime">Active First Stage Start Time:</strong></label>
            <input type="time" id="startingTime" class="form-control" data-i18n-placeholder="formLabels.enterTime" placeholder="08:00">
          </div>
          <div class="form-group">
            <label for="secondStageTime"><strong data-i18n="secondStageStartTime">Second Stage Start Time:</strong></label>
            <input type="time" id="secondStageTime" class="form-control" data-i18n-placeholder="formLabels.enterTime" placeholder="16:00">
          </div>
        </div>
        <div class="form-row" id="secondStageControls" style="display: none;">
          <div class="form-group full-width">
            <button type="button" class="btn btn-success" onclick="confirmSecondStage()">
              <i class="fas fa-check"></i> <span data-i18n="confirmSecondStage">Confirm Second Stage</span>
            </button>
            <small class="form-text text-muted" data-i18n="confirmSecondStageDesc">Click to confirm patient has entered second stage of labour</small>
          </div>
        </div>
      </div>
    </div>

    <!-- Starting Time Requirement Message -->
    <div class="starting-time-requirement" id="startingTimeRequirement">
      <div class="alert alert-info">
        <i class="fas fa-info-circle"></i>
        <strong data-i18n="nextStepRequired">Next Step Required:</strong> <span data-i18n="enterActiveFirstStage">Please enter the <strong>Active First Stage Start Time</strong> above to generate the labour monitoring tables.</span> 
        <span data-i18n="cervicalDilatation">This should be when the patient's cervical dilatation reached 5cm or more.</span>
      </div>
    </div>

    <!-- Second Stage Detection Section -->
    <div class="second-stage-card" id="secondStageCard" style="display: none;">
      <div class="card-header">
        <h4><i class="fas fa-baby"></i> <span data-i18n="secondStageDetection">Second Stage Detection</span></h4>
      </div>
      <div class="card-content">
        <div class="alert alert-info">
          <i class="fas fa-info-circle"></i>
          <strong data-i18n="patientEnteredSecondStage">Patient has entered Second Stage of Labour</strong>
        </div>
        <div class="second-stage-info">
          <p><strong data-i18n="activeFirstStage">Active First Stage:</strong> <span id="firstStageDuration"></span></p>
          <p><strong data-i18n="secondStageStarted">Second Stage Started:</strong> <span id="secondStageStartDisplay"></span></p>
        </div>
      </div>
    </div>

    <!-- Floating Action Buttons -->
    <div class="floating-actions">
      <a href="list.html" class="floating-btn btn-back">
        <i class="fas fa-arrow-left"></i>
        <span data-i18n="backToList">Back to List</span>
      </a>
      <button class="floating-btn btn-save" onclick="saveData()">
        <i class="fas fa-save"></i>
        <span data-i18n="saveProgress">Save Progress</span>
      </button>
      <a href="summary-view.html?patient=" class="floating-btn btn-view" target="_blank" id="viewSummaryBtn">
        <i class="fas fa-eye"></i>
        <span data-i18n="viewSummary">View Summary</span>
      </a>
      <button class="floating-btn btn-end-treatment" id="endTreatmentBtn" onclick="handleEndTreatmentClick()">
        <i class="fas fa-flag-checkered"></i>
        <span data-i18n="endTreatment">End Treatment</span>
      </button>
    </div>

    <!-- Success Message Display -->
    <div id="successMessage" class="success-message" style="display: none;">
      <i class="fas fa-check-circle"></i>
      <span data-i18n="savedSuccessfully">Saved Successfully</span>
    </div>

    <!-- Labour Care Summary Table -->
    <div class="summary-container">
      <div class="table-header">
        <h3><i class="fas fa-clipboard-list"></i> <span data-i18n="labourCareSummary">Labour Care Summary</span></h3>
        <p class="table-subtitle" data-i18n="completeFormBelow">Complete the form below for each time interval during active labour</p>
      </div>
      
      <!-- Supportive Care Table -->
      <div class="section-table" id="supportiveCareSection">
        <div class="section-header" onclick="toggleSection('supportiveCareSection')">
          <h4><i class="fas fa-hands-helping"></i> <span data-i18n="supportiveCare">Supportive Care</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="supportiveCareToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="supportiveCareTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- FHR Table Section -->
      <div class="section-table" id="fhrSection">
        <div class="section-header" onclick="toggleSection('fhrSection')">
          <h4><i class="fas fa-heartbeat"></i> <span data-i18n="fhr">FHR</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="fhrToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="fhrTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Baby Table Section -->
      <div class="section-table" id="babySection">
        <div class="section-header" onclick="toggleSection('babySection')">
          <h4><i class="fas fa-baby"></i> <span data-i18n="baby">Baby</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="babyToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="babyTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Woman Table Section -->
      <div class="section-table" id="womanSection">
        <div class="section-header" onclick="toggleSection('womanSection')">
          <h4><i class="fas fa-female"></i> <span data-i18n="woman">Woman</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="womanToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="womanTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Contractions Section -->
      <div class="section-table" id="contractionsSection">
        <div class="section-header" onclick="toggleSection('contractionsSection')">
          <h4><i class="fas fa-utensils"></i> <span data-i18n="contractions">Contractions</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="contractionsToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="contractionsTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Labour Progress Section -->
      <div class="section-table" id="labourProgressSection">
        <div class="section-header" onclick="toggleSection('labourProgressSection')">
          <h4><i class="fas fa-chart-line"></i> Labour Progress</h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="labourProgressToggleIcon"></i>
          </div>
        </div>
        
        <!-- Cervix Plot Table -->
        <div class="table-wrapper">
          <h5><i class="fas fa-chart-area"></i> <span data-i18n="cervixPlot">Cervix Plot</span></h5>
          <div class="plotting-container">
            <canvas id="cervixChart" width="800" height="400"></canvas>
            <div class="plot-controls">
              <button type="button" class="btn btn-sm btn-primary" onclick="savePlotData()">
                <i class="fas fa-save"></i> <span data-i18n="savePlot">Save Plot</span>
              </button>
              <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearCervixChart()">
                <i class="fas fa-eraser"></i> <span data-i18n="clearNewPoints">Clear New Points</span>
              </button>
              <button type="button" class="btn btn-sm btn-danger" onclick="clearAllCervixData()">
                <i class="fas fa-trash"></i> <span data-i18n="clearAllPlot">Clear All Plot</span>
              </button>
            </div>
          </div>
        </div>
        
        <!-- Descent Plot Table -->
        <div class="table-wrapper">
          <h5><i class="fas fa-chart-line"></i> <span data-i18n="descentPlot">Descent Plot</span></h5>
          <div class="plotting-container">
            <canvas id="descentChart" width="800" height="400"></canvas>
            <div class="plot-controls">
              <button type="button" class="btn btn-sm btn-primary" onclick="savePlotData()">
                <i class="fas fa-save"></i> <span data-i18n="savePlot">Save Plot</span>
              </button>
              <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearDescentChart()">
                <i class="fas fa-eraser"></i> <span data-i18n="clearNewPoints">Clear New Points</span>
              </button>
              <button type="button" class="btn btn-sm btn-danger" onclick="clearAllDescentData()">
                <i class="fas fa-trash"></i> <span data-i18n="clearAllPlot">Clear All Plot</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Medication Table Section -->
      <div class="section-table" id="medicationSection">
        <div class="section-header" onclick="toggleSection('medicationSection')">
          <h4><i class="fas fa-pills"></i> <span data-i18n="medication">Medication</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="medicationToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="medicationTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Shared Decision-Making Section -->
      <div class="section-table" id="decisionMakingSection">
        <div class="section-header" onclick="toggleSection('decisionMakingSection')">
          <h4><i class="fas fa-comments"></i> <span data-i18n="sharedDecisionMaking">Shared Decision-Making</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="decisionMakingToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="decisionMakingTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Initials Table Section -->
      <div class="section-table" id="initialsSection">
        <div class="section-header" onclick="toggleSection('initialsSection')">
          <h4><i class="fas fa-signature"></i> <span data-i18n="initials">Initials</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="initialsToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="initialsTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>
    </div>

    <!-- Clinical Recommendations Section -->
    <div class="recommendations-section">
      <h4><i class="fas fa-stethoscope"></i> <span data-i18n="clinicalRecommendations">Clinical Recommendations</span></h4>
      <div class="mb-2">
        <button type="button" class="btn btn-sm btn-outline-primary" onclick="testRecommendations()">
          <i class="fas fa-test-tube"></i> <span data-i18n="testRecommendations">Test Recommendations</span>
        </button>
        <button type="button" class="btn btn-sm btn-outline-secondary ms-2" onclick="clearRecommendations()">
          <i class="fas fa-eraser"></i> <span data-i18n="clearRecommendations">Clear Recommendations</span>
        </button>
        <button type="button" class="btn btn-sm btn-outline-info ms-2" onclick="testHybridTimeColumns()">
          <i class="fas fa-clock"></i> Test Hybrid Time Columns
        </button>
        <button type="button" class="btn btn-sm btn-outline-warning ms-2" onclick="forceHybridGeneration()">
          <i class="fas fa-magic"></i> Force Hybrid Generation
        </button>
      </div>
      <div id="recommendations" class="recommendations-content">
        <!-- Recommendations will be populated here -->
      </div>
    </div>
  </div>

  <!-- End Treatment Modal -->
  <div id="endTreatmentModal" class="end-treatment-modal">
    <div class="end-treatment-modal-content">
      <div class="end-treatment-modal-header">
        <h3><i class="fas fa-flag-checkered"></i> <span data-i18n="endTreatmentModal">End Treatment</span></h3>
        <button class="end-treatment-modal-close" onclick="closeEndTreatmentModal()">&times;</button>
      </div>
      <div class="end-treatment-modal-body">
        <p class="mb-4 text-muted" data-i18n="selectOutcome">Please select the outcome of this treatment:</p>
        
        <div class="end-treatment-options">
          <div class="end-treatment-option birth" onclick="selectEndTreatmentOption('birth')">
            <i class="fas fa-baby end-treatment-option-icon"></i>
            <h4 data-i18n="birth">Birth</h4>
            <p data-i18n="successfulDelivery">Successful delivery - record baby information and birth details</p>
          </div>
          
          <div class="end-treatment-option transfer" onclick="selectEndTreatmentOption('transfer')">
            <i class="fas fa-ambulance end-treatment-option-icon"></i>
            <h4 data-i18n="transfer">Transfer</h4>
            <p data-i18n="patientTransferred">Patient transferred to another facility for further care</p>
          </div>
          
          <div class="end-treatment-option other" onclick="selectEndTreatmentOption('other')">
            <i class="fas fa-ellipsis-h end-treatment-option-icon"></i>
            <h4 data-i18n="other">Other</h4>
            <p data-i18n="otherOutcome">Other outcome - specify details and reason</p>
          </div>
        </div>
      </div>
      <div class="end-treatment-modal-footer">
        <button class="btn-cancel-end-treatment" onclick="closeEndTreatmentModal()" data-i18n="cancel">Cancel</button>
        <button class="btn-confirm-end-treatment" id="confirmEndTreatmentBtn" onclick="confirmEndTreatment()" disabled data-i18n="confirmEndTreatment">
          Confirm & End Treatment
        </button>
      </div>
    </div>
  </div>

  <footer class="footer">
    <p>&copy; 2025 Labour Care App &mdash; <span data-i18n="footer">Designed for clinical excellence</span></p>
  </footer>

  <script>
    // Get patient ID from URL parameters
    function getPatientIdFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('patient');
    }

    // Get patient ID from URL parameters
    const params = new URLSearchParams(window.location.search);
    const patientId = params.get("patient");
    
    console.log('Patient ID from URL:', patientId);



    const sections = {
      "Supportive Care": [
        "Companion",
        "Pain_Relief", 
        "Oral_fluids",
        "Mobility"
      ],
      "FHR": [
        "Baseline FHR",
        "FHR deceleration"
      ],
      "Baby": [
        "Amniotic fluid",
        "Fetal position",
        "Caput",
        "Moulding"
      ],
      "Woman": [
        "Pulse",
        "Systolic BP",
        "Diastolic BP",
        "Temperature C",
        "Urine"
      ],
      "Contractions": [
        "Contractions per 10 min",
        "Duration of contractions"
      ],
      "Labour Progress": [
        "Cervix [Plot X]",
        "Descent [Plot O]"
      ],
      "Cervix Plot": [
        "Cervix [Plot X]"
      ],
      "Descent Plot": [
        "Descent [Plot O]"
      ],
      "Medication": [
        "Oxytocin (U/L, drops/min)",
        "Medicine",
        "IV fluids"
      ],
      "Shared Decision-Making": [
        "ASSESSMENT",
        "PLAN",
        "INITIALS"
      ]
    };

    const dropdownOptions = {
      // Supportive care
      "Companion": ["Y", "N", "D"],
      "Pain_Relief": ["Y", "N", "D"],
      "Oral_fluids": ["Y", "N", "D"],
      "Mobility": ["M", "SP"],

      // Baby
      "FHR deceleration": ["N", "E", "L", "V"],
      "Amniotic fluid": ["I", "C", "M", "M+", "M++", "M+++", "B"],
      "Fetal position": ["A", "P", "T"],
      "Caput": ["0", "+", "++", "+++"],
      "Moulding": ["0", "+", "++", "+++"],

      // Woman
      "Pulse": ["<60", "60-120", ">120"],
      "Systolic BP": ["<90", "90-140", ">140"],
      "Diastolic BP": ["<60", "60-90", ">90"],
      "Temperature C": ["<36", "36-37.5", ">37.5"],
      "Urine": ["-/-", "P-", "P Trace", "P+", "P++", "A-", "A Trace", "A+", "A++"],

      // Labour Progress
      "Contractions per 10 min": ["<2", "2-5", ">5"],
      "Duration of contractions": ["<20s", "20-50s", ">50s"],
      "Cervix [Plot X]": ["", "X"],
      "Descent [Plot O]": ["", "O"],

      // Medication
      "Oxytocin (U/L, drops/min)": ["None", "Started", "Stopped"],
      "Medicine": ["None", "Started", "Stopped"],
      "IV fluids": ["None", "Started", "Stopped"]
    };

    const alertValues = {
      // Supportive care - WHO LCG values
      "Companion": ["N"], // N = No companion
      "Pain_Relief": ["N"], // N = No pain relief
      "Oral_fluids": ["N"], // N = No oral fluid
      "Mobility": ["SP"], // SP = Supine position

      // Baby - WHO LCG values
      "Baseline FHR": [], // Will be handled by number input range checking
      "FHR deceleration": ["L"], // L = Late decelerations
      "Amniotic fluid": ["M+++", "B"], // M+++ = Severe meconium, B = Bloody
      "Fetal position": ["P", "T"], // P = Posterior, T = Transverse
      "Caput": ["+++"], // +++ = Severe caput
      "Moulding": ["+++"], // +++ = Severe moulding

      // Woman - WHO LCG values
      "Pulse": [], // Will be handled by number input range checking
      "Systolic BP": [], // Will be handled by number input range checking
      "Diastolic BP": [], // Will be handled by number input range checking
      "Temperature C": [], // Will be handled by number input range checking
      "Urine": [], // Will be handled by dropdown selection

      // Contractions - WHO LCG values
      "Contractions per 10 min": [], // Will be handled by number input range checking
      "Duration of contractions": [] // Will be handled by number input range checking
    };

    // WHO Alert Values for display in alert cells
    const whoAlertValues = {
      // Supportive care
      "Companion": "N",
      "Pain_Relief": "N", 
      "Oral_fluids": "N",
      "Mobility": "SP",

      // Baby
      "Baseline FHR": "110-160",
      "FHR deceleration": "L",
      "Amniotic fluid": "M+++, B",
      "Fetal position": "P, T",
      "Caput": "+++",
      "Moulding": "+++",

      // Woman
      "Pulse": "<60, >120",
      "Systolic BP": "<90, >140",
      "Diastolic BP": ">90",
      "Temperature C": "<36, >37.5",
      "Urine": "P++, A++",

      // Contractions
      "Contractions per 10 min": "<2, >5",
      "Duration of contractions": "<20s, >50s"
    };

    // Check and highlight alert values
    function checkAndHighlightAlert(element) {
      const fieldName = element.name;
      const value = element.value;
      
      console.log('checkAndHighlightAlert called for:', fieldName, 'value:', value);
      
      // Remove existing alert highlighting
      element.classList.remove('alert-value');
      
      // Check if this field has alert values defined
      if (alertValues[fieldName] && alertValues[fieldName].length > 0) {
        // Check if current value matches any alert value
        if (alertValues[fieldName].includes(value)) {
          element.classList.add('alert-value');
        }
      }
      
      // Special handling for number inputs (Baseline FHR, Pulse, BP, Temperature)
      if (element.type === 'number') {
        const numValue = parseFloat(value);
        if (!isNaN(numValue)) {
          switch(fieldName) {
            case 'Baseline FHR':
              if (numValue < 110 || numValue > 160) {
                element.classList.add('alert-value');
              }
              break;
            case 'Pulse':
              if (numValue < 60 || numValue > 120) {
                element.classList.add('alert-value');
              }
              break;
            case 'Systolic BP':
              if (numValue < 90 || numValue > 140) {
                element.classList.add('alert-value');
              }
              break;
            case 'Diastolic BP':
              if (numValue > 90) {
                element.classList.add('alert-value');
              }
              break;
            case 'Temperature C':
              if (numValue < 36 || numValue > 37.5) {
                element.classList.add('alert-value');
              }
              break;
            default:
                      // Check for contractions fields by name pattern
        if (fieldName.includes('Contractions_per_10_min')) {
          if (numValue < 2 || numValue > 5) {
            element.classList.add('alert-value');
            console.log('Alert added for Contractions per 10 min:', numValue);
          }
        } else if (fieldName.includes('Duration_of_contractions')) {
          if (numValue < 20 || numValue > 40) {
            element.classList.add('alert-value');
            console.log('Alert added for Duration of contractions:', numValue);
          }
        }
              break;
          }
        }
      }
    }

    // Add event listeners to form elements
    function addFormEventListeners() {
      console.log('addFormEventListeners() called');
      
      // Add event listeners to all selects and inputs
      const allSelects = document.querySelectorAll('select');
      const allInputs = document.querySelectorAll('input');
      
      console.log('Found selects:', allSelects.length, 'inputs:', allInputs.length);
      
      allSelects.forEach(select => {
        select.addEventListener('change', function() {
          console.log('Select changed:', this.name, 'value:', this.value);
          checkAndHighlightAlert(this);
          // Recommendations will be shown when needed, not on every change
        });
      });
      
      allInputs.forEach(input => {
        input.addEventListener('input', function() {
          console.log('Input changed:', this.name, 'value:', this.value);
          checkAndHighlightAlert(this);
          // Recommendations will be shown when needed, not on every change
        });
        input.addEventListener('change', function() {
          console.log('Input changed (change event):', this.name, 'value:', this.value);
          checkAndHighlightAlert(this);
          // Recommendations will be shown when needed, not on every change
        });
      });
      
      console.log('Event listeners added successfully');
    }

    // Test function to manually trigger recommendations
    function testRecommendations() {
      console.log('üß™ Testing recommendations function...');
      
      // Check if recommendations div exists
      const recommendationsDiv = document.getElementById('recommendations');
      console.log('Recommendations div found:', recommendationsDiv);
      
      // Check if there are any form elements
      const allInputs = document.querySelectorAll('input, select');
      console.log('Total form elements found:', allInputs.length);
      
      // Check if there are any values in the form
      const inputsWithValues = Array.from(allInputs).filter(input => input.value && input.value.trim() !== '');
      console.log('Form elements with values:', inputsWithValues.length);
      inputsWithValues.forEach(input => {
        console.log('Input with value:', input.name, '=', input.value);
      });
      
      // Clear previous recommendations and tracking before testing
      shownRecommendations.clear();
      isProcessingRecommendations = false;
      lastRecommendationsCall = 0; // Reset debounce timer
      console.log('üîÑ Reset recommendations tracking for testing');
      showRecommendations();
    }
    
    // Test function to debug hybrid time columns
    function testHybridTimeColumns() {
      console.log('üß™ Testing hybrid time columns...');
      console.log('Current state:');
      console.log(`  activeFirstStageStartTime: ${activeFirstStageStartTime}`);
      console.log(`  secondStageStartTime: ${secondStageStartTime}`);
      console.log(`  isSecondStageActive: ${isSecondStageActive}`);
      
      console.log('Before generateHybridTimeColumns():');
      console.log(`  contractionsTimeCols: ${contractionsTimeCols.length} columns:`, contractionsTimeCols);
      console.log(`  babyBaselineTimeCols: ${babyBaselineTimeCols.length} columns:`, babyBaselineTimeCols);
      
      // Generate hybrid time columns
      generateHybridTimeColumns();
      
      console.log('After generateHybridTimeColumns():');
      console.log(`  contractionsTimeCols: ${contractionsTimeCols.length} columns:`, contractionsTimeCols);
      console.log(`  babyBaselineTimeCols: ${babyBaselineTimeCols.length} columns:`, babyBaselineTimeCols);
      
      // Test isSecondStageTime function
      if (secondStageStartTime && isSecondStageActive) {
        console.log('Testing isSecondStageTime function:');
        contractionsTimeCols.forEach(time => {
          const isSecondStage = isSecondStageTime(time);
          console.log(`  ${time}: ${isSecondStage ? 'üü¢ Second Stage' : 'üîµ First Stage'}`);
        });
      }
    }
    
    // Force hybrid generation for testing
    function forceHybridGeneration() {
      console.log('üîß Force hybrid generation called');
      
      if (!activeFirstStageStartTime) {
        alert('Please set Active First Stage Start Time first');
        return;
      }
      
      if (!secondStageStartTime) {
        alert('Please set Second Stage Start Time first');
        return;
      }
      
      // Force second stage to be active
      isSecondStageActive = true;
      
      console.log('üîÑ Forcing hybrid time column generation...');
      generateHybridTimeColumns();
      
      console.log('üîÑ Regenerating tables...');
      regenerateContractionsAndFHRTables();
      
      console.log('üé® Updating colors...');
      updateSecondStageColors();
      
      console.log('‚úÖ Force hybrid generation completed');
    }
    
    // Function to clear recommendations and reset tracking
    function clearRecommendations() {
      const recommendationsDiv = document.getElementById('recommendations');
      if (recommendationsDiv) {
        recommendationsDiv.innerHTML = '';
        shownRecommendations.clear();
        isProcessingRecommendations = false;
        lastRecommendationsCall = 0; // Reset debounce timer
        console.log('‚úÖ Recommendations cleared and tracking reset');
      }
    }

    // Global variable to track already shown recommendations
    let shownRecommendations = new Set();
    let isProcessingRecommendations = false; // Prevent multiple simultaneous calls
    let lastRecommendationsCall = 0; // Track when recommendations were last called
    
    // Show clinical recommendations based on alert values
    // OLD COMPLEX FUNCTION - COMMENTED OUT TO PREVENT DUPLICATES
    /*
    function showRecommendations() {
      console.log('=== showRecommendations() called ===');
      
      // Debounce: prevent multiple calls within 500ms
      const now = Date.now();
      if (now - lastRecommendationsCall < 500) {
        console.log('‚è≠Ô∏è Skipping recommendations call - too soon after last call');
        return;
      }
      lastRecommendationsCall = now;
      
      // Prevent multiple simultaneous calls
      if (isProcessingRecommendations) {
        console.log('‚è≥ Already processing recommendations, skipping...');
        return;
      }
      
      isProcessingRecommendations = true;
      
      const recommendationsDiv = document.getElementById('recommendations');
      if (!recommendationsDiv) {
        console.log('‚ùå Recommendations div not found yet');
        isProcessingRecommendations = false;
        return;
      }
      
      console.log('‚úÖ Found recommendations div, checking for alerts...');
      console.log('Recommendations div content before:', recommendationsDiv.innerHTML);
      
      // Clear recommendations tracking for fresh start
      // This ensures we always process alerts from scratch
      shownRecommendations.clear();
      console.log('üîÑ Cleared recommendations tracking for fresh start');
      
      const activeAlerts = new Set();
      
      // Check all form elements for alert values
      const allInputs = document.querySelectorAll('input, select');
      console.log('Found form elements:', allInputs.length);
      
      // Debug: Show all form element names
      const allFieldNames = Array.from(allInputs).map(input => input.name);
      console.log('All field names:', allFieldNames);
      
      allInputs.forEach(input => {
        if (input.value && input.value.trim() !== '') {
          const fieldName = input.name;
          const value = input.value;
          console.log('Checking field:', fieldName, 'with value:', value);
          
          // Check if this value should trigger an alert
          let shouldAlert = false;
          let alertReason = '';
          
          // Check against WHO LCG alert values
          if (fieldName.includes('Baseline_FHR')) {
            const fhr = parseInt(value);
            if (!isNaN(fhr) && (fhr < 110 || fhr > 160)) {
              shouldAlert = true;
              alertReason = `FHR ${fhr} is outside normal range (110-160)`;
            }
          } else if (fieldName.includes('Pulse')) {
            const pulse = parseInt(value);
            if (!isNaN(pulse) && (pulse < 60 || pulse > 120)) {
              shouldAlert = true;
              alertReason = `Pulse ${pulse} is outside normal range (60-120)`;
            }
          } else if (fieldName.includes('Systolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && (bp < 90 || bp > 140)) {
              shouldAlert = true;
              alertReason = `Systolic BP ${bp} is outside normal range (90-140)`;
            }
          } else if (fieldName.includes('Diastolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && bp > 90) {
              shouldAlert = true;
              alertReason = `Diastolic BP ${bp} is above normal range (>90)`;
            }
          } else if (fieldName.includes('Temperature_C')) {
            const temp = parseFloat(value);
            if (!isNaN(temp) && (temp < 36 || temp > 37.5)) {
              shouldAlert = true;
              alertReason = `Temperature ${temp}¬∞C is outside normal range (36-37.5)`;
            }
          } else if (fieldName.includes('Pain_Relief') && value === 'N') {
            shouldAlert = true;
            alertReason = 'No pain relief provided';
          } else if (fieldName.includes('Oral_fluids') && value === 'N') {
            shouldAlert = true;
            alertReason = 'No oral fluids provided';
          } else if (fieldName.includes('Mobility') && value === 'SP') {
            shouldAlert = true;
            alertReason = 'Patient in supine position - encourage mobility';
          } else if (fieldName.includes('FHR_deceleration') && value === 'L') {
            shouldAlert = true;
            alertReason = 'Late FHR decelerations detected - assess fetal condition';
          } else if (fieldName.includes('Amniotic_fluid') && (value === 'M+++' || value === 'B')) {
            shouldAlert = true;
            alertReason = `Amniotic fluid: ${value} - monitor for fetal distress`;
          } else if (fieldName.includes('Fetal_position') && (value === 'P' || value === 'T')) {
            shouldAlert = true;
            alertReason = `Fetal position: ${value} - monitor labour progress`;
          } else if (fieldName.includes('Caput') && value === '+++') {
            shouldAlert = true;
            alertReason = 'Severe caput detected - monitor for obstructed labour';
          } else if (fieldName.includes('Moulding') && value === '+++') {
            shouldAlert = true;
            alertReason = 'Severe moulding detected - monitor for obstructed labour';
          } else if (fieldName.includes('Contractions_per_10_min')) {
            const contractions = parseInt(value);
            if (!isNaN(contractions) && (contractions < 2 || contractions > 5)) {
              shouldAlert = true;
              alertReason = `Contractions: ${contractions} per 10 min - outside normal range (2-5)`;
            }
          } else if (fieldName.includes('Duration_of_contractions')) {
            const duration = parseInt(value);
            if (!isNaN(duration) && (duration < 20 || duration > 50)) {
              shouldAlert = true;
              alertReason = `Contraction duration: ${duration}s - outside normal range (20-50s)`;
            }
          }
          
          if (shouldAlert) {
            // Extract field name for display (remove time suffix)
            const displayName = fieldName.split('_').slice(0, -2).join(' ').replace(/_/g, ' ');
            const alertKey = `${displayName}: ${alertReason}`;
            
            // Only add if this exact alert hasn't been shown before
            if (!shownRecommendations.has(alertKey)) {
              activeAlerts.add(alertKey);
              shownRecommendations.add(alertKey);
              console.log('‚úÖ New alert added:', alertKey);
            } else {
              console.log('‚è≠Ô∏è Alert already shown, skipping duplicate:', alertKey);
            }
          }
        }
      });
      
      // Generate recommendations HTML
      console.log('üìä Summary:');
      console.log(`  - Total form elements checked: ${allInputs.length}`);
      console.log(`  - Unique alerts found: ${activeAlerts.size}`);
      console.log(`  - Recommendations tracking size: ${shownRecommendations.size}`);
      
      if (activeAlerts.size > 0) {
        let recommendationsHTML = '';
        
        // Add clinical recommendations
        recommendationsHTML += '<div class="alert alert-info"><strong>üè• Clinical Recommendations:</strong><ul>';
        activeAlerts.forEach(alert => {
          const [field, reason] = alert.split(': ');
          
          // Provide specific recommendations based on field type
          let recommendation = '';
          if (field.includes('FHR') || field.includes('Baseline')) {
            recommendation = 'Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring if pattern persists.';
          } else if (field.includes('Pulse')) {
            recommendation = 'Monitor maternal pulse. Check for underlying causes and consider cardiovascular assessment.';
          } else if (field.includes('BP')) {
            recommendation = 'Monitor blood pressure closely. Consider antihypertensive therapy if severe hypertension.';
          } else if (field.includes('Temperature')) {
            recommendation = 'Monitor for signs of infection. Consider antibiotics if infection suspected.';
          } else if (field.includes('Pain') || field.includes('Mobility') || field.includes('Oral')) {
            recommendation = 'Review supportive care measures. Ensure adequate pain relief, mobility, and hydration.';
          } else {
            recommendation = 'Monitor and document progress. Consider specialist consultation if needed.';
          }
          
          recommendationsHTML += `<li><strong>${field}:</strong> ${recommendation}</li>`;
        });
        recommendationsHTML += '</ul></div>';
        
        recommendationsDiv.innerHTML = recommendationsHTML;
        console.log('‚úÖ Recommendations HTML set with alerts');
        console.log('Final HTML content:', recommendationsHTML);
      } else {
        recommendationsDiv.innerHTML = '<div class="alert alert-success">‚úÖ No active alerts. All parameters within normal ranges.</div>';
        console.log('‚úÖ Recommendations HTML set with no alerts message');
      }
      
      console.log('Final recommendations div content:', recommendationsDiv.innerHTML);
      console.log('=== showRecommendations() completed ===');
      
      // Reset processing flag
      isProcessingRecommendations = false;
    }
    */
    
    // NEW SIMPLE FUNCTION - NO DUPLICATES
    function showRecommendations() {
      console.log('=== showRecommendations() called ===');
      
      const recommendationsDiv = document.getElementById('recommendations');
      if (!recommendationsDiv) {
        console.log('‚ùå Recommendations div not found yet');
        return;
      }
      
      console.log('‚úÖ Found recommendations div, checking for alerts...');
      
      // Use a Map to track unique alerts by field type (not by individual values)
      const alertMap = new Map();
      
      // Check all form elements for alert values
      const allInputs = document.querySelectorAll('input, select');
      console.log('Found form elements:', allInputs.length);
      
      allInputs.forEach(input => {
        if (input.value && input.value.trim() !== '') {
          const fieldName = input.name;
          const value = input.value;
          
          // Check if this value should trigger an alert
          let shouldAlert = false;
          let alertType = '';
          
          // Check against WHO LCG alert values
          if (fieldName.includes('Baseline_FHR')) {
            const fhr = parseInt(value);
            if (!isNaN(fhr) && (fhr < 110 || fhr > 160)) {
              shouldAlert = true;
              alertType = 'FHR';
            }
          } else if (fieldName.includes('Pulse')) {
            const pulse = parseInt(value);
            if (!isNaN(pulse) && (pulse < 60 || pulse > 120)) {
              shouldAlert = true;
              alertType = 'Pulse';
            }
          } else if (fieldName.includes('Systolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && (bp < 90 || bp > 140)) {
              shouldAlert = true;
              alertType = 'Systolic BP';
            }
          } else if (fieldName.includes('Diastolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && bp > 90) {
              shouldAlert = true;
              alertType = 'Diastolic BP';
            }
          } else if (fieldName.includes('Temperature_C')) {
            const temp = parseFloat(value);
            if (!isNaN(temp) && (temp < 36 || temp > 37.5)) {
              shouldAlert = true;
              alertType = 'Temperature C';
            }
          } else if (fieldName.includes('Pain_Relief') && value === 'N') {
            shouldAlert = true;
            alertType = 'Pain Relief';
          } else if (fieldName.includes('Mobility') && value === 'SP') {
            shouldAlert = true;
            alertType = 'Mobility';
          } else if (fieldName.includes('FHR_deceleration') && (value === 'L' || value === 'V' || value === 'E')) {
            shouldAlert = true;
            alertType = 'FHR deceleration';
          } else if (fieldName.includes('Contractions_per_10_min')) {
            const contractions = parseInt(value);
            if (!isNaN(contractions) && (contractions < 2 || contractions > 5)) {
              shouldAlert = true;
              alertType = 'Contractions per 10 min';
            }
          } else if (fieldName.includes('Duration_of_contractions')) {
            const duration = parseInt(value);
            if (!isNaN(duration) && (duration < 20 || duration > 50)) {
              shouldAlert = true;
              alertType = 'Duration of contractions';
            }
          }
          
          if (shouldAlert) {
            // Store alert by type, not by individual field values
            alertMap.set(alertType, true);
          }
        }
      });
      
      // Generate recommendations HTML
      console.log(`üìä Unique alert types found: ${alertMap.size}`);
      
      if (alertMap.size > 0) {
        // Create recommendations HTML
        let recommendationsHTML = '<div class="alert alert-info"><strong>üè• Clinical Recommendations:</strong><ul>';
        
        // Convert Map keys to Array and sort for consistent display
        const sortedAlertTypes = Array.from(alertMap.keys()).sort();
        
        sortedAlertTypes.forEach(alertType => {
          let recommendation = '';
          
          // Generate specific recommendations based on alert type
          switch (alertType) {
            case 'Pain Relief':
              recommendation = 'Review supportive care measures. Ensure adequate pain relief, mobility, and hydration.';
              break;
            case 'Mobility':
              recommendation = 'Review supportive care measures. Ensure adequate pain relief, mobility, and hydration.';
              break;
            case 'FHR deceleration':
              recommendation = 'Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring if pattern persists.';
              break;
            case 'FHR':
              recommendation = 'Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring if pattern persists.';
              break;
            case 'Pulse':
              recommendation = 'Monitor maternal pulse. Check for underlying causes and consider cardiovascular assessment.';
              break;
            case 'Systolic BP':
            case 'Diastolic BP':
              recommendation = 'Monitor blood pressure closely. Consider antihypertensive therapy if severe hypertension.';
              break;
            case 'Temperature C':
              recommendation = 'Monitor for signs of infection. Consider antibiotics if infection suspected.';
              break;
            case 'Contractions per 10 min':
            case 'Duration of contractions':
              recommendation = 'Monitor and document progress. Consider specialist consultation if needed.';
              break;
            default:
              recommendation = 'Monitor closely and document findings. Consider specialist consultation if needed.';
          }
          
          recommendationsHTML += `<li><strong>${alertType}:</strong> ${recommendation}</li>`;
        });
        
        recommendationsHTML += '</ul></div>';
        
        recommendationsDiv.innerHTML = recommendationsHTML;
        console.log('‚úÖ Recommendations HTML set with alerts');
      } else {
        // No alerts found
        recommendationsDiv.innerHTML = '<div class="alert alert-success">‚úÖ No active alerts. All parameters within normal ranges.</div>';
        console.log('‚úÖ Recommendations HTML set with no alerts message');
      }
      
      console.log('=== showRecommendations() completed ===');
    }

    // REMOVED: Old recommendations object that was causing duplicates
    // The new showRecommendations() function handles all recommendations dynamically

    // Load data from Firestore
    async function loadData() {
      try {
        console.log('loadData called');
        
        // Get current user and their Firestore profile
        const user = firebase.auth().currentUser;
        if (!user) {
          document.body.innerHTML = '<div class="alert alert-danger">Not authenticated.</div>';
          return;
        }
          
        // Fetch user profile
        const userDoc = await firebase.firestore().collection("users").doc(user.uid).get();
        if (!userDoc.exists) {
          document.body.innerHTML = '<div class="alert alert-danger">User profile not found.</div>';
          return;
        }
        const userData = userDoc.data();

        // Get patient document
        const patientIdFromUrl = getPatientIdFromUrl();
        console.log('Patient ID from getPatientIdFromUrl():', patientIdFromUrl);
        
        if (!patientIdFromUrl) {
          document.body.innerHTML = '<div class="alert alert-danger">Patient ID not found.</div>';
          return;
        }

        const patientDoc = await firebase.firestore().collection("patients").doc(patientIdFromUrl).get({ source: "server" });
        if (!patientDoc.exists) {
          document.body.innerHTML = '<div class="alert alert-danger">Patient not found.</div>';
          return;
        }
        const d = patientDoc.data();

        // Initialize existing data variable
        let existing = {};

        // Access control: Super Admin always allowed, TMO if township matches, Midwife if createdBy matches
        let allowed = false;
          
        if (userData.role === "Super Admin" || userData.role === "admin") {
          allowed = true;
        } else if (userData.role === "TMO") {
          // TMO can access if township matches (handle cases where township might be undefined)
          const patientTownship = d.township || "";
          const userTownship = userData.township || "";
          if (patientTownship && userTownship && patientTownship === userTownship) {
            allowed = true;
          }
        } else if (userData.role === "Midwife" || userData.role === "midwife") {
          // Midwife can access if they created the patient
          if (d.createdBy === user.uid) {
            allowed = true;
          }
        }

        if (!allowed) {
          // Better error message based on role
          let errorMessage = "";
          if (userData.role === "TMO") {
            errorMessage = `Access Denied: You can only access patients in your township (${userData.township || 'undefined'}). This patient is in township: ${d.township || 'undefined'}.`;
          } else if (userData.role === "Midwife" || userData.role === "midwife") {
            errorMessage = `Access Denied: You can only access patients you created. This patient was created by: ${d.createdBy || 'unknown'}.`;
          } else {
            errorMessage = `Access Denied: You do not have permission to view this patient record. Please contact your administrator.`;
          }
          
          document.body.innerHTML = `
            <div class="alert alert-danger">
              <h4>Access Denied</h4>
              <p><strong>Reason:</strong> ${errorMessage}</p>
              <hr>
              <a href="list.html" class="btn btn-primary">‚Üê Back to Patient List</a>
            </div>
          `;
          return;
        }

        // Populate patient info
        document.getElementById("p_name").value = d.name || "";
        document.getElementById("p_age").value = d.age || "";
        document.getElementById("p_parity").value = d.parity || "";
        document.getElementById("p_onset").value = d.labour_onset || "";
        document.getElementById("p_active").value = d.active_labour || "";
        document.getElementById("p_membrane").value = d.ruptured_membrane || "";
        document.getElementById("p_risk").value = d.risk_factors || "";

        // Load starting time and second stage data
        try {
          const startingTimeDoc = await firebase.firestore().collection("patients").doc(patientIdFromUrl).collection("records").doc("startingTime").get();
          if (startingTimeDoc.exists) {
            const startingData = startingTimeDoc.data();
            const savedStartingTime = startingData.startingTime;
            
            // Only set activeFirstStageStartTime if there's actually a saved value
            if (savedStartingTime && savedStartingTime.trim() !== '') {
              activeFirstStageStartTime = savedStartingTime;
              document.getElementById("startingTime").value = activeFirstStageStartTime;
              
              // Generate dynamic time columns based on starting time
              generateDynamicTimeColumns();
              
              // Load existing records from the new structure
              const recordsDoc = await firebase.firestore()
                .collection("patients")
                .doc(patientIdFromUrl)
                .collection("records")
                .doc("summary")
                .get();
              
              if (recordsDoc.exists) {
                const savedData = recordsDoc.data();
                const savedStartingTimeFromSummary = savedData.startingTime;
                
                // Only load data if the starting time matches (preserves data when starting time hasn't changed)
                if (savedStartingTimeFromSummary === activeFirstStageStartTime) {
                  existing = savedData;
                  console.log('Loading existing data with matching starting time:', savedStartingTimeFromSummary);
                } else {
                  console.log('Starting time changed, not loading old data. Old:', savedStartingTimeFromSummary, 'New:', activeFirstStageStartTime);
                  // Data will be cleared since starting time changed
                }
              }

              // Load medication data
              const medicationSnap = await firebase.firestore().collection("patients").doc(patientIdFromUrl).collection("medication").get({ source: "server" });
              medicationSnap.forEach(doc => {
                const d = doc.data();
                const time = d.time;
                
                // Store oxytocin data
                if (d.oxytocin) {
                  existing[`Medication_Oxytocin_${time}`] = d.oxytocin;
                  if (d.oxytocin === "Yes") {
                    existing[`Medication_Oxytocin_${time}_UL`] = d.oxytocin_UL || "";
                    existing[`Medication_Oxytocin_${time}_drops`] = d.oxytocin_drops || "";
                  }
                }
                
                // Store medicine data
                if (d.medicine) {
                  existing[`Medication_Medicine_${time}`] = d.medicine;
                }
                
                // Store IV fluids data
                if (d.iv_fluids) {
                  existing[`Medication_IV_Fluids_${time}`] = d.iv_fluids;
                }
              });

              // If starting time exists, show all tables with data
              showAllTables();
              document.getElementById("startingTimeRequirement").style.display = "none";
              
              // Generate the summary table with existing data
              generateSummaryTable(existing);
              
              // Load plotting data from previous sessions
              await loadPlotData();
              
              // Setup alert highlighting for real-time alerts
              addAlertHighlighting();
              
              // Add event listeners for form changes
              document.querySelectorAll('select, input').forEach(el => {
                el.addEventListener('change', function() {
                  checkAndHighlightAlert(this);
                  // Recommendations will be shown when needed, not on every change
                });
              });
              
              // Lock time inputs if they already have values
              checkAndLockTimeInputs();
              
              // Log lock status for debugging
              setTimeout(() => {
                logLockStatus();
              }, 500);
              
            } else {
              // No starting time set, hide all tables and show requirement
              hideAllTables();
              showStartingTimeRequirement();
            }
          
          console.log('üîÑ Loading second stage data...');
          
          const secondStageDoc = await firebase.firestore().collection("patients").doc(patientIdFromUrl).collection("records").doc("secondStage").get();
          if (secondStageDoc.exists) {
            const secondStageData = secondStageDoc.data();
            secondStageStartTime = secondStageData.secondStageStartTime;
            isSecondStageActive = secondStageData.isSecondStageActive;
            
            console.log(`  Found second stage data: ${secondStageStartTime}, active: ${isSecondStageActive}`);
            
            if (isSecondStageActive) {
              document.getElementById("secondStageTime").value = secondStageStartTime;
              document.getElementById("secondStageCard").style.display = "block";
              
              // Calculate and display first stage duration
              if (activeFirstStageStartTime && secondStageStartTime) {
                const firstTime = new Date(`2000-01-01T${activeFirstStageStartTime}:00`);
                const secondTime = new Date(`2000-01-01T${secondStageStartTime}:00`);
                const firstStageDuration = Math.round((secondTime - firstTime) / (1000 * 60));
                document.getElementById("firstStageDuration").textContent = `${firstStageDuration} minutes`;
                document.getElementById("secondStageStartDisplay").textContent = secondStageStartTime;
              }
              
              console.log('üîÑ Generating hybrid time columns for existing second stage...');
              
              // Generate hybrid time columns for second stage
              generateHybridTimeColumns();
              
              // Update colors for all tables after generating hybrid columns
              setTimeout(() => {
                updateSecondStageColors();
              }, 100);
            } else {
              console.log('  Second stage not active');
            }
          } else {
            console.log('  No second stage data found');
          }
        } // Close the if (startingTimeDoc.exists) block
        } catch (error) {
          console.error("Error loading time data:", error);
          // On error, hide all tables and show requirement
          hideAllTables();
          showStartingTimeRequirement();
        }

        // Generate dynamic time columns
        generateDynamicTimeColumns();

        // Event listener for starting time changes is already added below in the try-catch block

        // Load existing records from the new structure
        const recordsDoc = await firebase.firestore()
          .collection("patients")
          .doc(patientIdFromUrl)
          .collection("records")
          .doc("summary")
          .get();
        
        if (recordsDoc.exists) {
          const savedData = recordsDoc.data();
          const savedStartingTime = savedData.startingTime;
          
          // Only load data if the starting time matches (preserves data when starting time hasn't changed)
          if (savedStartingTime === activeFirstStageStartTime) {
            existing = savedData;
            console.log('Loading existing data with matching starting time:', savedStartingTime);
          } else {
            console.log('Starting time changed, not loading old data. Old:', savedStartingTime, 'New:', activeFirstStageStartTime);
            // Data will be cleared since starting time changed
          }
        }

        // Load medication data
        const medicationSnap = await firebase.firestore().collection("patients").doc(patientIdFromUrl).collection("medication").get({ source: "server" });
        medicationSnap.forEach(doc => {
          const d = doc.data();
          const time = d.time;
          
          // Store oxytocin data
          if (d.oxytocin) {
            existing[`Medication_Oxytocin_${time}`] = d.oxytocin;
            if (d.oxytocin === "Yes") {
              existing[`Medication_Oxytocin_${time}_UL`] = d.oxytocin_UL || "";
              existing[`Medication_Oxytocin_${time}_drops`] = d.oxytocin_drops || "";
            }
          }
          
          // Store medicine data
          if (d.medicine) {
            existing[`Medication_Medicine_${time}`] = d.medicine;
          }
          
          // Store IV fluids data
          if (d.iv_fluids) {
            existing[`Medication_IV_Fluids_${time}`] = d.iv_fluids;
          }
        });

        console.log('üîÑ About to generate summary table...');
        console.log(`  contractionsTimeCols: ${contractionsTimeCols.length} columns`);
        console.log(`  babyBaselineTimeCols: ${babyBaselineTimeCols.length} columns`);
        
        // Generate the summary table
        generateSummaryTable(existing);
        
        // Load plotting data from previous sessions
        await loadPlotData();
        
        // Load treatment status
        await loadTreatmentStatus();
        
        // Update patient status in main collection if treatment was ended
        if (isTreatmentEnded && treatmentOutcome) {
          await updatePatientStatusInMainCollection(treatmentOutcome);
        }
        
        // Setup alert highlighting for real-time alerts
        addAlertHighlighting();
        
        // Add event listeners for form changes
        document.querySelectorAll('select, input').forEach(el => {
          el.addEventListener('change', function() {
            checkAndHighlightAlert(this);
            // Recommendations will be shown when needed, not on every change
          });
        });

        // Add event listeners for starting time changes
        document.getElementById("startingTime").addEventListener("change", function() {
          const newStartingTime = this.value;
          if (newStartingTime) {
            const oldStartingTime = activeFirstStageStartTime;
            activeFirstStageStartTime = newStartingTime;
            
            // Generate new time columns
            generateDynamicTimeColumns();
            
            // Save the starting time
            saveStartingTime();
            
            // Lock the starting time input after first use
            lockTimeInput("startingTime", "Active First Stage Start Time");
            
            // Hide starting time requirement message
            document.getElementById("startingTimeRequirement").style.display = "none";
            
            // Show all tables immediately
            showAllTables();
            
            // Generate tables with empty data (clear all data since time intervals changed)
            generateSummaryTable({});
            
            // Show warning about data loss
            showDataLossWarning();
          }
        });

        // Add event listener for second stage time input
        document.getElementById("secondStageTime").addEventListener("change", function() {
          const newSecondStageTime = this.value;
          if (newSecondStageTime && activeFirstStageStartTime) {
                    // Validate that second stage is after first stage (handle midnight crossing)
        const firstTime = new Date(`2000-01-01T${activeFirstStageStartTime}:00`);
        const secondTime = new Date(`2000-01-01T${newSecondStageTime}:00`);
        
        // Calculate time difference in minutes, handling midnight crossing
        let timeDiffMinutes = (secondTime - firstTime) / (1000 * 60);
        
        // If second time is earlier in the day, it means it's the next day
        if (timeDiffMinutes < 0) {
          timeDiffMinutes += 24 * 60; // Add 24 hours (1440 minutes)
        }
        
        // Second stage must be at least 30 minutes after first stage
        if (timeDiffMinutes < 30) {
          alert('Second stage must start at least 30 minutes after the active first stage start time.');
          this.value = '';
          return;
        }
            
            // Lock the second stage time input after first use
            lockTimeInput("secondStageTime", "Second Stage Start Time");
            
            // Show the second stage controls
            document.getElementById('secondStageControls').style.display = 'block';
          }
        });

      } catch (error) {
        console.error("Error loading data:", error);
        document.body.innerHTML = `<div class="alert alert-danger">Error loading data: ${error.message}</div>`;
      }
    }

    function generateSummaryTable(existing) {
      
      // Clear existing tables
      document.getElementById("supportiveCareTable").innerHTML = "";
      document.getElementById("fhrTable").innerHTML = "";
      document.getElementById("babyTable").innerHTML = "";
      document.getElementById("womanTable").innerHTML = "";
      document.getElementById("contractionsTable").innerHTML = "";
      // Note: Plotting charts are handled separately
      document.getElementById("medicationTable").innerHTML = "";
      document.getElementById("decisionMakingTable").innerHTML = "";
      document.getElementById("initialsTable").innerHTML = ""; // Clear initials table

      // Generate each section table
      generateSectionTable("Supportive Care", sections["Supportive Care"], "supportiveCareTable", existing);
      generateSectionTable("FHR", sections["FHR"], "fhrTable", existing);
      generateSectionTable("Baby", sections["Baby"], "babyTable", existing);
      generateSectionTable("Woman", sections["Woman"], "womanTable", existing);
      
      // Generate Contractions table with hybrid time columns
      generateSectionTable("Contractions", sections["Contractions"], "contractionsTable", existing);
      
      // Initialize plotting charts (replaces the old table generation)
      initializePlottingCharts();
      
      // Generate Medication table with 1-hour intervals
      generateMedicationTable("medicationTable", existing);
      
      // Generate Shared Decision-Making table with mixed time intervals
      generateSharedDecisionTable("decisionMakingTable", existing);
      
      generateInitialsTable("initialsTable", existing); // Generate initials table
      
      // Add event listeners for form changes
      addFormEventListeners();
      
      // Highlight any existing alert values after tables are generated
      setTimeout(() => {
        const allSelects = document.querySelectorAll('select');
        const allNumberInputs = document.querySelectorAll('input[type="number"]');
        
        allSelects.forEach(select => checkAndHighlightAlert(select));
        allNumberInputs.forEach(input => checkAndHighlightAlert(input));
        
        // Update second stage colors for all tables
        if (secondStageStartTime && isSecondStageActive) {
          updateSecondStageColors();
        }
        
        // Show initial recommendations after tables are generated
        if (document.getElementById('recommendations')) {
          // Clear previous recommendations tracking when tables are regenerated
          shownRecommendations.clear();
          showRecommendations();
        }
      }, 100);
    }

    // Generate a section table with dynamic time columns
    function generateSectionTable(sectionName, fields, tableId, existing) {
      console.log(`üèóÔ∏è generateSectionTable() called for: ${sectionName}`);
      
      const table = document.getElementById(tableId);
      if (!table) {
        console.error('Table not found:', tableId);
        return;
      }
      
      // Get the appropriate time columns for this section
      let timeColumns = [];
      switch (sectionName) {
        case "Supportive Care":
          timeColumns = supportiveCareTimeCols;
          break;
        case "FHR":
          timeColumns = babyBaselineTimeCols; // Hybrid intervals for FHR
          console.log(`üîç FHR table using ${timeColumns.length} time columns:`, timeColumns);
          break;
        case "Baby":
          timeColumns = babyOtherTimeCols; // 1-hour intervals for other baby parameters
          break;
        case "Contractions":
          timeColumns = contractionsTimeCols; // Hybrid intervals for contractions
          console.log(`üîç Contractions table using ${timeColumns.length} time columns:`, timeColumns);
          break;
        case "Woman":
          timeColumns = womanTimeCols;
          break;
        default:
          timeColumns = supportiveCareTimeCols; // fallback
      }
      
      console.log(`  ${sectionName} table will use ${timeColumns.length} time columns`);
      
      // Create table header
      let tableHTML = '<thead><tr>';
      tableHTML += '<th class="sticky-field">Field</th>';
      tableHTML += '<th class="sticky-alert">Alert</th>';
      
      // Add time column headers with second stage highlighting
      timeColumns.forEach(time => {
        const isSecondStage = isSecondStageTime(time);
        const headerClass = isSecondStage ? 'time-header second-stage' : 'time-header';
        tableHTML += `<th class="${headerClass}">${time}</th>`;
      });
      
      tableHTML += '</tr></thead><tbody>';
      
      // Create table rows
      fields.forEach(field => {
        const fieldName = field.replace(/\s+/g, '_');
        tableHTML += '<tr>';
        tableHTML += `<td class="sticky-field">${field}</td>`;
        
        // Add alert value cell
        const alertValue = whoAlertValues[field] || '';
        tableHTML += `<td class="sticky-alert"><span class="alert-value">${alertValue}</span></td>`;
        
        // Add time input cells
        timeColumns.forEach(time => {
          const timeKey = time.replace(':', '_');
          const inputName = `${fieldName}_${timeKey}`;
          const existingValue = existing && existing[inputName] ? existing[inputName] : '';
          
          // Determine input type based on field
          let inputHTML = '';
          if (field === 'Baseline FHR') {
            // Baseline FHR should be a number input
            inputHTML = `<input type="number" name="${inputName}" value="${existingValue}" class="time-cell" placeholder="Enter value" min="60" max="200">`;
          } else if (field.includes('Contractions per 10 min')) {
            // Contractions per 10 min should be a number input
            inputHTML = `<input type="number" name="${inputName}" value="${existingValue}" class="time-cell" placeholder="Enter value" min="0" max="10">`;
          } else if (field.includes('Duration of contractions')) {
            // Duration of contractions should be a number input
            inputHTML = `<input type="number" name="${inputName}" value="${existingValue}" class="time-cell" placeholder="Enter value" min="0" max="120">`;
          } else if (field.includes('Pulse') || field.includes('BP') || field.includes('Temperature')) {
            inputHTML = `<input type="number" name="${inputName}" value="${existingValue}" class="time-cell" placeholder="Enter value">`;
          } else if (field.includes('Urine')) {
            inputHTML = `<select name="${inputName}" class="time-cell">
              <option value="">Select</option>
              <option value="P++" ${existingValue === 'P++' ? 'selected' : ''}>P++</option>
              <option value="A++" ${existingValue === 'A++' ? 'selected' : ''}>A++</option>
              <option value="P+" ${existingValue === 'P+' ? 'selected' : ''}>P+</option>
              <option value="A+" ${existingValue === 'A+' ? 'selected' : ''}>A+</option>
              <option value="P-" ${existingValue === 'P-' ? 'selected' : ''}>P-</option>
              <option value="A-" ${existingValue === 'A-' ? 'selected' : ''}>A-</option>
              <option value="P Trace" ${existingValue === 'P Trace' ? 'selected' : ''}>P Trace</option>
              <option value="A Trace" ${existingValue === 'A Trace' ? 'selected' : ''}>A Trace</option>
              <option value="-/-" ${existingValue === '-/-' ? 'selected' : ''}>-/-</option>
            </select>`;
          } else {
            // Use the correct dropdown options for each field from dropdownOptions
            const fieldOptions = dropdownOptions[field] || ["Y", "N"]; // fallback to Y/N if not defined
            
            inputHTML = `<select name="${inputName}" class="time-cell">
              <option value=""></option>`;
            
            fieldOptions.forEach(option => {
              inputHTML += `<option value="${option}" ${existingValue === option ? 'selected' : ''}>${option}</option>`;
            });
            
            inputHTML += `</select>`;
          }
          
          tableHTML += `<td class="time-cell">${inputHTML}</td>`;
        });
        
        tableHTML += '</tr>';
      });
      
      tableHTML += '</tbody>';
      table.innerHTML = tableHTML;
    }

    // Generate Contractions table (keep as is)
    function generateContractionsTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Create table header
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      
      // Field header
      const fieldHeader = document.createElement("th");
      fieldHeader.className = "field-header sticky-field";
      fieldHeader.textContent = "Field";
      headerRow.appendChild(fieldHeader);
      
      // Alert header
      const alertHeader = document.createElement("th");
      alertHeader.className = "alert-header sticky-alert";
      alertHeader.textContent = "Alert";
      headerRow.appendChild(alertHeader);
      
      // Time headers (30-minute intervals with second stage highlighting)
      contractionsTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        headerRow.appendChild(timeHeader);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement("tbody");
      
      // Contractions per 10 min row
      const contractionsRow = document.createElement("tr");
      
      // Field cell
      const contractionsFieldCell = document.createElement("td");
      contractionsFieldCell.className = "field-cell sticky-field";
      contractionsFieldCell.textContent = "Contractions per 10 min";
      contractionsRow.appendChild(contractionsFieldCell);
      
      // Alert cell
      const contractionsAlertCell = document.createElement("td");
      contractionsAlertCell.className = "alert-cell sticky-alert";
      contractionsAlertCell.innerHTML = '<span class="alert-indicator">>5</span>';
      contractionsRow.appendChild(contractionsAlertCell);
      
      // Time cells for contractions per 10 min
      contractionsTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Contractions_per_10_min_${timeKey}`;
        const value = existing[key] || "";
        
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        ["<2", "2-5", ">5"].forEach(option => {
          const optionElement = document.createElement("option");
          optionElement.value = option;
          optionElement.textContent = option;
          select.appendChild(optionElement);
        });
        
        select.value = value;
        timeCell.appendChild(select);
        contractionsRow.appendChild(timeCell);
      });
      
      tbody.appendChild(contractionsRow);
      
      // Duration of contractions row
      const durationRow = document.createElement("tr");
      
      // Field cell
      const durationFieldCell = document.createElement("td");
      durationFieldCell.className = "field-cell sticky-field";
      durationFieldCell.textContent = "Duration of contractions";
      durationRow.appendChild(durationFieldCell);
      
      // Alert cell
      const durationAlertCell = document.createElement("td");
      durationAlertCell.className = "alert-cell sticky-alert";
              durationAlertCell.innerHTML = '<span class="alert-indicator">>50s</span>';
      durationRow.appendChild(durationAlertCell);
      
      // Time cells for duration of contractions
      contractionsTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Duration_of_contractions_${timeKey}`;
        const value = existing[key] || "";
        
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        ["<20s", "20-50s", ">50s"].forEach(option => {
          const optionElement = document.createElement("option");
          optionElement.value = option;
          optionElement.textContent = option;
          select.appendChild(optionElement);
        });
        
        select.value = value;
        timeCell.appendChild(select);
        durationRow.appendChild(timeCell);
      });
      
      tbody.appendChild(durationRow);
      table.appendChild(tbody);
    }



    function getLatestValue(field) {
  // Go through timeCols in reverse to find the latest non-empty value
  for (let i = timeCols.length - 1; i >= 0; i--) {
    const key = `${timeCols[i]}_${field.replace(/\s+/g, "_")}`;
    const el = document.getElementsByName(key)[0];
    if (el && el.value) return el.value;
  }
  return "";
}

    // REMOVED: Duplicate showRecommendations function that was overriding the correct one
      


      // REMOVED: Old recommendations logic that was causing duplicates
      // The new showRecommendations() function handles all recommendations dynamically
      


    // REMOVED DUPLICATE showRecommendations function that was looking for non-existent "recommendationsBox" element

    async function saveData() {
      try {
        const patientIdToSave = getPatientIdFromUrl();
        if (!patientIdToSave) {
          console.error('No patient ID found in URL');
          return;
        }

        const base = firebase.firestore().collection("patients").doc(patientIdToSave);

        // Fetch existing patient data to preserve createdBy
        const patientDoc = await base.get();
        let createdBy = "";
        if (patientDoc.exists && patientDoc.data().createdBy) {
          createdBy = patientDoc.data().createdBy;
        }

        // Save patient info - use update() to preserve existing fields like township
        await base.update({
          name: document.getElementById("p_name").value,
          age: document.getElementById("p_age").value,
          parity: document.getElementById("p_parity").value,
          labour_onset: document.getElementById("p_onset").value,
          active_labour: document.getElementById("p_active").value,
          ruptured_membrane: document.getElementById("p_membrane").value,
          risk_factors: document.getElementById("p_risk").value,
          createdBy
        });

        // Save starting time if it exists
        if (activeFirstStageStartTime) {
          await saveStartingTime();
        }

        // Save all form data using time-based structure
        const formData = {};
        
        // Save data for each time column in each section
        // Supportive Care
        supportiveCareTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          sections["Supportive Care"].forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Baby - use the correct variable names (handle hybrid time columns)
        babyBaselineTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          // Only Baseline FHR and FHR deceleration use hybrid intervals
          const baselineFields = ["Baseline FHR", "FHR deceleration"];
          baselineFields.forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        babyOtherTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          // Other baby fields use 1-hour intervals
          const otherFields = ["Amniotic fluid", "Fetal position", "Caput", "Moulding"];
          otherFields.forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Woman
        womanTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          sections["Woman"].forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Contractions (handle hybrid time columns)
        contractionsTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          sections["Contractions"].forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Medication - Fix the data collection
        medicationTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          
          // Oxytocin
          const oxytocinKey = `Medication_Oxytocin_${timeKey}`;
          const oxytocinInput = document.querySelector(`input[name="${oxytocinKey}"], select[name="${oxytocinKey}"]`);
          if (oxytocinInput && oxytocinInput.value) {
            formData[oxytocinKey] = oxytocinInput.value;
            
            // If oxytocin is "Y", save the additional details
            if (oxytocinInput.value === "Y") {
              const uLKey = `${oxytocinKey}_UL`;
              const dropsKey = `${oxytocinKey}_drops`;
              const uLInput = document.querySelector(`input[name="${uLKey}"]`);
              const dropsInput = document.querySelector(`input[name="${dropsKey}"]`);
              
              if (uLInput && uLInput.value) {
                formData[uLKey] = uLInput.value;
              }
              if (dropsInput && dropsInput.value) {
                formData[dropsKey] = dropsInput.value;
              }
            }
          }
          
          // Medicine
          const medicineKey = `Medication_Medicine_${timeKey}`;
          const medicineInput = document.querySelector(`input[name="${medicineKey}"], select[name="${medicineKey}"]`);
          if (medicineInput && medicineInput.value) {
            formData[medicineKey] = medicineInput.value;
            
            // If medicine is "Y", save the text input
            if (medicineInput.value === "Y") {
              const textKey = `${medicineKey}_text`;
              const textInput = document.querySelector(`input[name="${textKey}"]`);
              if (textInput && textInput.value) {
                formData[textKey] = textInput.value;
              }
            }
          }
          
          // IV Fluids
          const ivFluidsKey = `Medication_IV_Fluids_${timeKey}`;
          const ivFluidsInput = document.querySelector(`input[name="${ivFluidsKey}"], select[name="${ivFluidsKey}"]`);
          if (ivFluidsInput && ivFluidsInput.value) {
            formData[ivFluidsKey] = ivFluidsInput.value;
          }
        });
        
        // Shared Decision Making - Assessment
        const assessmentFields = ["Woman's condition", "Baby's condition", "Labour progress", "Other concerns"];
        assessmentTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          assessmentFields.forEach(field => {
            const fieldKey = field.replace(/\s+/g, '_').replace("'", "");
            const inputName = `ASSESSMENT_${fieldKey}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        planTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          const inputName = `PLAN_${timeKey}`;
          const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
          if (input && input.value) {
            formData[inputName] = input.value;
          }
        });
        
        // Initials
        initialsTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          const inputName = `INITIALS_${timeKey}`;
          const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
          if (input && input.value) {
            formData[inputName] = input.value;
          }
        });

        // Save the summary data
        await base.collection("records").doc("summary").set({
          ...formData,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          lastUpdated: new Date().toISOString(),
          startingTime: activeFirstStageStartTime // Save the starting time with the data
        });
        
        console.log('Saved form data:', formData);
        console.log('Total fields saved:', Object.keys(formData).length);

        showSaveSuccess();
      } catch (error) {
        console.error('Save error:', error);
        showSaveError(`Failed to save data: ${error.message}`);
      }
    }

    // Show save success message
    function showSaveSuccess() {
      const successMessage = document.getElementById('successMessage');
      if (successMessage) {
        successMessage.style.display = 'flex';
        successMessage.style.zIndex = '9999';
        console.log('Success message displayed');
        
        setTimeout(() => {
          successMessage.style.display = 'none';
        }, 3000);
      } else {
        console.error('Success message element not found');
      }
    }

    // Show save error message
    function showSaveError(errorMessage) {
      const successMessage = document.getElementById('successMessage');
      if (successMessage) {
        successMessage.innerHTML = '<i class="fas fa-exclamation-triangle"></i><span>Save Error: ' + errorMessage + '</span>';
        successMessage.className = 'success-message error-message';
        successMessage.style.display = 'flex';
        successMessage.style.zIndex = '9999';
        
        setTimeout(() => {
          successMessage.style.display = 'none';
          successMessage.innerHTML = '<i class="fas fa-check-circle"></i><span>Saved Successfully</span>';
          successMessage.className = 'success-message';
        }, 5000);
        
        console.error("Save error:", errorMessage);
      } else {
        console.error('Success message element not found');
      }
    }

    // Generate time columns starting from 00:30
    function generateTimeColumns() {
      const timeCols = [];
      for (let hour = 0; hour <= 15; hour++) {
        for (let minute = 0; minute < 60; minute += 30) {
          if (hour === 0 && minute === 0) continue; // Skip 00:00
          const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
          timeCols.push(timeStr);
        }
      }
      return timeCols;
    }

    // Initialize time columns
    const timeCols = generateTimeColumns();

    // Load data when page loads
    firebase.auth().onAuthStateChanged(function(user) {
      if (!user) {
        window.location.href = "login.html";
      } else {
        console.log('User authenticated, patientId from URL:', getPatientIdFromUrl());
        
        // Only load data after user is authenticated
        loadData();
        
        // Set the View Summary button href with the correct patient ID
        const viewSummaryBtn = document.getElementById('viewSummaryBtn');
        const currentPatientId = getPatientIdFromUrl();
        if (viewSummaryBtn && currentPatientId) {
          viewSummaryBtn.href = `summary-view.html?patient=${currentPatientId}`;
          console.log('View Summary button href set to:', viewSummaryBtn.href);
        } else {
          console.log('View Summary button not found or patientId missing:', { viewSummaryBtn, currentPatientId });
        }
        
        // Test recommendations after a delay to ensure everything is loaded
        // Recommendations will be shown when needed, not automatically
      }
    });

    // Populate time columns in the header
    function populateTimeColumns() {
      const timeColumnsContainer = document.getElementById('timeColumns');
      if (timeColumnsContainer) {
        timeColumnsContainer.innerHTML = timeCols.map(t => 
          `<div class="time-column">${t}</div>`
        ).join('');
      }
    }

    // Call this after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Set the View Summary button href immediately
      const viewSummaryBtn = document.getElementById('viewSummaryBtn');
      const currentPatientId = getPatientIdFromUrl();
      if (viewSummaryBtn && currentPatientId) {
        viewSummaryBtn.href = `summary-view.html?patient=${currentPatientId}`;
        console.log('View Summary button href set on DOM load:', viewSummaryBtn.href);
      }
      
      populateTimeColumns();
      initializeFoldedSections(); // Initialize all sections as folded
      addAlertHighlighting(); // Add alert highlighting functionality
      initializePlottingCharts(); // Initialize plotting charts
      
      // Test if sticky positioning is supported
      testStickySupport();
      
      // Check and lock time inputs if they already have values
      // This will run after the page loads and data is loaded
      setTimeout(() => {
        checkAndLockTimeInputs();
        logLockStatus();
        startLockMonitoring(); // Start periodic lock monitoring
      }, 1000);
    });
    
    // Test if sticky positioning is supported
    function testStickySupport() {
      const testElement = document.createElement('div');
      testElement.style.position = 'sticky';
      testElement.style.top = '0';
      
      if (testElement.style.position === 'sticky') {
        console.log('‚úÖ Sticky positioning is supported');
      } else {
        console.log('‚ùå Sticky positioning is NOT supported - using fallback');
        // Add fallback CSS class
        document.body.classList.add('no-sticky-support');
      }
    }

    // Toggle patient information section
    function togglePatientInfo() {
      const patientForm = document.getElementById('patientForm');
      const toggleIcon = document.getElementById('toggleIcon');
      
      if (patientForm.style.display === 'none') {
        patientForm.style.display = 'block';
        toggleIcon.className = 'fas fa-chevron-down';
      } else {
        patientForm.style.display = 'none';
        toggleIcon.className = 'fas fa-chevron-right';
      }
    }

    // Toggle section visibility
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (!section) {
        console.log('Section not found:', sectionId);
        return;
      }
      
      const tableWrappers = section.querySelectorAll('.table-wrapper');
      const toggleIcon = section.querySelector('.toggle-icon i');
      
      if (!tableWrappers || tableWrappers.length === 0 || !toggleIcon) {
        console.log('Table wrappers or toggle icon not found in section:', sectionId);
        return;
      }
      
      // Check if any table wrapper is visible
      const isVisible = Array.from(tableWrappers).some(wrapper => 
        wrapper.style.display !== 'none' && wrapper.style.display !== ''
      );
      
      // Toggle all table wrappers
      tableWrappers.forEach(wrapper => {
        if (isVisible) {
          wrapper.style.display = 'none';
        } else {
          wrapper.style.display = 'block';
        }
      });
      
      // Update toggle icon
      if (isVisible) {
        toggleIcon.className = 'fas fa-chevron-right';
      } else {
        toggleIcon.className = 'fas fa-chevron-down';
      }
    }

    // Initialize all sections as folded
    function initializeFoldedSections() {
      // Start with Patient Information folded
      document.getElementById('patientForm').style.display = 'none';
      document.getElementById('toggleIcon').className = 'fas fa-chevron-right';
      
      // Start with all section tables folded
      const sections = ['supportiveCareSection', 'fhrSection', 'babySection', 'womanSection', 'contractionsSection', 'labourProgressSection', 'medicationSection', 'decisionMakingSection', 'initialsSection'];
      sections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) {
          const tableWrappers = section.querySelectorAll('.table-wrapper');
          const toggleIcon = section.querySelector('.toggle-icon i');
          
          if (tableWrappers && tableWrappers.length > 0 && toggleIcon) {
            tableWrappers.forEach(wrapper => {
              wrapper.style.display = 'none';
            });
            toggleIcon.className = 'fas fa-chevron-right';
          }
        }
      });
    }

    // Generate Initials table with dynamic time columns
    function generateInitialsTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Create table header
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      
      // Field header
      const fieldHeader = document.createElement("th");
      fieldHeader.className = "field-header sticky-field";
      fieldHeader.textContent = "Field";
      headerRow.appendChild(fieldHeader);
      
      // Time headers (1-hour intervals with second stage highlighting)
      initialsTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        headerRow.appendChild(timeHeader);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement("tbody");
      
      // Single row for initials
      const initialsRow = document.createElement("tr");
      
      // Field cell
      const initialsFieldCell = document.createElement("td");
      initialsFieldCell.className = "field-cell sticky-field";
      initialsFieldCell.textContent = "Initials";
      initialsRow.appendChild(initialsFieldCell);
      
      // Time cells for initials
      initialsTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `INITIALS_${timeKey}`;
        const value = existing[key] || "";
        
        const input = document.createElement("input");
        input.name = key;
        input.type = "text";
        input.className = "form-control form-control-sm";
        input.placeholder = "3 chars max";
        input.maxLength = 3;
        input.value = value;
        timeCell.appendChild(input);
        initialsRow.appendChild(timeCell);
      });
      
      tbody.appendChild(initialsRow);
      table.appendChild(tbody);
    }

    // Global variables for plotting
    let cervixChart = null;
    let descentChart = null;
    let cervixData = [];
    let descentData = [];
    let unsavedCervixPoints = [];
    let unsavedDescentPoints = [];

    // Initialize plotting charts
    function initializePlottingCharts() {
      // Initialize Cervix Chart
      const cervixCanvas = document.getElementById('cervixChart');
      if (cervixCanvas) {
        cervixChart = cervixCanvas.getContext('2d');
        setupChart(cervixCanvas, 'cervix');
      }
      
      // Initialize Descent Chart
      const descentCanvas = document.getElementById('descentChart');
      if (descentCanvas) {
        descentChart = descentCanvas.getContext('2d');
        setupChart(descentCanvas, 'descent');
      }
      
      // Update initial status
      updateChartStatus();
    }

    // Setup chart with grid and labels
    function setupChart(canvas, type) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw grid
      drawGrid(ctx, width, height, type);
      
      // Draw labels
      drawLabels(ctx, width, height, type);
      
      // Redraw all saved points
      redrawSavedPoints(canvas, type);
      
      // Redraw all unsaved points
      redrawUnsavedPoints(canvas, type);
      
      // Add click/touch event listeners
      addChartEventListeners(canvas, type);
    }

    // Draw grid lines
    function drawGrid(ctx, width, height, type) {
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      
      // Vertical lines (time intervals) - use dynamic time columns
      let timeColumns;
      if (type === 'cervix') {
        timeColumns = cervixPlotTimeCols;
      } else {
        timeColumns = descentPlotTimeCols;
      }
      
      const timeIntervals = timeColumns.length - 1;
      for (let i = 0; i <= timeIntervals; i++) {
        const x = (width * 0.1) + (i * (width * 0.8) / timeIntervals);
        ctx.beginPath();
        ctx.moveTo(x, height * 0.1);
        ctx.lineTo(x, height * 0.9);
        ctx.stroke();
      }
      
      // Horizontal lines (cervix/descent values)
      const valueIntervals = type === 'cervix' ? 6 : 6; // 6 levels
      for (let i = 0; i <= valueIntervals; i++) {
        const y = height * 0.1 + (i * (height * 0.8) / valueIntervals);
        ctx.beginPath();
        ctx.moveTo(width * 0.1, y);
        ctx.lineTo(width * 0.9, y);
        ctx.stroke();
      }
    }

    // Draw chart labels
    function drawLabels(ctx, width, height, type) {
      ctx.fillStyle = '#374151';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      
      // Time labels (x-axis) - use dynamic time columns
      let timeColumns;
      if (type === 'cervix') {
        timeColumns = cervixPlotTimeCols;
      } else {
        timeColumns = descentPlotTimeCols;
      }
      
      // Draw time labels for each time column
      timeColumns.forEach((time, index) => {
        const x = (width * 0.1) + (index * (width * 0.8) / (timeColumns.length - 1));
        const timeLabel = time; // Use actual time like "08:00", "09:00", etc.
        ctx.fillText(timeLabel, x, height * 0.95);
      });
      
      // Value labels (y-axis)
      if (type === 'cervix') {
        const cervixValues = ['10cm', '9cm', '8cm', '7cm', '6cm', '5cm'];
        for (let i = 0; i < cervixValues.length; i++) {
          const y = height * 0.1 + (i * (height * 0.8) / (cervixValues.length - 1));
          ctx.fillText(cervixValues[i], width * 0.05, y + 4);
        }
      } else {
        const descentValues = ['5', '4', '3', '2', '1', '0'];
        for (let i = 0; i < descentValues.length; i++) {
          const y = height * 0.1 + (i * (height * 0.8) / (descentValues.length - 1));
          ctx.fillText(descentValues[i], width * 0.05, y + 4);
        }
      }
      
      // Chart title
      ctx.font = 'bold 16px Arial';
      ctx.fillText(type === 'cervix' ? 'Cervical Dilation Progress' : 'Fetal Descent Progress', width / 2, height * 0.05);
    }

    // Add event listeners for chart interaction
    function addChartEventListeners(canvas, type) {
      // Mouse events
      canvas.addEventListener('click', (e) => handleChartClick(e, canvas, type));
      
      // Touch events for mobile
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        // Create a synthetic event
        const syntheticEvent = {
          offsetX: x,
          offsetY: y
        };
        handleChartClick(syntheticEvent, canvas, type);
      });
    }

    // Handle chart clicks/touches
    function handleChartClick(e, canvas, type) {
      const rect = canvas.getBoundingClientRect();
      const x = e.offsetX;
      const y = e.offsetY;
      
      // Convert pixel coordinates to chart values
      const timeValue = Math.round(((x - rect.width * 0.1) / (rect.width * 0.8)) * 15);
      const valueIndex = Math.round(((y - rect.height * 0.1) / (rect.height * 0.8)) * 5);
      
      if (timeValue >= 0 && timeValue <= 15 && valueIndex >= 0 && valueIndex <= 5) {
        addPlotPoint(canvas, type, timeValue, valueIndex);
      }
    }

    // Add a plot point to the chart (as unsaved)
    function addPlotPoint(canvas, type, time, value) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Calculate pixel coordinates
      const x = (width * 0.1) + (time * (width * 0.8) / 15);
      const y = height * 0.1 + (value * (height * 0.8) / 5);
      
      // Create the data point
      const dataPoint = { time, value, x, y, saved: false };
      
      // Add to unsaved points
      if (type === 'cervix') {
        unsavedCervixPoints.push(dataPoint);
      } else {
        unsavedDescentPoints.push(dataPoint);
      }
      
      // Draw the plot point with unsaved style
      ctx.fillStyle = type === 'cervix' ? '#60a5fa' : '#34d399'; // Lighter color for unsaved
      ctx.font = 'bold 18px Arial'; // Smaller font for unsaved points
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (type === 'cervix') {
        ctx.fillText('X', x, y);
      } else {
        ctx.fillText('O', x, y);
      }
      
      // Update status indicators
      updateChartStatus();
      
      // Check for alerts based on WHO LCG guidelines
      checkPlottingAlerts(type, time, value);
    }

    // Check for plotting alerts based on WHO LCG guidelines
    function checkPlottingAlerts(type, time, value) {
      if (type === 'cervix') {
        // WHO LCG Cervix Alert Guidelines
        const cervixValues = [10, 9, 8, 7, 6, 5];
        const alertThresholds = ['', '‚â• 2h', '‚â• 2.5h', '‚â• 3h', '‚â• 5h', '‚â• 6h'];
        
        if (alertThresholds[value] && time > 0) {
          console.log(`‚ö†Ô∏è Cervix Alert: ${cervixValues[value]}cm at ${time}h - ${alertThresholds[value]}`);
          // You can add visual alerts here
        }
      } else {
        // WHO LCG Descent Alert Guidelines
        if (time >= 12 && value > 0) {
          console.log(`‚ö†Ô∏è Descent Alert: Second stage - pushing should begin`);
          // You can add visual alerts here
        }
      }
    }

    // Clear only unsaved points (keep saved data)
    function clearCervixChart() {
      if (cervixChart) {
        unsavedCervixPoints = [];
        setupChart(document.getElementById('cervixChart'), 'cervix');
        updateChartStatus();
        console.log('üßπ Cleared unsaved cervix points');
      }
    }

    function clearDescentChart() {
      if (descentChart) {
        unsavedDescentPoints = [];
        setupChart(document.getElementById('descentChart'), 'descent');
        updateChartStatus();
        console.log('üßπ Cleared unsaved descent points');
      }
    }

    // Clear ALL data (both saved and unsaved)
    async function clearAllCervixData() {
      if (confirm('‚ö†Ô∏è This will permanently delete ALL cervix plot data. Are you sure?')) {
        try {
          // Clear from Firestore
          const patientId = getPatientIdFromUrl();
          if (!patientId) return;
          
          const base = firebase.firestore().collection("patients").doc(patientId);
          await base.collection("plotData").doc("cervix").delete();
          
          // Clear local data
          cervixData = [];
          unsavedCervixPoints = [];
          
          // Redraw chart
          setupChart(document.getElementById('cervixChart'), 'cervix');
          updateChartStatus();
          
          console.log('üóëÔ∏è Cleared all cervix data');
        } catch (error) {
          console.error('‚ùå Error clearing cervix data:', error);
        }
      }
    }

    async function clearAllDescentData() {
      if (confirm('‚ö†Ô∏è This will permanently delete ALL descent plot data. Are you sure?')) {
        try {
          // Clear from Firestore
          const patientId = getPatientIdFromUrl();
          if (!patientId) return;
          
          const base = firebase.firestore().collection("patients").doc(patientId);
          await base.collection("plotData").doc("descent").delete();
          
          // Clear local data
          descentData = [];
          unsavedDescentPoints = [];
          
          // Redraw chart
          setupChart(document.getElementById('descentChart'), 'descent');
          updateChartStatus();
          
          console.log('üóëÔ∏è Cleared all descent data');
        } catch (error) {
          console.error('‚ùå Error clearing descent data:', error);
        }
      }
    }

    // Redraw saved points
    function redrawSavedPoints(canvas, type) {
      const data = type === 'cervix' ? cervixData : descentData;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = type === 'cervix' ? '#3b82f6' : '#10b981';
      ctx.font = 'bold 24px Arial'; // Larger font for saved points
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      data.forEach(point => {
        if (type === 'cervix') {
          ctx.fillText('X', point.x, point.y);
        } else {
          ctx.fillText('O', point.x, point.y);
        }
      });
    }

    // Redraw unsaved points
    function redrawUnsavedPoints(canvas, type) {
      const data = type === 'cervix' ? unsavedCervixPoints : unsavedDescentPoints;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = type === 'cervix' ? '#60a5fa' : '#34d399'; // Lighter color for unsaved
      ctx.font = 'bold 18px Arial'; // Smaller font for unsaved points
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      data.forEach(point => {
        if (type === 'cervix') {
          ctx.fillText('X', point.x, point.y);
        } else {
          ctx.fillText('O', point.x, point.y);
        }
      });
    }

    // Save plotting data to Firestore
    async function savePlotData() {
      try {
        // Check if user is authenticated
        if (!firebase.auth().currentUser) {
          throw new Error('User not authenticated');
        }

        const patientId = getPatientIdFromUrl();
        if (!patientId) {
          throw new Error('No patient ID found');
        }

        const base = firebase.firestore().collection("patients").doc(patientId);
        
        // Combine saved and unsaved data
        const allCervixData = [...cervixData, ...unsavedCervixPoints];
        const allDescentData = [...descentData, ...unsavedDescentPoints];
        
        // Save cervix plot data
        if (allCervixData.length > 0) {
          await base.collection("plotData").doc("cervix").set({
            data: allCervixData,
            timestamp: new Date().toISOString(),
            savedBy: firebase.auth().currentUser.uid
          });
          cervixData = allCervixData;
          unsavedCervixPoints = [];
        }
        
        // Save descent plot data
        if (allDescentData.length > 0) {
          await base.collection("plotData").doc("descent").set({
            data: allDescentData,
            timestamp: new Date().toISOString(),
            savedBy: firebase.auth().currentUser.uid
          });
          descentData = allDescentData;
          unsavedDescentPoints = [];
        }
        
        // Show success message
        showSaveSuccess();
        console.log('‚úÖ Plot data saved successfully');
        
        // Redraw charts to show saved state
        if (cervixChart) {
          setupChart(document.getElementById('cervixChart'), 'cervix');
        }
        if (descentChart) {
          setupChart(document.getElementById('descentChart'), 'descent');
        }
        
        // Update status indicators
        updateChartStatus();
        
      } catch (error) {
        console.error('‚ùå Error saving plot data:', error);
        showSaveError(`Failed to save plot data: ${error.message}`);
      }
    }

    // Load treatment status from Firestore
    async function loadTreatmentStatus() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        const endTreatmentDoc = await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('records')
          .doc('endTreatment')
          .get();
        
        if (endTreatmentDoc.exists) {
          const data = endTreatmentDoc.data();
          isTreatmentEnded = true;
          treatmentOutcome = data.outcome;
          
          // Update button state
          updateEndTreatmentButton();
          
          console.log('Treatment status loaded:', treatmentOutcome);
        }
      } catch (error) {
        console.error('Error loading treatment status:', error);
      }
    }

    // Load plotting data from Firestore
    async function loadPlotData() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        const base = firebase.firestore().collection("patients").doc(patientId);
        
        // Load cervix data
        const cervixDoc = await base.collection("plotData").doc("cervix").get();
        if (cervixDoc.exists) {
          cervixData = cervixDoc.data().data || [];
          console.log('üìä Loaded cervix data:', cervixData.length, 'points');
        }
        
        // Load descent data
        const descentDoc = await base.collection("plotData").doc("descent").get();
        if (descentDoc.exists) {
          descentData = descentDoc.data().data || [];
          console.log('üìä Loaded descent data:', descentData.length, 'points');
        }
        
        console.log('‚úÖ Plot data loaded successfully');
        
        // Update status indicators
        updateChartStatus();
        
        // Redraw charts with loaded data after a short delay to ensure charts are ready
        setTimeout(() => {
          if (cervixChart && cervixData.length > 0) {
            redrawChart('cervix');
          }
          if (descentChart && descentData.length > 0) {
            redrawChart('descent');
          }
        }, 500);
        
      } catch (error) {
        console.error('‚ùå Error loading plot data:', error);
        // Don't show error to user for loading, just log it
      }
    }

    // Alert highlighting function - RESTORED!
    function checkAndHighlightAlert(element) {
      if (!element) return;
      
      const fieldName = element.name;
      const value = element.value;
      
      // Remove any existing alert highlighting
      element.classList.remove('alert-value');
      
      // Check for alert conditions based on field and value
      if (fieldName.includes('Companion') && value === 'N') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Mobility') && value === 'SP') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Baseline_FHR')) {
        const fhr = parseFloat(value);
        if (fhr < 110 || fhr > 160) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Pulse')) {
        const pulse = parseFloat(value);
        if (pulse < 50 || pulse > 100) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Systolic_BP')) {
        const bp = parseFloat(value);
        if (bp < 90 || bp > 140) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Diastolic_BP')) {
        const bp = parseFloat(value);
        if (bp < 60 || bp > 90) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Temperature_C')) {
        const temp = parseFloat(value);
        if (temp < 36.0 || temp > 37.5) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('FHR_deceleration') && value === 'L') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Amniotic_fluid') && (value === 'M' || value === 'M+' || value === 'M++' || value === 'M+++')) {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Fetal_position') && value === 'T') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Caput') && (value === '+' || value === '++' || value === '+++')) {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Moulding') && (value === '++' || value === '+++')) {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Pain_Relief') && value === 'N') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Oral_fluids') && value === 'N') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Contractions_per_10_min')) {
        const contractions = parseFloat(value);
        if (contractions < 2 || contractions > 5) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Duration_of_contractions')) {
        const duration = parseFloat(value);
        if (duration < 20 || duration > 60) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Urine')) {
        if (value.includes('P') || value.includes('A')) {
          element.classList.add('alert-value');
        }
      }
    }

    // Add alert highlighting to all form elements
    function addAlertHighlighting() {
      // Add event listeners for real-time alert checking
      document.addEventListener('change', function(e) {
        if (e.target.matches('select, input')) {
          checkAndHighlightAlert(e.target);
        }
      });
      
      document.addEventListener('input', function(e) {
        if (e.target.matches('input[type="number"]')) {
          checkAndHighlightAlert(e.target);
        }
      });
    }

    // Update chart status indicators
    function updateChartStatus() {
      // Update cervix chart status
      const cervixSavedElement = document.getElementById('cervixSavedCount');
      const cervixUnsavedElement = document.getElementById('cervixUnsavedCount');
      if (cervixSavedElement) cervixSavedElement.textContent = cervixData.length;
      if (cervixUnsavedElement) cervixUnsavedElement.textContent = unsavedCervixPoints.length;
      
      // Update descent chart status
      const descentSavedElement = document.getElementById('descentSavedCount');
      const descentUnsavedElement = document.getElementById('descentUnsavedCount');
      if (descentSavedElement) descentSavedElement.textContent = descentData.length;
      if (descentUnsavedElement) descentUnsavedElement.textContent = unsavedDescentPoints.length;
    }

    // Redraw chart with existing data
    function redrawChart(type) {
      const canvas = document.getElementById(type === 'cervix' ? 'cervixChart' : 'descentChart');
      if (!canvas) return;
      
      setupChart(canvas, type);
      
      // Redraw all saved points with saved point styling
      const data = type === 'cervix' ? cervixData : descentData;
      data.forEach(point => {
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = type === 'cervix' ? '#3b82f6' : '#10b981';
        ctx.font = 'bold 24px Arial'; // Use saved point font size
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        if (type === 'cervix') {
          ctx.fillText('X', point.x, point.y);
        } else {
          ctx.fillText('O', point.x, point.y);
        }
      });
      
      // Update status indicators after redrawing
      updateChartStatus();
    }

    // Generate Medication table with dynamic time columns
    function generateMedicationTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Add CSS class for second stage if active
      if (secondStageStartTime && isSecondStageActive) {
        table.classList.add('second-stage-active');
        console.log('üü¢ Medication table: Added second-stage-active class');
      } else {
        table.classList.remove('second-stage-active');
        console.log('üîµ Medication table: Removed second-stage-active class');
      }
      
      // Create table header
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      
      // Field header
      const fieldHeader = document.createElement("th");
      fieldHeader.className = "field-header sticky-field";
      fieldHeader.textContent = "Field";
      headerRow.appendChild(fieldHeader);
      
      // Time headers (1-hour intervals with second stage highlighting)
      console.log(`üîç Medication table: Checking second stage state - secondStageStartTime: ${secondStageStartTime}, isSecondStageActive: ${isSecondStageActive}`);
      medicationTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
          console.log(`üü¢ Medication: Second stage highlighting applied to ${time}`);
          console.log(`üîç Style applied: backgroundColor=${timeHeader.style.backgroundColor}, color=${timeHeader.style.color}`);
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
          console.log(`üîµ Medication: First stage highlighting applied to ${time}`);
          console.log(`üîç Style applied: backgroundColor=${timeHeader.style.backgroundColor}, color=${timeHeader.style.color}`);
        }
        
        timeHeader.textContent = time;
        headerRow.appendChild(timeHeader);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement("tbody");
      
      // Row 1: Oxytocin
      const oxytocinRow = document.createElement("tr");
      
      // Field cell
      const oxytocinFieldCell = document.createElement("td");
      oxytocinFieldCell.className = "field-cell sticky-field";
      oxytocinFieldCell.textContent = "Oxytocin";
      oxytocinRow.appendChild(oxytocinFieldCell);
      
      // Time cells for oxytocin
      medicationTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Medication_Oxytocin_${timeKey}`;
        const value = existing[key] || "";
        
        // Create the main container for this cell
        const cellContainer = document.createElement("div");
        cellContainer.className = "medication-cell-container";
        
        if (value === "Y") {
          // Show input fields when Y is selected
          const detailsContainer = document.createElement("div");
          detailsContainer.className = "oxytocin-details";
          
          const uLInput = document.createElement("input");
          uLInput.name = `${key}_UL`;
          uLInput.type = "number";
          uLInput.className = "form-control form-control-sm mb-1";
          uLInput.placeholder = "U/L";
          uLInput.min = "0";
          uLInput.step = "0.1";
          uLInput.value = existing[`${key}_UL`] || "";
          detailsContainer.appendChild(uLInput);
          
          const dropsInput = document.createElement("input");
          dropsInput.name = `${key}_drops`;
          dropsInput.type = "number";
          dropsInput.className = "form-control form-control-sm";
          dropsInput.placeholder = "drops/min";
          dropsInput.min = "0";
          dropsInput.step = "1";
          dropsInput.value = existing[`${key}_drops`] || "";
          detailsContainer.appendChild(dropsInput);
          
          // Add hidden input to store the Y value
          const hiddenInput = document.createElement("input");
          hiddenInput.type = "hidden";
          hiddenInput.name = key;
          hiddenInput.value = "Y";
          detailsContainer.appendChild(hiddenInput);
          
          // Add change to N button
          const changeButton = document.createElement("button");
          changeButton.type = "button";
          changeButton.className = "btn btn-sm btn-outline-secondary mt-1";
          changeButton.textContent = "Change to N";
          changeButton.onclick = function() {
            // Clear the cell and regenerate with N selected
            timeCell.innerHTML = "";
            generateOxytocinCell(timeCell, time, { [key]: "N" });
          };
          detailsContainer.appendChild(changeButton);
          
          cellContainer.appendChild(detailsContainer);
        } else {
          // Show dropdown when N or empty
          const select = document.createElement("select");
          select.name = key;
          select.className = "form-select form-select-sm";
          
          const blankOption = document.createElement("option");
          blankOption.value = "";
          blankOption.textContent = "";
          select.appendChild(blankOption);
          
          const noOption = document.createElement("option");
          noOption.value = "N";
          noOption.textContent = "N";
          select.appendChild(noOption);
          
          const yesOption = document.createElement("option");
          yesOption.value = "Y";
          yesOption.textContent = "Y";
          select.appendChild(yesOption);
          
          select.value = value;
          
          // Add change event listener
          select.addEventListener('change', function() {
            if (this.value === "Y") {
              // Clear the cell and regenerate with Y selected
              timeCell.innerHTML = "";
              generateOxytocinCell(timeCell, time, { [key]: "Y" });
            }
          });
          
          cellContainer.appendChild(select);
        }
        
        timeCell.appendChild(cellContainer);
        oxytocinRow.appendChild(timeCell);
      });
      
      tbody.appendChild(oxytocinRow);
      
      // Row 2: Medicine
      const medicineRow = document.createElement("tr");
      
      // Field cell
      const medicineFieldCell = document.createElement("td");
      medicineFieldCell.className = "field-cell sticky-field";
      medicineFieldCell.textContent = "Medicine";
      medicineRow.appendChild(medicineFieldCell);
      
      // Time cells for medicine
      medicationTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Medication_Medicine_${timeKey}`;
        const value = existing[key] || "";
        
        // Create the main container for this cell
        const cellContainer = document.createElement("div");
        cellContainer.className = "medication-cell-container";
        
        if (value === "Y") {
          // Show text input when Y is selected
          const detailsContainer = document.createElement("div");
          detailsContainer.className = "medicine-details";
          
          // Add hidden input to store the Y value
          const hiddenInput = document.createElement("input");
          hiddenInput.type = "hidden";
          hiddenInput.name = key;
          hiddenInput.value = "Y";
          detailsContainer.appendChild(hiddenInput);
          
          // Create text input with a different name for the actual medicine text
          const textInput = document.createElement("input");
          textInput.name = `${key}_text`;
          textInput.type = "text";
          textInput.className = "form-control form-control-sm";
          textInput.placeholder = "Medicine name";
          textInput.value = existing[`${key}_text`] || "";
          detailsContainer.appendChild(textInput);
          
          // Add change to N button
          const changeButton = document.createElement("button");
          changeButton.type = "button";
          changeButton.className = "btn btn-sm btn-outline-secondary mt-1";
          changeButton.textContent = "Change to N";
          changeButton.onclick = function() {
            // Clear the cell and regenerate with N selected
            timeCell.innerHTML = "";
            generateMedicineCell(timeCell, time, { [key]: "N" });
          };
          detailsContainer.appendChild(changeButton);
          
          cellContainer.appendChild(detailsContainer);
        } else {
          // Show dropdown when N or empty
          const select = document.createElement("select");
          select.name = key;
          select.className = "form-select form-select-sm";
          
          const blankOption = document.createElement("option");
          blankOption.value = "";
          blankOption.textContent = "";
          select.appendChild(blankOption);
          
          const noOption = document.createElement("option");
          noOption.value = "N";
          noOption.textContent = "N";
          select.appendChild(noOption);
          
          const yesOption = document.createElement("option");
          yesOption.value = "Y";
          yesOption.textContent = "Y";
          select.appendChild(yesOption);
          
          select.value = value;
          
          // Add change event listener
          select.addEventListener('change', function() {
            if (this.value === "Y") {
              // Clear the cell and regenerate with Y selected
              timeCell.innerHTML = "";
              generateMedicineCell(timeCell, time, { [key]: "Y" });
            }
          });
          
          cellContainer.appendChild(select);
        }
        
        timeCell.appendChild(cellContainer);
        medicineRow.appendChild(timeCell);
      });
      
      tbody.appendChild(medicineRow);
      
      // Row 3: IV Fluids
      const ivFluidsRow = document.createElement("tr");
      
      // Field cell
      const ivFluidsFieldCell = document.createElement("td");
      ivFluidsFieldCell.className = "field-cell sticky-field";
      ivFluidsFieldCell.textContent = "IV Fluids";
      ivFluidsRow.appendChild(ivFluidsFieldCell);
      
      // Time cells for IV fluids
      medicationTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Medication_IV_Fluids_${timeKey}`;
        const value = existing[key] || "";
        
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        const noOption = document.createElement("option");
        noOption.value = "N";
        noOption.textContent = "N";
        select.appendChild(noOption);
        
        const yesOption = document.createElement("option");
        yesOption.value = "Y";
        yesOption.textContent = "Y";
        select.appendChild(yesOption);
        
        select.value = value;
        timeCell.appendChild(select);
        ivFluidsRow.appendChild(timeCell);
      });
      
      tbody.appendChild(ivFluidsRow);
      table.appendChild(tbody);
      
      // Debug: Check computed styles after table generation
      setTimeout(() => {
        console.log('üîç Debugging medication table styles after generation:');
        const timeHeaders = table.querySelectorAll('.time-header');
        timeHeaders.forEach((header, index) => {
          const computedStyle = window.getComputedStyle(header);
          console.log(`Time header ${index}: "${header.textContent}"`);
          console.log(`  Inline style: backgroundColor=${header.style.backgroundColor}, color=${header.style.color}`);
          console.log(`  Computed style: backgroundColor=${computedStyle.backgroundColor}, color=${computedStyle.color}`);
        });
        
        // Force re-application of second stage colors if needed
        if (secondStageStartTime && isSecondStageActive) {
          console.log('üîÑ Force re-applying second stage colors to medication table');
          timeHeaders.forEach((header, index) => {
            const timeText = header.textContent;
            if (isSecondStageTime(timeText)) {
              header.style.setProperty('background-color', '#dcfce7', 'important');
              header.style.setProperty('color', '#166534', 'important');
              console.log(`‚úÖ Force applied green to ${timeText}`);
            }
          });
        }
      }, 100);
    }

    // Helper function to generate Oxytocin cell content
    function generateOxytocinCell(timeCell, time, existing) {
      const timeKey = time.replace(':', '_');
      const key = `Medication_Oxytocin_${timeKey}`;
      
      const cellContainer = document.createElement("div");
      cellContainer.className = "medication-cell-container";
      
      if (existing[key] === "Y") {
        // Show input fields when Y is selected
        const detailsContainer = document.createElement("div");
        detailsContainer.className = "oxytocin-details";
        
        const uLInput = document.createElement("input");
        uLInput.name = `${key}_UL`;
        uLInput.type = "number";
        uLInput.className = "form-control form-control-sm mb-1";
        uLInput.placeholder = "U/L";
        uLInput.min = "0";
        uLInput.step = "0.1";
        uLInput.value = existing[`${key}_UL`] || "";
        detailsContainer.appendChild(uLInput);
        
        const dropsInput = document.createElement("input");
        dropsInput.name = `${key}_drops`;
        dropsInput.type = "number";
        dropsInput.className = "form-control form-control-sm";
        dropsInput.placeholder = "drops/min";
        dropsInput.min = "0";
        dropsInput.step = "1";
        dropsInput.value = existing[`${key}_drops`] || "";
        detailsContainer.appendChild(dropsInput);
        
        // Add hidden input to store the Y value
        const hiddenInput = document.createElement("input");
        hiddenInput.type = "hidden";
        hiddenInput.name = key;
        hiddenInput.value = "Y";
        detailsContainer.appendChild(hiddenInput);
        
        // Add change to N button
        const changeButton = document.createElement("button");
        changeButton.type = "button";
        changeButton.className = "btn btn-sm btn-outline-secondary mt-1";
        changeButton.textContent = "Change to N";
        changeButton.onclick = function() {
          // Clear the cell and regenerate with N selected
          timeCell.innerHTML = "";
          generateOxytocinCell(timeCell, time, { [key]: "N" });
        };
        detailsContainer.appendChild(changeButton);
        
        cellContainer.appendChild(detailsContainer);
      } else {
        // Show dropdown when N or empty
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        const noOption = document.createElement("option");
        noOption.value = "N";
        noOption.textContent = "N";
        select.appendChild(noOption);
        
        const yesOption = document.createElement("option");
        yesOption.value = "Y";
        yesOption.textContent = "Y";
        select.appendChild(yesOption);
        
        select.value = existing[key] || "";
        
        // Add change event listener
        select.addEventListener('change', function() {
          if (this.value === "Y") {
            // Clear the cell and regenerate with Y selected
            timeCell.innerHTML = "";
            generateOxytocinCell(timeCell, time, { [key]: "Y" });
          }
        });
        
        cellContainer.appendChild(select);
      }
      
      timeCell.appendChild(cellContainer);
    }

    // Helper function to generate Medicine cell content
    function generateMedicineCell(timeCell, time, existing) {
      const timeKey = time.replace(':', '_');
      const key = `Medication_Medicine_${timeKey}`;
      
      const cellContainer = document.createElement("div");
      cellContainer.className = "medication-cell-container";
      
      if (existing[key] === "Y") {
        // Show text input when Y is selected
        const detailsContainer = document.createElement("div");
        detailsContainer.className = "medicine-details";
        
        // Add hidden input to store the Y value
        const hiddenInput = document.createElement("input");
        hiddenInput.type = "hidden";
        hiddenInput.name = key;
        hiddenInput.value = "Y";
        detailsContainer.appendChild(hiddenInput);
        
        // Create text input with a different name for the actual medicine text
        const textInput = document.createElement("input");
        textInput.name = `${key}_text`;
        textInput.type = "text";
        textInput.className = "form-control form-control-sm";
        textInput.placeholder = "Medicine name";
        textInput.value = existing[`${key}_text`] || "";
        detailsContainer.appendChild(textInput);
        
        // Add change to N button
        const changeButton = document.createElement("button");
        changeButton.type = "button";
        changeButton.className = "btn btn-sm btn-outline-secondary mt-1";
        changeButton.textContent = "Change to N";
        changeButton.onclick = function() {
          // Clear the cell and regenerate with N selected
          timeCell.innerHTML = "";
          generateMedicineCell(timeCell, time, { [key]: "N" });
        };
        detailsContainer.appendChild(changeButton);
        
        cellContainer.appendChild(detailsContainer);
      } else {
        // Show dropdown when N or empty
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        const noOption = document.createElement("option");
        noOption.value = "N";
        noOption.textContent = "N";
        select.appendChild(noOption);
        
        const yesOption = document.createElement("option");
        yesOption.value = "Y";
        yesOption.textContent = "Y";
        select.appendChild(yesOption);
        
        select.value = existing[key] || "";
        
        // Add change event listener
        select.addEventListener('change', function() {
          if (this.value === "Y") {
            // Clear the cell and regenerate with Y selected
            timeCell.innerHTML = "";
            generateMedicineCell(timeCell, time, { [key]: "Y" });
          }
        });
        
        cellContainer.appendChild(select);
      }
      
      timeCell.appendChild(cellContainer);
    }

    // Shared Decision-Making Table - Following WHO LCG Guidelines
    function generateSharedDecisionTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Create two separate mini-tables for better usability
      
      // ===== ASSESSMENT TABLE =====
      const assessmentTable = document.createElement("div");
      assessmentTable.className = "mini-table-container mb-4";
      
      const assessmentTitle = document.createElement("h5");
      assessmentTitle.className = "mini-table-title";
      assessmentTitle.innerHTML = '<i class="fas fa-clipboard-list"></i> Assessment';
      assessmentTable.appendChild(assessmentTitle);
      
      const assessmentTableElement = document.createElement("table");
      assessmentTableElement.className = "summary-table mini-table";
      
      // Assessment table header
      const assessmentThead = document.createElement("thead");
      const assessmentHeaderRow = document.createElement("tr");
      
      // Field header
      const assessmentFieldHeader = document.createElement("th");
      assessmentFieldHeader.className = "field-header sticky-field";
      assessmentFieldHeader.textContent = "Field";
      assessmentHeaderRow.appendChild(assessmentFieldHeader);
      
      // Time headers (1-hour intervals from 01:00 to 15:00)
      assessmentTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark green text
        }
        
        timeHeader.textContent = time;
        assessmentHeaderRow.appendChild(timeHeader);
      });
      
      assessmentThead.appendChild(assessmentHeaderRow);
      assessmentTableElement.appendChild(assessmentThead);
      
      // Assessment table body
      const assessmentTbody = document.createElement("tbody");
      
      // Assessment data rows
      const assessmentFields = ["Woman's condition", "Baby's condition", "Labour progress", "Other concerns"];
      
      assessmentFields.forEach(field => {
        const row = document.createElement("tr");
        
        // Field cell
        const fieldCell = document.createElement("td");
        fieldCell.className = "field-cell sticky-field";
        fieldCell.textContent = field;
        row.appendChild(fieldCell);
        
        // Time cells for assessment (1-hour intervals)
        assessmentTimeCols.forEach(time => {
          const timeCell = document.createElement("td");
          timeCell.className = "time-cell";
          timeCell.style.minWidth = "60px";
          
          const timeKey = time.replace(':', '_');
          const fieldKey = field.replace(/\s+/g, '_').replace("'", "");
          const key = `ASSESSMENT_${fieldKey}_${timeKey}`;
          const value = existing[key] || "";
          
          const input = document.createElement("input");
          input.name = key;
          input.type = "text";
          input.className = "form-control form-control-sm";
          input.placeholder = "Brief note";
          input.value = value;
          timeCell.appendChild(input);
          row.appendChild(timeCell);
        });
        
        assessmentTbody.appendChild(row);
      });
      
      assessmentTableElement.appendChild(assessmentTbody);
      assessmentTable.appendChild(assessmentTableElement);
      
      // ===== PLAN TABLE =====
      const planTable = document.createElement("div");
      planTable.className = "mini-table-container";
      
      const planTitle = document.createElement("h5");
      planTitle.className = "mini-table-title";
      planTitle.innerHTML = '<i class="fas fa-tasks"></i> Plan';
      planTable.appendChild(planTitle);
      
      const planTableElement = document.createElement("table");
      planTableElement.className = "summary-table mini-table";
      
      // Plan table header
      const planThead = document.createElement("thead");
      const planHeaderRow = document.createElement("tr");
      
      // Field header
      const planFieldHeader = document.createElement("th");
      planFieldHeader.className = "field-header sticky-field";
      planFieldHeader.textContent = "Field";
      planHeaderRow.appendChild(planFieldHeader);
      
      // Time headers (2-hour intervals from 02:00 to 14:00)
      planTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        planHeaderRow.appendChild(timeHeader);
      });
      
      planThead.appendChild(planHeaderRow);
      planTableElement.appendChild(planThead);
      
      // Plan table body
      const planTbody = document.createElement("tbody");
      
      // Single plan row
      const planRow = document.createElement("tr");
      
      // Field cell
      const planFieldCell = document.createElement("td");
      planFieldCell.className = "field-cell sticky-field";
      planFieldCell.textContent = "Plan";
      planRow.appendChild(planFieldCell);
      
      // Time cells for plan (2-hour intervals)
      planTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        timeCell.style.minWidth = "120px";
        
        const timeKey = time.replace(':', '_');
        const key = `PLAN_${timeKey}`;
        const value = existing[key] || "";
        
        const input = document.createElement("input");
        input.name = key;
        input.type = "text";
        input.className = "form-control form-control-sm";
        input.placeholder = "Detailed plan";
        input.value = value;
        timeCell.appendChild(input);
        planRow.appendChild(timeCell);
      });
      
      planTbody.appendChild(planRow);
      planTableElement.appendChild(planTbody);
      planTable.appendChild(planTableElement);
      
      // Add both tables to the main container
      table.appendChild(assessmentTable);
      table.appendChild(planTable);
      
      // Add event listeners for all inputs
      const allInputs = table.querySelectorAll('input[type="text"]');
      allInputs.forEach(input => {
        input.addEventListener('change', function() {
          // Recommendations will be shown when needed, not on every change
        });
        input.addEventListener('input', function() {
          // Recommendations will be shown when needed, not on every change
        });
      });
    }

    // ===== DYNAMIC TIME MANAGEMENT =====
    let activeFirstStageStartTime = null;
    let secondStageStartTime = null;
    let isSecondStageActive = false;
    
    // Default time intervals (will be dynamically generated)
    let supportiveCareTimeCols = [];
    let babyBaselineTimeCols = [];
    let babyOtherTimeCols = [];
    let womanTimeCols = [];
    let contractionsTimeCols = [];
    let cervixPlotTimeCols = [];
    let descentPlotTimeCols = [];
    let medicationTimeCols = [];
    let assessmentTimeCols = [];
    let planTimeCols = [];
    let initialsTimeCols = [];
    
    // Second stage time intervals (15-minute for contractions and FHR)
    let contractionsTimeColsSecondStage = [];
    let babyBaselineTimeColsSecondStage = [];
    
    // Generate time columns based on starting time
    function generateDynamicTimeColumns() {
      console.log('üöÄ generateDynamicTimeColumns() called');
      console.log(`  activeFirstStageStartTime: ${activeFirstStageStartTime}`);
      
      if (!activeFirstStageStartTime) {
        // Default fallback - use current time as starting point
        const now = new Date();
        activeFirstStageStartTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        console.log(`  No starting time, using current time: ${activeFirstStageStartTime}`);
      }
      
      const startHour = parseInt(activeFirstStageStartTime.split(':')[0]);
      const startMinute = parseInt(activeFirstStageStartTime.split(':')[1]);
      
      // Supportive Care: +1 hour intervals for 12 hours
      supportiveCareTimeCols = [];
      for (let i = 0; i <= 12; i++) {
        const hour = (startHour + i) % 24;
        supportiveCareTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
      }
      
      // Baby Baseline & FHR: +30 minute intervals for 12 hours (FIRST STAGE)
      babyBaselineTimeCols = [];
      for (let i = 0; i <= 24; i++) {
        const totalMinutes = startHour * 60 + startMinute + (i * 30);
        const hour = Math.floor(totalMinutes / 60) % 24;
        const minute = totalMinutes % 60;
        babyBaselineTimeCols.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      }
      
      // Baby Baseline & FHR: +15 minute intervals for 12 hours (SECOND STAGE)
      babyBaselineTimeColsSecondStage = [];
      for (let i = 0; i <= 48; i++) {
        const totalMinutes = startHour * 60 + startMinute + (i * 15);
        const hour = Math.floor(totalMinutes / 60) % 24;
        const minute = totalMinutes % 60;
        babyBaselineTimeColsSecondStage.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      }
      
      // Baby Other, Woman, Medication, Assessment, Initials: +1 hour intervals for 12 hours
      babyOtherTimeCols = [];
      womanTimeCols = [];
      medicationTimeCols = [];
      assessmentTimeCols = [];
      initialsTimeCols = [];
      for (let i = 0; i <= 12; i++) {
        const hour = (startHour + i) % 24;
        babyOtherTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        womanTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        medicationTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        assessmentTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        initialsTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
      }
      
      // Contractions: +30 minute intervals for 12 hours (FIRST STAGE)
      contractionsTimeCols = [];
      for (let i = 0; i <= 24; i++) {
        const totalMinutes = startHour * 60 + startMinute + (i * 30);
        const hour = Math.floor(totalMinutes / 60) % 24;
        const minute = totalMinutes % 60;
        contractionsTimeCols.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      }
      
      // Contractions: +15 minute intervals for 12 hours (SECOND STAGE)
      contractionsTimeColsSecondStage = [];
      for (let i = 0; i <= 48; i++) {
        const totalMinutes = startHour * 60 + startMinute + (i * 15);
        const hour = Math.floor(totalMinutes / 60) % 24;
        const minute = totalMinutes % 60;
        contractionsTimeColsSecondStage.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      }
      
      // Cervix & Descent Plot: +1 hour intervals for 12 hours
      cervixPlotTimeCols = [];
      descentPlotTimeCols = [];
      for (let i = 0; i <= 12; i++) {
        const hour = (startHour + i) % 24;
        cervixPlotTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        descentPlotTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
      }
      
      // Plan: +2 hour intervals for 12 hours
      planTimeCols = [];
      for (let i = 0; i <= 6; i++) {
        const hour = (startHour + (i * 2)) % 24;
        planTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
      }
    }
    
    // Check if a time column should be highlighted for second stage
    function isSecondStageTime(time) {
      if (!secondStageStartTime || !isSecondStageActive) {
        console.log(`üîç isSecondStageTime(${time}): secondStageStartTime=${secondStageStartTime}, isSecondStageActive=${isSecondStageActive}`);
        return false;
      }
      
      // Convert time strings to minutes since midnight
      const timeMinutes = timeToMinutes(time);
      const secondStageMinutes = timeToMinutes(secondStageStartTime);
      
      // Handle midnight crossing - if second stage is earlier in the day, it means it's the next day
      if (secondStageMinutes < timeMinutes) {
        // Second stage is next day, so current time is first stage
        console.log(`üîç isSecondStageTime(${time}): ${time} (${timeMinutes}min) vs ${secondStageStartTime} (${secondStageMinutes}min) - Second stage is next day, so ${time} is FIRST stage`);
        return false;
      } else {
        // Same day comparison
        const isSecondStage = timeMinutes >= secondStageMinutes;
        console.log(`üîç isSecondStageTime(${time}): ${time} (${timeMinutes}min) vs ${secondStageStartTime} (${secondStageMinutes}min) = ${isSecondStage} (same day)`);
        return isSecondStage;
      }
    }
    
    // Helper function to convert time string to minutes since midnight
    function timeToMinutes(timeStr) {
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    }
    
    // Generate hybrid time columns: 30-min before second stage, 15-min after
    function generateHybridTimeColumns() {
      console.log('üöÄ generateHybridTimeColumns() called');
      console.log(`  activeFirstStageStartTime: ${activeFirstStageStartTime}`);
      console.log(`  secondStageStartTime: ${secondStageStartTime}`);
      console.log(`  isSecondStageActive: ${isSecondStageActive}`);
      
      if (!activeFirstStageStartTime) {
        console.log('‚ùå No activeFirstStageStartTime, returning early');
        return;
      }
      
      const startHour = parseInt(activeFirstStageStartTime.split(':')[0]);
      const startMinute = parseInt(activeFirstStageStartTime.split(':')[1]);
      console.log(`  Start time: ${startHour}:${startMinute}`);
      
      // If no second stage, use 30-minute intervals for full 12 hours
      if (!secondStageStartTime || !isSecondStageActive) {
        console.log('üìÖ No second stage - generating 30-minute intervals only');
        // Keep original 30-minute intervals
        contractionsTimeCols = [];
        babyBaselineTimeCols = [];
        
        for (let i = 0; i <= 24; i++) {
          const totalMinutes = startHour * 60 + startMinute + (i * 30);
          const hour = Math.floor(totalMinutes / 60) % 24;
          const minute = totalMinutes % 60;
          const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
          contractionsTimeCols.push(timeStr);
          babyBaselineTimeCols.push(timeStr);
        }
        
        console.log(`  Generated ${contractionsTimeCols.length} 30-minute intervals:`, contractionsTimeCols);
        return;
      }
      
      console.log('üîÑ Second stage active - generating hybrid intervals');
      
      // Use the working timeToMinutes function for consistent time handling
      const startTimeMinutes = timeToMinutes(activeFirstStageStartTime);
      const secondStageMinutes = timeToMinutes(secondStageStartTime);
      
      console.log(`  Start time in minutes: ${startTimeMinutes}`);
      console.log(`  Second stage in minutes: ${secondStageMinutes}`);
      
      // Generate hybrid contractions time columns
      contractionsTimeCols = [];
      let currentTimeMinutes = startTimeMinutes;
      const endTimeMinutes = startTimeMinutes + (12 * 60); // 12 hours
      
      console.log(`  Generating from ${startTimeMinutes} to ${endTimeMinutes} minutes`);
      
      while (currentTimeMinutes <= endTimeMinutes) {
        const hour = Math.floor(currentTimeMinutes / 60) % 24;
        const minute = currentTimeMinutes % 60;
        const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        
        contractionsTimeCols.push(timeStr);
        
        // Determine interval based on whether we're before or after second stage
        if (currentTimeMinutes < secondStageMinutes) {
          // Before second stage: 30-minute intervals
          currentTimeMinutes += 30;
          console.log(`  Added ${timeStr} (30-min interval, before second stage)`);
        } else {
          // After second stage: 15-minute intervals
          currentTimeMinutes += 15;
          console.log(`  Added ${timeStr} (15-min interval, after second stage)`);
        }
      }
      
      // Generate hybrid FHR time columns
      babyBaselineTimeCols = [];
      currentTimeMinutes = startTimeMinutes;
      
      while (currentTimeMinutes <= endTimeMinutes) {
        const hour = Math.floor(currentTimeMinutes / 60) % 24;
        const minute = currentTimeMinutes % 60;
        const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        
        babyBaselineTimeCols.push(timeStr);
        
        // Determine interval based on whether we're before or after second stage
        if (currentTimeMinutes < secondStageMinutes) {
          // Before second stage: 30-minute intervals
          currentTimeMinutes += 30;
        } else {
          // After second stage: 15-minute intervals
          currentTimeMinutes += 15;
        }
      }
      
      console.log('‚úÖ Generated hybrid time columns:');
      console.log(`  Contractions: ${contractionsTimeCols.length} intervals:`, contractionsTimeCols);
      console.log(`  FHR: ${babyBaselineTimeCols.length} intervals:`, babyBaselineTimeCols);
      console.log(`  Second stage starts at: ${secondStageStartTime}`);
      console.log(`  Start time minutes: ${startTimeMinutes}`);
      console.log(`  Second stage minutes: ${secondStageMinutes}`);
      
      // Verify the hybrid nature
      const beforeSecondStage = contractionsTimeCols.filter(time => timeToMinutes(time) < secondStageMinutes);
      const afterSecondStage = contractionsTimeCols.filter(time => timeToMinutes(time) >= secondStageMinutes);
      console.log(`  Before second stage: ${beforeSecondStage.length} columns (30-min intervals)`);
      console.log(`  After second stage: ${afterSecondStage.length} columns (15-min intervals)`);
    }
    
    // Confirm second stage
    function confirmSecondStage() {
      console.log('üöÄ confirmSecondStage() called');
      
      const secondStageInput = document.getElementById('secondStageTime');
      const secondStageTime = secondStageInput.value;
      
      console.log(`  Second stage time input: ${secondStageTime}`);
      console.log(`  Active first stage time: ${activeFirstStageStartTime}`);
      
      if (!secondStageTime) {
        alert('Please enter the second stage start time first.');
        return;
      }
      
      if (!activeFirstStageStartTime) {
        alert('Please set the active first stage start time first.');
        return;
      }
      
      // Validate that second stage is after first stage (handle midnight crossing)
      const firstTime = new Date(`2000-01-01T${activeFirstStageStartTime}:00`);
      const secondTime = new Date(`2000-01-01T${secondStageTime}:00`);
      
      // Calculate time difference in minutes, handling midnight crossing
      let timeDiffMinutes = (secondTime - firstTime) / (1000 * 60);
      
      // If second time is earlier in the day, it means it's the next day
      if (timeDiffMinutes < 0) {
        timeDiffMinutes += 24 * 60; // Add 24 hours (1440 minutes)
      }
      
      console.log(`  Time difference: ${timeDiffMinutes} minutes`);
      
      // Second stage must be at least 30 minutes after first stage
      if (timeDiffMinutes < 30) {
        alert('Second stage must start at least 30 minutes after the active first stage start time.');
        return;
      }
      
      console.log('‚úÖ Validation passed, setting second stage...');
      
      secondStageStartTime = secondStageTime;
      isSecondStageActive = true;
      
      console.log(`  secondStageStartTime set to: ${secondStageStartTime}`);
      console.log(`  isSecondStageActive set to: ${isSecondStageActive}`);
      
      // Show second stage card
      document.getElementById('secondStageCard').style.display = 'block';
      
      // Hide the second stage controls (button disappears)
      document.getElementById('secondStageControls').style.display = 'none';
      
      // Update display
      const firstStageDuration = Math.round((secondTime - firstTime) / (1000 * 60));
      document.getElementById('firstStageDuration').textContent = `${firstStageDuration} minutes`;
      document.getElementById('secondStageStartDisplay').textContent = secondStageTime;
      
      // Save the second stage time
      saveSecondStageData();
      
      // Lock the second stage time input
      lockTimeInput("secondStageTime", "Second Stage Start Time");
      
      console.log('üîÑ Generating hybrid time columns...');
      
      // Generate hybrid time columns (30-min before, 15-min after second stage)
      generateHybridTimeColumns();
      
      console.log('üîÑ Regenerating contractions and FHR tables...');
      
      // Regenerate only contractions and FHR tables with hybrid time columns
      regenerateContractionsAndFHRTables();
      
      console.log('üé® Updating second stage colors...');
      
      // Update colors for all tables (including the new hybrid columns)
      updateSecondStageColors();
      
      console.log('üîÑ Force refreshing all tables...');
      
      // Force refresh of all tables to ensure hybrid columns are displayed
      setTimeout(() => {
        generateSummaryTable({});
        updateSecondStageColors();
      }, 200);
      
      // Show success message
      showSaveSuccess();
      
      console.log('‚úÖ Second stage confirmed with hybrid time columns');
    }
    
    // Update second stage colors without regenerating tables
    function updateSecondStageColors() {
      console.log('üé® updateSecondStageColors() called');
      console.log(`  secondStageStartTime: ${secondStageStartTime}`);
      console.log(`  isSecondStageActive: ${isSecondStageActive}`);
      
      // Update time header colors in all tables
      const allTimeHeaders = document.querySelectorAll('.time-header');
      console.log(`  Found ${allTimeHeaders.length} time headers to update`);
      
      allTimeHeaders.forEach((header, index) => {
        const timeText = header.textContent;
        const isSecondStage = isSecondStageTime(timeText);
        console.log(`  Header ${index}: "${timeText}" - isSecondStage: ${isSecondStage}`);
        
        if (isSecondStage) {
          header.style.setProperty('background-color', '#dcfce7', 'important'); // Light green for second stage
          header.style.setProperty('color', '#166534', 'important'); // Dark green text
          console.log(`üü¢ Updated ${timeText} to second stage colors`);
        } else {
          header.style.setProperty('background-color', '#dbeafe', 'important'); // Light blue for first stage
          header.style.setProperty('color', '#1e40af', 'important'); // Dark blue text
          console.log(`üîµ Updated ${timeText} to first stage colors`);
        }
      });
      
      // Also update the medication table CSS class
      const medicationTable = document.getElementById('medicationTable');
      if (medicationTable && secondStageStartTime && isSecondStageActive) {
        medicationTable.classList.add('second-stage-active');
        console.log('üü¢ Added second-stage-active class to medication table');
      }
      
      console.log('‚úÖ Second stage colors updated without data loss');
    }
    
    // Save second stage data to Firestore
    async function saveSecondStageData() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) {
          console.error('No patient ID found in URL');
          return;
        }
        
        const secondStageData = {
          secondStageStartTime: secondStageStartTime,
          isSecondStageActive: isSecondStageActive,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('records')
          .doc('secondStage')
          .set(secondStageData);
        
        console.log('Second stage data saved successfully');
      } catch (error) {
        console.error('Error saving second stage data:', error);
      }
    }
    
    // Load second stage data from Firestore
    async function loadSecondStageData() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        const doc = await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('records')
          .doc('secondStage')
          .get();
        
        if (doc.exists) {
          const data = doc.data();
          secondStageStartTime = data.secondStageStartTime;
          isSecondStageActive = data.isSecondStageActive;
          
          if (isSecondStageActive && secondStageStartTime) {
            // Show second stage card
            document.getElementById('secondStageCard').style.display = 'block';
            
            // Update display
            if (activeFirstStageStartTime) {
              const firstTime = new Date(`2000-01-01T${activeFirstStageStartTime}:00`);
              const secondTime = new Date(`2000-01-01T${secondStageStartTime}:00`);
              const firstStageDuration = Math.round((secondTime - firstTime) / (1000 * 60));
              
              document.getElementById('firstStageDuration').textContent = `${firstStageDuration} minutes`;
              document.getElementById('secondStageStartDisplay').textContent = secondStageStartTime;
            }
            
            // Lock the second stage time input
            lockTimeInput("secondStageTime", "Second Stage Start Time");
            
            // Generate hybrid time columns for second stage
            generateHybridTimeColumns();
            
            // Update colors for all tables after generating hybrid columns
            setTimeout(() => {
              updateSecondStageColors();
            }, 100);
          }
        }
      } catch (error) {
        console.error('Error loading second stage data:', error);
      }
    }
    
    // Save starting time data
    async function saveStartingTime() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) {
          console.error('No patient ID found in URL');
          return;
        }
        
        await firebase.firestore()
          .collection("patients")
          .doc(patientId)
          .collection("records")
          .doc("startingTime")
          .set({
            startingTime: activeFirstStageStartTime,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
        
        console.log('Starting time saved successfully');
      } catch (error) {
        console.error("Error saving starting time:", error);
      }
    }
    
    // Preserve existing data when starting time changes
    function preserveExistingData() {
      const existingData = {};
      
      // Collect all existing form data before regenerating tables
      const allInputs = document.querySelectorAll('input, select');
      allInputs.forEach(input => {
        if (input.name && input.value) {
          existingData[input.name] = input.value;
        }
      });
      
      return existingData;
    }
    
    // Map existing data to new time columns
    function mapDataToNewTimes(existingData, oldStartTime, newStartTime) {
      if (!oldStartTime || !newStartTime) return existingData;
      
      const mappedData = {};
      const oldHour = parseInt(oldStartTime.split(':')[0]);
      const newHour = parseInt(newStartTime.split(':')[0]);
      const hourDiff = newHour - oldHour;
      
      Object.keys(existingData).forEach(key => {
        // Extract time from key (e.g., "08:00_Field_Name" -> "08:00")
        const timeMatch = key.match(/(\d{2}:\d{2})_/);
        if (timeMatch) {
          const oldTime = timeMatch[1];
          const oldTimeHour = parseInt(oldTime.split(':')[0]);
          const newTimeHour = (oldTimeHour + hourDiff + 24) % 24; // Handle day wrap
          const newTime = `${newTimeHour.toString().padStart(2, '0')}:${oldTime.split(':')[1]}`;
          
          // Create new key with new time
          const newKey = key.replace(oldTime, newTime);
          mappedData[newKey] = existingData[key];
        } else {
          // Keep non-time-based data as is
          mappedData[key] = existingData[key];
        }
      });
      
      return mappedData;
    }
    
    // Regenerate only contractions and FHR tables with hybrid time columns
    function regenerateContractionsAndFHRTables() {
      console.log('üîÑ Regenerating contractions and FHR tables with hybrid time columns...');
      
      // Clear only contractions and FHR tables
      document.getElementById("contractionsTable").innerHTML = "";
      document.getElementById("fhrTable").innerHTML = "";
      
      // Generate tables with hybrid time columns
      generateSectionTable("Contractions", sections["Contractions"], "contractionsTable", {});
      generateSectionTable("FHR", sections["FHR"], "fhrTable", {});
      
      // Add event listeners for the new tables
      addFormEventListeners();
      
      console.log('‚úÖ Contractions and FHR tables regenerated with hybrid time columns');
    }
    
    // Regenerate all tables (used when second stage is confirmed)
    function regenerateAllTables() {
      // This function should NOT be called for second stage confirmation
      // It's only for when we actually need to regenerate tables
      console.warn('‚ö†Ô∏è regenerateAllTables() called - this should not happen for second stage');
      
      // Clear existing tables
      document.getElementById("supportiveCareTable").innerHTML = "";
      document.getElementById("babyTable").innerHTML = "";
      document.getElementById("contractionsTable").innerHTML = "";
      document.getElementById("medicationTable").innerHTML = "";
      document.getElementById("decisionMakingTable").innerHTML = "";
      document.getElementById("initialsTable").innerHTML = "";
      
      // Generate tables with empty data (fresh start)
      generateSummaryTable({});
      
      // Re-initialize plotting charts
      setTimeout(() => {
        initializePlottingCharts();
        loadPlotData();
      }, 100);
      
      // Add event listeners again
      addFormEventListeners();
    }
    
    // Regenerate all tables with preserved data
    function regenerateAllTablesWithData(preservedData) {
      // Clear existing tables
      document.getElementById('supportiveCareTable').innerHTML = '';
      document.getElementById('babyTable').innerHTML = '';
      document.getElementById('womanTable').innerHTML = '';
      document.getElementById('contractionsTable').innerHTML = '';
      document.getElementById('cervixPlotTable').innerHTML = '';
      document.getElementById('descentPlotTable').innerHTML = '';
      document.getElementById('medicationTable').innerHTML = '';
      document.getElementById('decisionMakingTable').innerHTML = '';
      document.getElementById('initialsTable').innerHTML = '';
      
      // Regenerate tables with preserved data
      generateSummaryTable(preservedData);
    }

    // DEPRECATED: Baby section with two separate tables - now using generateSectionTable for separate FHR and Baby sections
    // This function is kept for backward compatibility but is no longer used
    function generateBabyTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // ===== FHR TABLE (30-min intervals) =====
      const fhrTable = document.createElement("table");
      fhrTable.className = "summary-table mb-4";
      
      // FHR table header
      const fhrThead = document.createElement("thead");
      const fhrHeaderRow = document.createElement("tr");
      
      // Field header
      const fhrFieldHeader = document.createElement("th");
      fhrFieldHeader.className = "field-header sticky-field";
      fhrFieldHeader.textContent = "Field";
      fhrHeaderRow.appendChild(fhrFieldHeader);
      
      // Alert header
      const fhrAlertHeader = document.createElement("th");
      fhrAlertHeader.className = "alert-header sticky-alert";
      fhrAlertHeader.textContent = "Alert";
      fhrHeaderRow.appendChild(fhrAlertHeader);
      
      // Time headers (30-min intervals with second stage highlighting)
      babyBaselineTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        fhrHeaderRow.appendChild(timeHeader);
      });
      
      fhrThead.appendChild(fhrHeaderRow);
      fhrTable.appendChild(fhrThead);
      
      // FHR table body
      const fhrTbody = document.createElement("tbody");
      
      // Baseline FHR row
      const baselineFHRRow = document.createElement("tr");
      
      // Field cell
      const baselineFHRFieldCell = document.createElement("td");
      baselineFHRFieldCell.className = "field-cell sticky-field";
      baselineFHRFieldCell.textContent = "Baseline FHR";
      baselineFHRRow.appendChild(baselineFHRFieldCell);
      
      // Alert cell
      const baselineFHRAlertCell = document.createElement("td");
      baselineFHRAlertCell.className = "alert-cell sticky-alert";
      baselineFHRAlertCell.innerHTML = '<span class="alert-indicator">110-160</span>';
      baselineFHRRow.appendChild(baselineFHRAlertCell);
      
      // Time cells for Baseline FHR
      babyBaselineTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Baseline_FHR_${timeKey}`;
        const value = existing[key] || "";
        
        const input = document.createElement("input");
        input.name = key;
        input.type = "number";
        input.className = "form-control form-control-sm";
        input.placeholder = "FHR";
        input.min = "60";
        input.max = "200";
        input.value = value;
        timeCell.appendChild(input);
        baselineFHRRow.appendChild(timeCell);
      });
      
      fhrTbody.appendChild(baselineFHRRow);
      
      // FHR Deceleration row
      const decelerationRow = document.createElement("tr");
      
      // Field cell
      const decelerationFieldCell = document.createElement("td");
      decelerationFieldCell.className = "field-cell sticky-field";
      decelerationFieldCell.textContent = "FHR deceleration";
      decelerationRow.appendChild(decelerationFieldCell);
      
      // Alert cell
      const decelerationAlertCell = document.createElement("td");
      decelerationAlertCell.className = "alert-cell sticky-alert";
      decelerationAlertCell.innerHTML = '<span class="alert-indicator">L</span>';
      decelerationRow.appendChild(decelerationAlertCell);
      
      // Time cells for FHR deceleration
      babyBaselineTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `FHR_deceleration_${timeKey}`;
        const value = existing[key] || "";
        
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        ["N", "E", "L", "V"].forEach(option => {
          const optionElement = document.createElement("option");
          optionElement.value = option;
          optionElement.textContent = option;
          select.appendChild(optionElement);
        });
        
        select.value = value;
        timeCell.appendChild(select);
        decelerationRow.appendChild(timeCell);
      });
      
      fhrTbody.appendChild(decelerationRow);
      fhrTable.appendChild(fhrTbody);
      
      // ===== BABY TABLE (1-hour intervals) =====
      const babyTable = document.createElement("table");
      babyTable.className = "summary-table";
      
      // Baby table header
      const babyThead = document.createElement("thead");
      const babyHeaderRow = document.createElement("tr");
      
      // Field header
      const babyFieldHeader = document.createElement("th");
      babyFieldHeader.className = "field-header sticky-field";
      babyFieldHeader.textContent = "Field";
      babyHeaderRow.appendChild(babyFieldHeader);
      
      // Alert header
      const babyAlertHeader = document.createElement("th");
      babyAlertHeader.className = "alert-header sticky-alert";
      babyAlertHeader.textContent = "Alert";
      babyHeaderRow.appendChild(babyAlertHeader);
      
      // Time headers (1-hour intervals with second stage highlighting)
      babyOtherTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        babyHeaderRow.appendChild(timeHeader);
      });
      
      babyThead.appendChild(babyHeaderRow);
      babyTable.appendChild(babyThead);
      
      // Baby table body
      const babyTbody = document.createElement("tbody");
      
      // Baby fields
      const babyFields = ["Amniotic fluid", "Fetal position", "Caput", "Moulding"];
      
      babyFields.forEach(field => {
        const row = document.createElement("tr");
        
        // Field cell
        const fieldCell = document.createElement("td");
        fieldCell.className = "field-cell sticky-field";
        fieldCell.textContent = field;
        row.appendChild(fieldCell);
        
        // Alert cell
        const alertCell = document.createElement("td");
        alertCell.className = "alert-cell sticky-alert";
        const alertValue = whoAlertValues[field] || "";
        alertCell.innerHTML = `<span class="alert-indicator">${alertValue}</span>`;
        row.appendChild(alertCell);
        
        // Time cells
        babyOtherTimeCols.forEach(time => {
          const timeCell = document.createElement("td");
          timeCell.className = "time-cell";
          
          const timeKey = time.replace(':', '_');
          const key = `${field.replace(/\s+/g, "_")}_${timeKey}`;
          const value = existing[key] || "";
          
          const select = document.createElement("select");
          select.name = key;
          select.className = "form-select form-select-sm";
          
          const blankOption = document.createElement("option");
          blankOption.value = "";
          blankOption.textContent = "";
          select.appendChild(blankOption);
          
          // Add options based on field
          let options = [];
          switch(field) {
            case "Amniotic fluid":
              options = ["I", "C", "M", "M+", "M++", "M+++", "B"];
              break;
            case "Fetal position":
              options = ["A", "P", "T"];
              break;
            case "Caput":
            case "Moulding":
              options = ["0", "+", "++", "+++"];
              break;
          }
          
          options.forEach(option => {
            const optionElement = document.createElement("option");
            optionElement.value = option;
            optionElement.textContent = option;
            select.appendChild(optionElement);
          });
          
          select.value = value;
          timeCell.appendChild(select);
          row.appendChild(timeCell);
        });
        
        babyTbody.appendChild(row);
      });
      
      babyTable.appendChild(babyTbody);
      
      // Add both tables to the main container
      table.appendChild(fhrTable);
      table.appendChild(babyTable);
    }

    // Hide all tables initially
    function hideAllTables() {
      const allSections = [
        'supportiveCareSection', 'fhrSection', 'babySection', 'womanSection', 'contractionsSection', 'labourProgressSection', 
        'medicationSection', 'decisionMakingSection', 'initialsSection'
      ];
      
      allSections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) {
          section.style.display = 'none';
        }
      });
      
      // Also hide second stage card and clinical recommendations
      const secondStageCard = document.getElementById('secondStageCard');
      if (secondStageCard) {
        secondStageCard.style.display = 'none';
      }
      
      const recommendationsSection = document.querySelector('.recommendations-section');
      if (recommendationsSection) {
        recommendationsSection.style.display = 'none';
      }
    }

    // Show all tables after starting time is set
    function showAllTables() {
      const allSections = [
        'supportiveCareSection', 'fhrSection', 'babySection', 'womanSection', 'contractionsSection', 'labourProgressSection', 
        'medicationSection', 'decisionMakingSection', 'initialsSection'
      ];
      
      allSections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) {
          section.style.display = 'block';
        }
      });
      
      // Show clinical recommendations
      const recommendationsSection = document.querySelector('.recommendations-section');
      if (recommendationsSection) {
        recommendationsSection.style.display = 'block';
      }
      
      // Recommendations will be shown when needed, not automatically
    }

    // Show starting time requirement message
    function showStartingTimeRequirement() {
      const requirementDiv = document.getElementById('startingTimeRequirement');
      if (requirementDiv) {
        requirementDiv.style.display = 'block';
      }
    }

    // Lock time input fields to prevent changes after initial input
    function lockTimeInput(inputId, fieldName) {
      const input = document.getElementById(inputId);
      if (!input) return;
      
      // Don't lock if the input is empty or has no meaningful value
      if (!input.value || input.value.trim() === '') {
        console.log(`‚ö†Ô∏è ${fieldName} has no value, not locking`);
        return;
      }
      
      // Check if already locked
      if (isInputLocked(inputId)) {
        console.log(`üîí ${fieldName} is already locked`);
        return;
      }
      
      // Disable the input
      input.disabled = true;
      input.readOnly = true;
      
      // Add visual styling to show it's locked
      input.classList.add('locked-input');
      input.style.backgroundColor = '#f8f9fa';
      input.style.color = '#6c757d';
      input.style.cursor = 'not-allowed';
      
      // Add a lock icon and "Locked" text
      const lockIcon = document.createElement('div');
      lockIcon.className = 'lock-indicator';
      lockIcon.innerHTML = '<i class="fas fa-lock"></i> Locked';
      lockIcon.style.cssText = `
        position: absolute;
        top: 50%;
        right: 10px;
        transform: translateY(-50%);
        color: #6c757d;
        font-size: 12px;
        pointer-events: none;
        z-index: 10;
      `;
      
      // Make the parent container relative positioned if it isn't already
      const parent = input.parentElement;
      if (parent.style.position !== 'relative') {
        parent.style.position = 'relative';
      }
      
      // Remove any existing lock indicators
      const existingLock = parent.querySelector('.lock-indicator');
      if (existingLock) {
        existingLock.remove();
      }
      
      // Add the lock indicator
      parent.appendChild(lockIcon);
      
      // Note: Help text removed as requested by user
      
      // Add a locked badge to the label if it exists
      const label = input.parentElement.querySelector('label');
      if (label) {
        const lockedBadge = document.createElement('span');
        lockedBadge.className = 'badge bg-secondary ms-2';
        lockedBadge.innerHTML = '<i class="fas fa-lock"></i> Locked';
        lockedBadge.style.fontSize = '0.75em';
        label.appendChild(lockedBadge);
      }
      
      // Add event listeners to prevent any changes
      input.addEventListener('keydown', preventInput);
      input.addEventListener('input', preventInput);
      input.addEventListener('paste', preventInput);
      input.addEventListener('drop', preventInput);
      
      // Prevent focus and selection
      input.addEventListener('focus', preventFocus);
      input.addEventListener('click', preventFocus);
      
      // Additional security: prevent context menu and selection
      input.addEventListener('contextmenu', preventInput);
      input.addEventListener('selectstart', preventInput);
      
      // Prevent drag and drop
      input.draggable = false;
      
      // Set tabindex to -1 to prevent tab navigation
      input.tabIndex = -1;
      
      console.log(`üîí ${fieldName} has been locked`);
    }
    
    // Prevent any input on locked fields
    function preventInput(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // Show a brief message that the field is locked
      showLockedMessage(e.target);
      
      return false;
    }
    
    // Show message when trying to modify locked input
    function showLockedMessage(input) {
      // Create or get existing message element
      let messageDiv = document.getElementById('lockedMessage');
      if (!messageDiv) {
        messageDiv = document.createElement('div');
        messageDiv.id = 'lockedMessage';
        messageDiv.className = 'alert alert-warning alert-dismissible fade show';
        messageDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 9999;
          max-width: 300px;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        `;
        messageDiv.innerHTML = `
          <i class="fas fa-lock"></i>
          <strong>Field Locked</strong><br>
          This field has been locked and cannot be modified.
          <button type="button" class="btn-close" onclick="this.parentElement.style.display='none'"></button>
        `;
        document.body.appendChild(messageDiv);
        
        // Add event listener for close button
        const closeBtn = messageDiv.querySelector('.btn-close');
        if (closeBtn) {
          closeBtn.addEventListener('click', function() {
            messageDiv.style.display = 'none';
          });
        }
      }
      
      // Show the message
      messageDiv.style.display = 'block';
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        if (messageDiv) {
          messageDiv.style.display = 'none';
        }
      }, 3000);
    }
    
    // Prevent focus on locked fields
    function preventFocus(e) {
      e.preventDefault();
      e.target.blur();
      return false;
    }

    // Check if time inputs should be locked on page load
    function checkAndLockTimeInputs() {
      // Only lock starting time if it has a saved value from Firestore
      if (activeFirstStageStartTime && activeFirstStageStartTime !== '') {
        // Check if this is actually a saved value, not just an empty string
        const startingTimeInput = document.getElementById("startingTime");
        if (startingTimeInput && startingTimeInput.value && startingTimeInput.value.trim() !== '') {
          lockTimeInput("startingTime", "Active First Stage Start Time");
        }
      }
      
      // Only lock second stage time if it has a saved value from Firestore
      if (secondStageStartTime && isSecondStageActive && secondStageStartTime !== '') {
        const secondStageInput = document.getElementById("secondStageTime");
        if (secondStageInput && secondStageInput.value && secondStageInput.value.trim() !== '') {
          lockTimeInput("secondStageTime", "Second Stage Start Time");
        }
      }
    }
    
    // Check if an input is already locked
    function isInputLocked(inputId) {
      const input = document.getElementById(inputId);
      return input && input.classList.contains('locked-input');
    }
    
    // Unlock an input (for administrators only)
    function unlockTimeInput(inputId, fieldName) {
      const input = document.getElementById(inputId);
      if (!input) return;
      
      if (!isInputLocked(inputId)) {
        console.log(`üîì ${fieldName} is not locked`);
        return;
      }
      
      // Re-enable the input
      input.disabled = false;
      input.readOnly = false;
      
      // Remove locked styling
      input.classList.remove('locked-input');
      input.style.backgroundColor = '';
      input.style.color = '';
      input.style.cursor = '';
      
      // Remove lock indicator
      const lockIndicator = input.parentElement.querySelector('.lock-indicator');
      if (lockIndicator) {
        lockIndicator.remove();
      }
      
      // Note: Help text removal code removed as it's no longer needed
      
      // Remove locked badge from label
      const label = input.parentElement.querySelector('label');
      if (label) {
        const lockedBadge = label.querySelector('.badge');
        if (lockedBadge) {
          lockedBadge.remove();
        }
      }
      
      // Remove event listeners
      input.removeEventListener('keydown', preventInput);
      input.removeEventListener('input', preventInput);
      input.removeEventListener('paste', preventInput);
      input.removeEventListener('drop', preventInput);
      input.removeEventListener('focus', preventFocus);
      input.removeEventListener('click', preventFocus);
      
      console.log(`üîì ${fieldName} has been unlocked`);
    }
    
    // Log current lock status for debugging
    function logLockStatus() {
      console.log('üîí Current Lock Status:');
      console.log(`  Starting Time: ${isInputLocked('startingTime') ? 'LOCKED' : 'UNLOCKED'}`);
      console.log(`  Second Stage Time: ${isInputLocked('secondStageTime') ? 'LOCKED' : 'UNLOCKED'}`);
      console.log(`  Active First Stage Start Time: ${activeFirstStageStartTime || 'NOT SET'}`);
      console.log(`  Second Stage Start Time: ${secondStageStartTime || 'NOT SET'}`);
      console.log(`  Is Second Stage Active: ${isSecondStageActive}`);
    }
    
    // Periodic check to ensure inputs remain locked
    function startLockMonitoring() {
      setInterval(() => {
        // Check if locked inputs are still properly locked
        const startingTimeInput = document.getElementById("startingTime");
        if (activeFirstStageStartTime && activeFirstStageStartTime !== '' && 
            startingTimeInput && startingTimeInput.value && startingTimeInput.value.trim() !== '' && 
            !isInputLocked('startingTime')) {
          console.log('‚ö†Ô∏è Starting time input was unlocked, re-locking...');
          lockTimeInput("startingTime", "Active First Stage Start Time");
        }
        
        const secondStageInput = document.getElementById("secondStageTime");
        if (secondStageStartTime && isSecondStageActive && secondStageStartTime !== '' && 
            secondStageInput && secondStageInput.value && secondStageInput.value.trim() !== '' && 
            !isInputLocked('secondStageTime')) {
          console.log('‚ö†Ô∏è Second stage time input was unlocked, re-locking...');
          lockTimeInput("secondStageTime", "Second Stage Start Time");
        }
      }, 5000); // Check every 5 seconds
    }

    // ===== END TREATMENT FUNCTIONS =====
    let selectedEndTreatmentOption = null;
    let isTreatmentEnded = false;
    let treatmentOutcome = null;

    // Handle end treatment button click
    function handleEndTreatmentClick() {
      if (isTreatmentEnded) {
        // Resume treatment
        resumeTreatment();
      } else {
        // Show end treatment modal
        showEndTreatmentModal();
      }
    }

    // Resume treatment
    function resumeTreatment() {
      if (confirm('Are you sure you want to resume this treatment? This will clear the end treatment status.')) {
        isTreatmentEnded = false;
        treatmentOutcome = null;
        
        // Update button
        updateEndTreatmentButton();
        
        // Clear end treatment data from Firestore
        clearEndTreatmentData();
        
        // Show success message
        showSaveSuccess();
      }
    }

    // Update end treatment button state
    function updateEndTreatmentButton() {
      const btn = document.getElementById('endTreatmentBtn');
      const icon = btn.querySelector('i');
      const text = btn.querySelector('span');
      
      if (isTreatmentEnded) {
        btn.className = 'floating-btn btn-resume-treatment';
        icon.className = 'fas fa-play';
        text.setAttribute('data-i18n', 'resumeTreatment');
        text.textContent = languageManager ? languageManager.t('resumeTreatment') : 'Resume Treatment';
      } else {
        btn.className = 'floating-btn btn-end-treatment';
        icon.className = 'fas fa-chevron-down';
        icon.className = 'fas fa-flag-checkered';
        text.setAttribute('data-i18n', 'endTreatment');
        text.textContent = languageManager ? languageManager.t('endTreatment') : 'End Treatment';
      }
    }

    // Clear end treatment data
    async function clearEndTreatmentData() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('records')
          .doc('endTreatment')
          .delete();
        
        // Reset patient status in main collection
        await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .update({
            treatmentStatus: 'active',
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
          });
        
        console.log('End treatment data cleared successfully and patient status reset to active');
      } catch (error) {
        console.error('Error clearing end treatment data:', error);
      }
    }
    
    // Update patient status in main collection
    async function updatePatientStatusInMainCollection(outcome) {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        let status = 'active';
        switch(outcome) {
          case 'birth':
            status = 'birthed';
            break;
          case 'transfer':
            status = 'transferred';
            break;
          case 'other':
            status = 'other';
            break;
        }
        
        await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .update({
            treatmentStatus: status,
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
          });
        
        console.log(`Patient status updated to: ${status}`);
      } catch (error) {
        console.error('Error updating patient status in main collection:', error);
      }
    }

    // Show end treatment modal
    function showEndTreatmentModal() {
      document.getElementById('endTreatmentModal').style.display = 'block';
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
      
      // Reset selection
      selectedEndTreatmentOption = null;
      document.querySelectorAll('.end-treatment-option').forEach(option => {
        option.classList.remove('selected');
      });
      document.getElementById('confirmEndTreatmentBtn').disabled = true;
    }

    // Close end treatment modal
    function closeEndTreatmentModal() {
      document.getElementById('endTreatmentModal').style.display = 'none';
      document.body.style.overflow = ''; // Restore scrolling
      selectedEndTreatmentOption = null;
    }

    // Select end treatment option
    function selectEndTreatmentOption(option) {
      // Remove previous selection
      document.querySelectorAll('.end-treatment-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      
      // Add selection to clicked option
      event.currentTarget.classList.add('selected');
      selectedEndTreatmentOption = option;
      
      // Enable confirm button
      document.getElementById('confirmEndTreatmentBtn').disabled = false;
    }

    // Confirm end treatment and redirect
    function confirmEndTreatment() {
      if (!selectedEndTreatmentOption) {
        alert('Please select an outcome first.');
        return;
      }

      const patientId = getPatientIdFromUrl();
      if (!patientId) {
        alert('Patient ID not found.');
        return;
      }

      // Set treatment status
      isTreatmentEnded = true;
      treatmentOutcome = selectedEndTreatmentOption;
      
      // Update button state
      updateEndTreatmentButton();
      
      // Save end treatment data to Firestore
      saveEndTreatmentData(patientId, selectedEndTreatmentOption);

      // Redirect based on selection
      switch (selectedEndTreatmentOption) {
        case 'birth':
          window.location.href = `baby.html?patient=${patientId}`;
          break;
        case 'transfer':
          window.location.href = `transfer.html?patient=${patientId}`;
          break;
        case 'other':
          window.location.href = `other-outcome.html?patient=${patientId}`;
          break;
        default:
          alert('Invalid selection.');
      }
    }

    // Save end treatment data to Firestore
    async function saveEndTreatmentData(patientId, outcome) {
      try {
        const endTreatmentData = {
          outcome: outcome,
          endTreatmentTime: new Date().toISOString(),
          endedBy: firebase.auth().currentUser?.uid || 'unknown',
          patientId: patientId,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        };

        await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('records')
          .doc('endTreatment')
          .set(endTreatmentData);

        console.log('End treatment data saved successfully');
      } catch (error) {
        console.error('Error saving end treatment data:', error);
        // Continue with redirect even if save fails
      }
    }



    // Load medication data from Firestore
    async function loadMedicationData() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        const medicationSnap = await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('medication')
          .get();
        
        medicationSnap.forEach(doc => {
          const data = doc.data();
          const time = data.time;
          
          // Store medication data in existing records
          if (data.oxytocin) {
            existing[`Medication_Oxytocin_${time}`] = data.oxytocin;
            if (data.oxytocin === "Yes") {
              existing[`Medication_Oxytocin_${time}_UL`] = data.oxytocin_UL || "";
              existing[`Medication_Oxytocin_${time}_drops`] = data.oxytocin_drops || "";
            }
          }
          
          if (data.medicine) {
            existing[`Medication_Medicine_${time}`] = data.medicine;
          }
          
          if (data.iv_fluids) {
            existing[`Medication_IV_Fluids_${time}`] = data.iv_fluids;
          }
        });
      } catch (error) {
        console.error('Error loading medication data:', error);
      }
    }

    // Show warning about data loss when starting time changes
    function showDataLossWarning() {
      // Create warning message if it doesn't exist
      let warningDiv = document.getElementById('dataLossWarning');
      if (!warningDiv) {
        warningDiv = document.createElement('div');
        warningDiv.id = 'dataLossWarning';
        warningDiv.className = 'alert alert-warning';
        warningDiv.innerHTML = `
          <i class="fas fa-exclamation-triangle"></i>
          <strong>Warning:</strong> You have changed the Active First Stage Start Time. 
          All previously saved data has been cleared because the time intervals are now different. 
          Please re-enter the patient data for the new time schedule.
        `;
        
        // Insert after the starting time requirement div
        const startingTimeRequirement = document.getElementById('startingTimeRequirement');
        if (startingTimeRequirement) {
          startingTimeRequirement.parentNode.insertBefore(warningDiv, startingTimeRequirement.nextSibling);
        }
      }
      
      // Show the warning
      warningDiv.style.display = 'block';
      
      // Auto-hide after 15 seconds (longer since it's important)
      setTimeout(() => {
        warningDiv.style.display = 'none';
      }, 15000);
    }

  </script>
</body>
</html>
