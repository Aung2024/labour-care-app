<!DOCTYPE html>
<html lang="en">
<head>
  <title>Labour Care Summary - Maternal & Child Health Care System</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
 
  
  <style>
    :root {
      --primary-color: #10b981;
      --secondary-color: #059669;
      --accent-color: #34d399;
      --light-bg: #f0fdf4;
      --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    body {
      background: var(--light-bg);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .header-section {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      padding: 1rem 0;
      margin-bottom: 1.5rem;
    }

    .language-switcher {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .language-switcher button {
      min-width: 60px;
      font-weight: 600;
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .language-switcher button:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-1px);
    }

    /* Mobile responsiveness for header */
    @media (max-width: 768px) {
      .header-section {
        padding: 0.75rem 0;
      }
      
      .header-section h1 {
        font-size: 1.25rem;
      }
      
      .language-switcher {
        gap: 0.25rem;
      }
      
      .language-switcher button {
        min-width: 50px;
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
      }
      
      .d-flex.gap-3 {
        gap: 0.75rem !important;
      }
      
      .btn-outline-light {
        font-size: 0.8rem;
        padding: 0.4rem 0.8rem;
      }
    }
    
    /* Locked input styling */
    .locked-input {
      background-color: #f8f9fa !important;
      color: #6c757d !important;
      cursor: not-allowed !important;
      border: 1px solid #dee2e6 !important;
      opacity: 0.8 !important;
    }
    
    .lock-indicator {
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      color: #6c757d;
      font-size: 12px;
      pointer-events: none;
      z-index: 10;
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid #dee2e6;
    }
    
    .form-group {
      position: relative;
    }
    
    /* Ensure form groups have relative positioning for lock indicators */
    .form-group .form-control {
      position: relative;
    }
    
    /* Locked input container styling */
    .form-group:has(.locked-input) {
      opacity: 0.9;
    }
    
    .form-group:has(.locked-input) label {
      color: #6c757d;
      font-weight: 500;
    }
    
    /* Badge styling for locked status */
    .badge.bg-secondary {
      background-color: #6c757d !important;
      color: white !important;
    }
    
    /* Hover effect for locked inputs */
    .locked-input:hover {
      background-color: #e9ecef !important;
      border-color: #ced4da !important;
    }

    .footer {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      color: #374151;
      text-align: center;
      padding: 1rem 1.5rem;
      margin-top: 2rem;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    
    .footer .container {
      padding-top: 0;
    }


  </style>
  
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
<script src="js/firebase.js"></script>
  <script src="js/status-manager.js"></script>
<script src="languages/language-manager.js"></script>
</head>
<body>
  <!-- Header Section -->
  <div class="header-section">
    <div class="container">
      <div class="row align-items-center">
        <div class="col-md-10">
          <h1 class="mb-2">
            <i class="fas fa-clipboard-list me-3"></i>
            <span data-i18n="pageSubtitle">Labour Care Summary</span>
          </h1>
  </div>
        <div class="col-md-2 text-end">
          <div class="language-switcher">
            <button class="btn btn-sm" onclick="toggleLanguage()">
              <span id="languageToggle">EN</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="main-container">
    <!-- Patient Information Card -->
    <div class="patient-card">
      <div class="card-header" onclick="togglePatientInfo()" style="cursor: pointer;">
        <h3><i class="fas fa-user-injured"></i> <span data-i18n="patientInformation">Patient Information</span></h3>
        <div class="toggle-icon">
          <i class="fas fa-chevron-down" id="toggleIcon"></i>
        </div>
      </div>
      <div class="patient-form" id="patientForm">
        <div class="form-row">
          <div class="form-group">
            <label for="p_name" data-i18n="patientName">Patient Name</label>
            <input type="text" id="p_name" class="form-control" data-i18n-placeholder="formLabels.enterPatientName" placeholder="Enter patient name">
          </div>
          <div class="form-group">
            <label for="p_age" data-i18n="age">Age</label>
            <input type="number" id="p_age" class="form-control" data-i18n-placeholder="formLabels.enterAge" placeholder="Age">
          </div>
          <div class="form-group">
            <label for="p_parity" data-i18n="parity">Parity</label>
            <input type="text" id="p_parity" class="form-control" data-i18n-placeholder="formLabels.enterParity" placeholder="Parity">
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label for="p_onset" data-i18n="labourOnset">Labour Onset</label>
            <select id="p_onset" class="form-control">
              <option value="" data-i18n="formLabels.selectOnsetType">Select onset type</option>
          <option value="Spontaneous" data-i18n="formLabels.spontaneous">Spontaneous</option>
          <option value="Induced" data-i18n="formLabels.induced">Induced</option>
        </select>
      </div>
          <div class="form-group">
            <label for="p_active" data-i18n="activeLabourDiagnosis">Active Labour Diagnosis</label>
            <input type="date" id="p_active" class="form-control">
       
    </div>
          <div class="form-group">
            <label for="p_membrane" data-i18n="rupturedMembranes">Ruptured Membranes</label>
            <input type="datetime-local" id="p_membrane" class="form-control">
            
    </div>
        </div>
        <div class="form-row">
          <div class="form-group full-width">
            <label for="p_risk" data-i18n="riskFactors">Risk Factors</label>
            <textarea id="p_risk" class="form-control" rows="2" data-i18n-placeholder="formLabels.enterRiskFactors" placeholder="Enter any risk factors"></textarea>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label for="startingTime"><strong data-i18n="activeFirstStageStartTime">Active First Stage Start Time:</strong></label>
            <input type="time" id="startingTime" class="form-control" data-i18n-placeholder="formLabels.enterTime" placeholder="08:00">
          </div>
          <div class="form-group">
            <label for="secondStageTime"><strong data-i18n="secondStageStartTime">Second Stage Start Time:</strong></label>
            <input type="time" id="secondStageTime" class="form-control" data-i18n-placeholder="formLabels.enterTime" placeholder="16:00">
          </div>
        </div>
        <div class="form-row" id="secondStageControls" style="display: none;">
          <div class="form-group full-width">
            <button type="button" class="btn btn-success" onclick="confirmSecondStage()">
              <i class="fas fa-check"></i> <span data-i18n="confirmSecondStage">Confirm Second Stage</span>
            </button>
            <small class="form-text text-muted" data-i18n="confirmSecondStageDesc">Click to confirm patient has entered second stage of labour</small>
          </div>
        </div>
      </div>
    </div>

    <!-- Starting Time Requirement Message -->
    <div class="starting-time-requirement" id="startingTimeRequirement">
      <div class="alert alert-info">
        <i class="fas fa-info-circle"></i>
        <strong data-i18n="nextStepRequired">Next Step Required:</strong> <span data-i18n="enterActiveFirstStage">Please enter the <strong>Active First Stage Start Time</strong> above to generate the labour monitoring tables.</span> 
        <span data-i18n="cervicalDilatation">This should be when the patient's cervical dilatation reached 5cm or more.</span>
      </div>
    </div>

    <!-- Second Stage Detection Section -->
    <div class="second-stage-card" id="secondStageCard" style="display: none;">
      <div class="card-header">
        <h4><i class="fas fa-baby"></i> <span data-i18n="secondStageDetection">Second Stage Detection</span></h4>
      </div>
      <div class="card-content">
        <div class="alert alert-info">
          <i class="fas fa-info-circle"></i>
          <strong data-i18n="patientEnteredSecondStage">Patient has entered Second Stage of Labour</strong>
        </div>
        <div class="second-stage-info">
          <p><strong data-i18n="activeFirstStage">Active First Stage:</strong> <span id="firstStageDuration"></span></p>
          <p><strong data-i18n="secondStageStarted">Second Stage Started:</strong> <span id="secondStageStartDisplay"></span></p>
        </div>
      </div>
    </div>

    <!-- Success Message Display -->
    <div id="successMessage" class="success-message" style="display: none;">
      <i class="fas fa-check-circle"></i>
      <span data-i18n="savedSuccessfully">Saved Successfully</span>
    </div>

    <!-- Labour Care Summary Table -->
    <div class="summary-container">
      <div class="table-header">
        <h3><i class="fas fa-clipboard-list"></i> <span data-i18n="labourCareSummary">Labour Care Summary</span></h3>
        <p class="table-subtitle" data-i18n="completeFormBelow">Complete the form below for each time interval during active labour</p>
      </div>
      
      <!-- Supportive Care Table -->
      <div class="section-table" id="supportiveCareSection">
        <div class="section-header" onclick="toggleSection('supportiveCareSection')">
          <h4><i class="fas fa-hands-helping"></i> <span data-i18n="supportiveCare">Supportive Care</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="supportiveCareToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="supportiveCareTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- FHR Table Section -->
      <div class="section-table" id="fhrSection">
        <div class="section-header" onclick="toggleSection('fhrSection')">
          <h4><i class="fas fa-heartbeat"></i> <span data-i18n="fhr">FHR</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="fhrToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="fhrTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Baby Table Section -->
      <div class="section-table" id="babySection">
        <div class="section-header" onclick="toggleSection('babySection')">
          <h4><i class="fas fa-baby"></i> <span data-i18n="baby">Baby</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="babyToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="babyTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Woman Table Section -->
      <div class="section-table" id="womanSection">
        <div class="section-header" onclick="toggleSection('womanSection')">
          <h4><i class="fas fa-female"></i> <span data-i18n="woman">Woman</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="womanToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="womanTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Contractions Section -->
      <div class="section-table" id="contractionsSection">
        <div class="section-header" onclick="toggleSection('contractionsSection')">
          <h4><i class="fas fa-utensils"></i> <span data-i18n="contractions">Contractions</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="contractionsToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="contractionsTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Cervix Plot Section -->
      <div class="section-table" id="cervixPlotSection">
        <div class="section-header" onclick="toggleSection('cervixPlotSection')">
          <h4><i class="fas fa-chart-area"></i> <span data-i18n="cervixPlot">Cervix [Plot X]</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="cervixPlotToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="cervixPlotTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Descent Plot Section -->
      <div class="section-table" id="descentPlotSection">
        <div class="section-header" onclick="toggleSection('descentPlotSection')">
          <h4><i class="fas fa-chart-line"></i> <span data-i18n="descentPlot">Descent [Plot O]</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="descentPlotToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="descentPlotTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Medication Table Section -->
      <div class="section-table" id="medicationSection">
        <div class="section-header" onclick="toggleSection('medicationSection')">
          <h4><i class="fas fa-pills"></i> <span data-i18n="medication">Medication</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="medicationToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="medicationTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Shared Decision-Making Section -->
      <div class="section-table" id="decisionMakingSection">
        <div class="section-header" onclick="toggleSection('decisionMakingSection')">
          <h4><i class="fas fa-comments"></i> <span data-i18n="sharedDecisionMaking">Shared Decision-Making</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="decisionMakingToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="decisionMakingTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>

      <!-- Initials Table Section -->
      <div class="section-table" id="initialsSection">
        <div class="section-header" onclick="toggleSection('initialsSection')">
          <h4><i class="fas fa-signature"></i> <span data-i18n="initials">Initials</span></h4>
          <div class="toggle-icon">
            <i class="fas fa-chevron-down" id="initialsToggleIcon"></i>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="summary-table" id="initialsTable">
            <!-- Table content will be generated here -->
          </table>
        </div>
      </div>
    </div>

    <!-- Clinical Recommendations Section -->
    <div class="recommendations-section">
      <h4><i class="fas fa-stethoscope"></i> <span data-i18n="clinicalRecommendations">Clinical Recommendations</span></h4>
      <div class="mb-2">
        <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearRecommendations()">
          <i class="fas fa-eraser"></i> <span data-i18n="clearRecommendations">Clear Recommendations</span>
        </button>
      </div>
      <div id="recommendations" class="recommendations-content">
        <!-- Recommendations will be populated here -->
      </div>
    </div>
  </div>


  <footer class="footer">
    <!-- Floating Action Buttons -->
    <div class="floating-actions">
      <a href="patient-care-hub.html" class="floating-btn btn-back">
        <i class="fas fa-arrow-left"></i>
        <span data-i18n="backToHub">Back to Hub</span>
      </a>
      <button class="floating-btn btn-save" onclick="saveData()">
        <i class="fas fa-save"></i>
        <span data-i18n="saveProgress">Save Progress</span>
      </button>
      <a href="summary-view.html?patient=" class="floating-btn btn-view" target="_blank" id="viewSummaryBtn" onclick="openViewSummary(event)">
        <i class="fas fa-eye"></i>
        <span data-i18n="viewSummary">View Summary</span>
      </a>
    </div>
    
    <div class="container">
      <p class="mb-0">
        <i class="fas fa-heart me-2"></i>
        © 2025 Maternal & Child Health Care System — <span data-i18n="footer">Designed for clinical excellence - Powered by Jhpiego Myanmar</span>
      </p>
    </div>
  </footer>

  <script>
    // Get patient ID from URL parameters
    function getPatientIdFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('patient');
    }

    // Date validation function for Active Labour Diagnosis and Ruptured Membranes
    function validateDates() {
      const activeDiagnosis = document.getElementById('p_active').value;
      const rupturedMembranes = document.getElementById('p_membrane').value;
      
      if (activeDiagnosis && rupturedMembranes) {
        const activeDate = new Date(activeDiagnosis);
        const ruptureDate = new Date(rupturedMembranes);
        
        // Compare only the date part (ignore time)
        const activeDateOnly = new Date(activeDate.getFullYear(), activeDate.getMonth(), activeDate.getDate());
        const ruptureDateOnly = new Date(ruptureDate.getFullYear(), ruptureDate.getMonth(), ruptureDate.getDate());
        
        if (activeDateOnly > ruptureDateOnly) {
          // Show error message
          const errorDiv = document.getElementById('dateValidationError');
          if (errorDiv) {
            errorDiv.remove();
          }
          
          const errorMessage = document.createElement('div');
          errorMessage.id = 'dateValidationError';
          errorMessage.className = 'alert alert-danger mt-2';
          errorMessage.innerHTML = '❌ Error: Active Labour Diagnosis Date must be earlier than or equal to Ruptured Membranes Date.';
          
          // Insert after the ruptured membranes field
          const membraneField = document.getElementById('p_membrane').parentElement;
          membraneField.parentNode.insertBefore(errorMessage, membraneField.nextSibling);
          
          return false;
        } else {
          // Remove error message if validation passes
          const errorDiv = document.getElementById('dateValidationError');
          if (errorDiv) {
            errorDiv.remove();
          }
        }
      }
      return true;
    }

    // Get patient ID from URL parameters
    const params = new URLSearchParams(window.location.search);
    const patientId = params.get("patient");
    
    console.log('Patient ID from URL:', patientId);



    const sections = {
      "Supportive Care": [
        "Companion",
        "Pain_Relief", 
        "Oral_fluids",
        "Mobility"
      ],
      "FHR": [
        "Baseline FHR",
        "FHR deceleration"
      ],
      "Baby": [
        "Amniotic fluid",
        "Fetal position",
        "Caput",
        "Moulding"
      ],
      "Woman": [
        "Pulse",
        "Systolic BP",
        "Diastolic BP",
        "Temperature C",
        "Urine"
      ],
      "Contractions": [
        "Contractions per 10 min",
        "Duration of contractions"
      ],
      "Labour Progress": [
        "Cervix [Plot X]",
        "Descent [Plot O]"
      ],
      "Cervix Plot": [
        "Cervix [Plot X]"
      ],
      "Descent Plot": [
        "Descent [Plot O]"
      ],
      "Medication": [
        "Oxytocin (U/L, drops/min)",
        "Medicine",
        "IV fluids"
      ],
      "Shared Decision-Making": [
        "ASSESSMENT",
        "PLAN",
        "INITIALS"
      ]
    };

    const dropdownOptions = {
      // Supportive care
      "Companion": ["Y", "N", "D"],
      "Pain_Relief": ["Y", "N", "D"],
      "Oral_fluids": ["Y", "N", "D"],
      "Mobility": ["M", "SP"],

      // Baby
      "FHR deceleration": ["N", "E", "L", "V"],
      "Amniotic fluid": ["I", "C", "M", "M+", "M++", "M+++", "B"],
      "Fetal position": ["A", "P", "T"],
      "Caput": ["0", "+", "++", "+++"],
      "Moulding": ["0", "+", "++", "+++"],

      // Woman
      "Pulse": ["<60", "60-120", ">120"],
      "Systolic BP": ["<90", "90-140", ">140"],
      "Diastolic BP": ["<60", "60-90", ">90"],
      "Temperature C": ["<36", "36-37.5", ">37.5"],
      "Urine": ["-/-", "P-", "P Trace", "P+", "P++", "A-", "A Trace", "A+", "A++"],

      // Labour Progress
      "Contractions per 10 min": ["<2", "2-5", ">5"],
      "Duration of contractions": ["<20s", "20-50s", ">50s"],
      "Cervix [Plot X]": ["", "X"],
      "Descent [Plot O]": ["", "O"],

      // Medication
      "Oxytocin (U/L, drops/min)": ["None", "Started", "Stopped"],
      "Medicine": ["None", "Started", "Stopped"],
      "IV fluids": ["None", "Started", "Stopped"]
    };

    const alertValues = {
      // Supportive care - WHO LCG values
      "Companion": ["N"], // N = No companion
      "Pain_Relief": ["N"], // N = No pain relief
      "Oral_fluids": ["N"], // N = No oral fluid
      "Mobility": ["SP"], // SP = Supine position

      // Baby - WHO LCG values
      "Baseline FHR": [], // Will be handled by number input range checking
      "FHR deceleration": ["L"], // L = Late decelerations
      "Amniotic fluid": ["M+++", "B"], // M+++ = Severe meconium, B = Bloody
      "Fetal position": ["P", "T"], // P = Posterior, T = Transverse
      "Caput": ["+++"], // +++ = Severe caput
      "Moulding": ["+++"], // +++ = Severe moulding

      // Woman - WHO LCG values
      "Pulse": [], // Will be handled by number input range checking
      "Systolic BP": [], // Will be handled by number input range checking
      "Diastolic BP": [], // Will be handled by number input range checking
      "Temperature C": [], // Will be handled by number input range checking
      "Urine": [], // Will be handled by dropdown selection

      // Contractions - WHO LCG values
      "Contractions per 10 min": [], // Will be handled by number input range checking
      "Duration of contractions": [] // Will be handled by number input range checking
    };

    // WHO Alert Values for display in alert cells
    const whoAlertValues = {
      // Supportive care
      "Companion": "N",
      "Pain_Relief": "N", 
      "Oral_fluids": "N",
      "Mobility": "SP",

      // Baby
      "Baseline FHR": "<110, ≥160",
      "FHR deceleration": "L",
      "Amniotic fluid": "M+++, B",
      "Fetal position": "P, T",
      "Caput": "+++",
      "Moulding": "+++",

      // Woman
      "Pulse": "<60, ≥120",
      "Systolic BP": "<80, ≥140",
      "Diastolic BP": "≥90",
      "Temperature C": "<35.0, ≥37.5",
      "Urine": "P++, A++",

      // Contractions
      "Contractions per 10 min": "≤2, >5",
      "Duration of contractions": "<20, >60"
    };

    // Check if a cervix plot value should be highlighted as an alert based on time thresholds
    function checkCervixPlotAlert(cervixValue, timeValue, timeKey) {
      if (!timeValue || timeValue !== 'X') return false;
      
      // Define time thresholds for each cervix value (in hours)
      const timeThresholds = {
        '10': 0,    // No threshold for 10cm
        '9': 2,     // ≥ 2h
        '8': 2.5,   // ≥ 2.5h  
        '7': 3,     // ≥ 3h
        '6': 5,     // ≥ 5h
        '5': 6      // ≥ 6h
      };
      
      const thresholdHours = timeThresholds[cervixValue];
      if (!thresholdHours) return false; // No threshold for this cervix value
      
      // Get the current time from the timeKey (format: "HH_MM")
      const [hours, minutes] = timeKey.split('_').map(Number);
      const currentTime = hours * 60 + minutes; // Convert to minutes
      
      // Get the active first stage start time
      if (!activeFirstStageStartTime) return false;
      const [startHours, startMinutes] = activeFirstStageStartTime.split(':').map(Number);
      const startTime = startHours * 60 + startMinutes; // Convert to minutes
      
      // Calculate elapsed time in hours
      let elapsedHours = (currentTime - startTime) / 60;
      
      // Handle midnight crossing
      if (elapsedHours < 0) {
        elapsedHours += 24;
      }
      
      // Check if elapsed time exceeds threshold
      return elapsedHours >= thresholdHours;
    }

    // Check and highlight alert values
    function checkAndHighlightAlert(element) {
      const fieldName = element.name;
      const value = element.value;
      
      console.log('checkAndHighlightAlert called for:', fieldName, 'value:', value);
      
      // Remove existing alert highlighting
      element.classList.remove('alert-value');
      
      // Check if this field has alert values defined
      if (alertValues[fieldName] && alertValues[fieldName].length > 0) {
        // Check if current value matches any alert value
        if (alertValues[fieldName].includes(value)) {
          element.classList.add('alert-value');
        }
      }
      
      // Special handling for number inputs (Baseline FHR, Pulse, BP, Temperature)
      if (element.type === 'number') {
        const numValue = parseFloat(value);
        if (!isNaN(numValue)) {
          switch(fieldName) {
            case 'Baseline FHR':
              if (numValue < 110 || numValue >= 160) {
                element.classList.add('alert-value');
              }
              break;
            case 'Pulse':
              if (numValue < 60 || numValue >= 120) {
                element.classList.add('alert-value');
              }
              break;
            case 'Systolic BP':
              if (numValue < 80 || numValue >= 140) {
                element.classList.add('alert-value');
              }
              break;
            case 'Diastolic BP':
              if (numValue >= 90) {
                element.classList.add('alert-value');
              }
              break;
            case 'Temperature C':
              if (numValue < 35.0 || numValue >= 37.5) {
                element.classList.add('alert-value');
              }
              break;
            default:
                      // Check for contractions fields by name pattern
        if (fieldName.includes('Contractions_per_10_min')) {
          if (numValue <= 2 || numValue > 5) {
            element.classList.add('alert-value');
            console.log('Alert added for Contractions per 10 min:', numValue);
          }
        } else if (fieldName.includes('Duration_of_contractions')) {
          if (numValue < 20 || numValue > 60) {
            element.classList.add('alert-value');
            console.log('Alert added for Duration of contractions:', numValue);
          }
        }
              break;
          }
        }
      }
    }

    // Add event listeners to form elements
    function addFormEventListeners() {
      console.log('addFormEventListeners() called');
      
      // Add event listeners to all selects and inputs
      const allSelects = document.querySelectorAll('select');
      const allInputs = document.querySelectorAll('input');
      
      console.log('Found selects:', allSelects.length, 'inputs:', allInputs.length);
      
      allSelects.forEach(select => {
        select.addEventListener('change', function() {
          console.log('Select changed:', this.name, 'value:', this.value);
          checkAndHighlightAlert(this);
          // Recommendations will be shown when needed, not on every change
        });
      });
      
      allInputs.forEach(input => {
        input.addEventListener('input', function() {
          console.log('Input changed:', this.name, 'value:', this.value);
          checkAndHighlightAlert(this);
          // Recommendations will be shown when needed, not on every change
        });
        input.addEventListener('change', function() {
          console.log('Input changed (change event):', this.name, 'value:', this.value);
          checkAndHighlightAlert(this);
          // Recommendations will be shown when needed, not on every change
        });
      });
      
      console.log('Event listeners added successfully');
    }

    // Test function to manually trigger recommendations
    function testRecommendations() {
      console.log('🧪 Testing recommendations function...');
      
      // Check if recommendations div exists
      const recommendationsDiv = document.getElementById('recommendations');
      console.log('Recommendations div found:', recommendationsDiv);
      
      // Check if there are any form elements
      const allInputs = document.querySelectorAll('input, select');
      console.log('Total form elements found:', allInputs.length);
      
      // Check if there are any values in the form
      const inputsWithValues = Array.from(allInputs).filter(input => input.value && input.value.trim() !== '');
      console.log('Form elements with values:', inputsWithValues.length);
      inputsWithValues.forEach(input => {
        console.log('Input with value:', input.name, '=', input.value);
      });
      
      // Clear previous recommendations and tracking before testing
      shownRecommendations.clear();
      isProcessingRecommendations = false;
      lastRecommendationsCall = 0; // Reset debounce timer
      console.log('🔄 Reset recommendations tracking for testing');
      showRecommendations();
    }
    
    // Test function to debug hybrid time columns
    function testHybridTimeColumns() {
      console.log('🧪 Testing hybrid time columns...');
      console.log('Current state:');
      console.log(`  activeFirstStageStartTime: ${activeFirstStageStartTime}`);
      console.log(`  secondStageStartTime: ${secondStageStartTime}`);
      console.log(`  isSecondStageActive: ${isSecondStageActive}`);
      
      console.log('Before generateHybridTimeColumns():');
      console.log(`  contractionsTimeCols: ${contractionsTimeCols.length} columns:`, contractionsTimeCols);
      console.log(`  babyBaselineTimeCols: ${babyBaselineTimeCols.length} columns:`, babyBaselineTimeCols);
      
      // Generate hybrid time columns
      generateHybridTimeColumns();
      
      console.log('After generateHybridTimeColumns():');
      console.log(`  contractionsTimeCols: ${contractionsTimeCols.length} columns:`, contractionsTimeCols);
      console.log(`  babyBaselineTimeCols: ${babyBaselineTimeCols.length} columns:`, babyBaselineTimeCols);
      
      // Test isSecondStageTime function
      if (secondStageStartTime && isSecondStageActive) {
        console.log('Testing isSecondStageTime function:');
        contractionsTimeCols.forEach(time => {
          const isSecondStage = isSecondStageTime(time);
          console.log(`  ${time}: ${isSecondStage ? '🟢 Second Stage' : '🔵 First Stage'}`);
        });
      }
    }
    
    // Force hybrid generation for testing
    function forceHybridGeneration() {
      console.log('🔧 Force hybrid generation called');
      
      if (!activeFirstStageStartTime) {
        console.log('❌ No Active First Stage Start Time - cannot force hybrid generation');
        return;
      }
      
      if (!secondStageStartTime) {
        console.log('❌ No Second Stage Start Time - cannot force hybrid generation');
        return;
      }
      
      // Force second stage to be active
      isSecondStageActive = true;
      
      console.log('🔄 Forcing hybrid time column generation...');
      generateHybridTimeColumns();
      
      console.log('🔄 Regenerating tables with preserved data...');
      
      // Get existing data from the current form
      const existingData = {};
      const allInputs = document.querySelectorAll('input, select');
      allInputs.forEach(input => {
        if (input.name && input.value) {
          existingData[input.name] = input.value;
        }
      });
      
      console.log('📊 Preserving existing data:', Object.keys(existingData).length, 'fields');
      
      // Regenerate the full summary table with hybrid time columns and existing data
      generateSummaryTable(existingData);
      
      console.log('🎨 Updating colors...');
      updateSecondStageColors();
      
      console.log('✅ Force hybrid generation completed');
    }
    
    // Function to clear recommendations and reset tracking
    function clearRecommendations() {
      const recommendationsDiv = document.getElementById('recommendations');
      if (recommendationsDiv) {
        recommendationsDiv.innerHTML = '';
        shownRecommendations.clear();
        isProcessingRecommendations = false;
        lastRecommendationsCall = 0; // Reset debounce timer
        console.log('✅ Recommendations cleared and tracking reset');
      }
    }

    // Global variable to track already shown recommendations
    let shownRecommendations = new Set();
    let isProcessingRecommendations = false; // Prevent multiple simultaneous calls
    let lastRecommendationsCall = 0; // Track when recommendations were last called
    
    // Show clinical recommendations based on alert values
    // OLD COMPLEX FUNCTION - COMMENTED OUT TO PREVENT DUPLICATES
    /*
    function showRecommendations() {
      console.log('=== showRecommendations() called ===');
      
      // Debounce: prevent multiple calls within 500ms
      const now = Date.now();
      if (now - lastRecommendationsCall < 500) {
        console.log('⏭️ Skipping recommendations call - too soon after last call');
        return;
      }
      lastRecommendationsCall = now;
      
      // Prevent multiple simultaneous calls
      if (isProcessingRecommendations) {
        console.log('⏳ Already processing recommendations, skipping...');
        return;
      }
      
      isProcessingRecommendations = true;
      
      const recommendationsDiv = document.getElementById('recommendations');
      if (!recommendationsDiv) {
        console.log('❌ Recommendations div not found yet');
        isProcessingRecommendations = false;
        return;
      }
      
      console.log('✅ Found recommendations div, checking for alerts...');
      console.log('Recommendations div content before:', recommendationsDiv.innerHTML);
      
      // Clear recommendations tracking for fresh start
      // This ensures we always process alerts from scratch
      shownRecommendations.clear();
      console.log('🔄 Cleared recommendations tracking for fresh start');
      
      const activeAlerts = new Set();
      
      // Check all form elements for alert values
      const allInputs = document.querySelectorAll('input, select');
      console.log('Found form elements:', allInputs.length);
      
      // Debug: Show all form element names
      const allFieldNames = Array.from(allInputs).map(input => input.name);
      console.log('All field names:', allFieldNames);
      
      allInputs.forEach(input => {
        if (input.value && input.value.trim() !== '') {
          const fieldName = input.name;
          const value = input.value;
          console.log('Checking field:', fieldName, 'with value:', value);
          
          // Check if this value should trigger an alert
          let shouldAlert = false;
          let alertReason = '';
          
          // Check against WHO LCG alert values
          if (fieldName.includes('Baseline_FHR')) {
            const fhr = parseInt(value);
            if (!isNaN(fhr) && (fhr < 110 || fhr >= 160)) {
              shouldAlert = true;
              alertReason = `FHR ${fhr} is outside normal range (<110, ≥160)`;
            }
          } else if (fieldName.includes('Pulse')) {
            const pulse = parseInt(value);
            if (!isNaN(pulse) && (pulse < 60 || pulse >= 120)) {
              shouldAlert = true;
              alertReason = `Pulse ${pulse} is outside normal range (<60, ≥120)`;
            }
          } else if (fieldName.includes('Systolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && (bp < 80 || bp >= 140)) {
              shouldAlert = true;
              alertReason = `Systolic BP ${bp} is outside normal range (<80, ≥140)`;
            }
          } else if (fieldName.includes('Diastolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && bp >= 90) {
              shouldAlert = true;
              alertReason = `Diastolic BP ${bp} is above normal range (≥90)`;
            }
          } else if (fieldName.includes('Temperature_C')) {
            const temp = parseFloat(value);
            if (!isNaN(temp) && (temp < 35.0 || temp >= 37.5)) {
              shouldAlert = true;
              alertReason = `Temperature ${temp}°C is outside normal range (<35.0, ≥37.5)`;
            }
          } else if (fieldName.includes('Pain_Relief') && value === 'N') {
            shouldAlert = true;
            alertReason = 'No pain relief provided';
          } else if (fieldName.includes('Oral_fluids') && value === 'N') {
            shouldAlert = true;
            alertReason = 'No oral fluids provided';
          } else if (fieldName.includes('Mobility') && value === 'SP') {
            shouldAlert = true;
            alertReason = 'Patient in supine position - encourage mobility';
          } else if (fieldName.includes('FHR_deceleration') && value === 'L') {
            shouldAlert = true;
            alertReason = 'Late FHR decelerations detected - assess fetal condition';
          } else if (fieldName.includes('Amniotic_fluid') && (value === 'M+++' || value === 'B')) {
            shouldAlert = true;
            alertReason = `Amniotic fluid: ${value} - monitor for fetal distress`;
          } else if (fieldName.includes('Fetal_position') && (value === 'P' || value === 'T')) {
            shouldAlert = true;
            alertReason = `Fetal position: ${value} - monitor labour progress`;
          } else if (fieldName.includes('Caput') && value === '+++') {
            shouldAlert = true;
            alertReason = 'Severe caput detected - monitor for obstructed labour';
          } else if (fieldName.includes('Moulding') && value === '+++') {
            shouldAlert = true;
            alertReason = 'Severe moulding detected - monitor for obstructed labour';
          } else if (fieldName.includes('Contractions_per_10_min')) {
            const contractions = parseInt(value);
            if (!isNaN(contractions) && (contractions < 2 || contractions > 5)) {
              shouldAlert = true;
              alertReason = `Contractions: ${contractions} per 10 min - outside normal range (2-5)`;
            }
          } else if (fieldName.includes('Duration_of_contractions')) {
            const duration = parseInt(value);
            if (!isNaN(duration) && (duration < 20 || duration > 50)) {
              shouldAlert = true;
              alertReason = `Contraction duration: ${duration}s - outside normal range (20-50s)`;
            }
          }
          
          if (shouldAlert) {
            // Extract field name for display (remove time suffix)
            const displayName = fieldName.split('_').slice(0, -2).join(' ').replace(/_/g, ' ');
            const alertKey = `${displayName}: ${alertReason}`;
            
            // Only add if this exact alert hasn't been shown before
            if (!shownRecommendations.has(alertKey)) {
              activeAlerts.add(alertKey);
              shownRecommendations.add(alertKey);
              console.log('✅ New alert added:', alertKey);
            } else {
              console.log('⏭️ Alert already shown, skipping duplicate:', alertKey);
            }
          }
        }
      });
      
      // Generate recommendations HTML
      console.log('📊 Summary:');
      console.log(`  - Total form elements checked: ${allInputs.length}`);
      console.log(`  - Unique alerts found: ${activeAlerts.size}`);
      console.log(`  - Recommendations tracking size: ${shownRecommendations.size}`);
      
      if (activeAlerts.size > 0) {
        let recommendationsHTML = '';
        
        // Add clinical recommendations
        recommendationsHTML += '<div class="alert alert-info"><strong>🏥 Clinical Recommendations:</strong><ul>';
        activeAlerts.forEach(alert => {
          const [field, reason] = alert.split(': ');
          
          // Provide specific recommendations based on field type
          let recommendation = '';
          if (field.includes('FHR') || field.includes('Baseline')) {
            recommendation = 'Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring if pattern persists.';
          } else if (field.includes('Pulse')) {
            recommendation = 'Monitor maternal pulse. Check for underlying causes and consider cardiovascular assessment.';
          } else if (field.includes('BP')) {
            recommendation = 'Monitor blood pressure closely. Consider antihypertensive therapy if severe hypertension.';
          } else if (field.includes('Temperature')) {
            recommendation = 'Monitor for signs of infection. Consider antibiotics if infection suspected.';
          } else if (field.includes('Pain') || field.includes('Mobility') || field.includes('Oral')) {
            recommendation = 'Review supportive care measures. Ensure adequate pain relief, mobility, and hydration.';
          } else {
            recommendation = 'Monitor and document progress. Consider specialist consultation if needed.';
          }
          
          recommendationsHTML += `<li><strong>${field}:</strong> ${recommendation}</li>`;
        });
        recommendationsHTML += '</ul></div>';
        
        recommendationsDiv.innerHTML = recommendationsHTML;
        console.log('✅ Recommendations HTML set with alerts');
        console.log('Final HTML content:', recommendationsHTML);
      } else {
        recommendationsDiv.innerHTML = '<div class="alert alert-success">✅ No active alerts. All parameters within normal ranges.</div>';
        console.log('✅ Recommendations HTML set with no alerts message');
      }
      
      console.log('Final recommendations div content:', recommendationsDiv.innerHTML);
      console.log('=== showRecommendations() completed ===');
      
      // Reset processing flag
      isProcessingRecommendations = false;
    }
    */
    
    // NEW SIMPLE FUNCTION - NO DUPLICATES
    function showRecommendations() {
      console.log('=== showRecommendations() called ===');
      
      const recommendationsDiv = document.getElementById('recommendations');
      if (!recommendationsDiv) {
        console.log('❌ Recommendations div not found yet');
        return;
      }
      
      console.log('✅ Found recommendations div, checking for alerts...');
      
      // Use a Map to track unique alerts by field type (not by individual values)
      const alertMap = new Map();
      
      // Check all form elements for alert values
      const allInputs = document.querySelectorAll('input, select');
      console.log('Found form elements:', allInputs.length);
      
      allInputs.forEach(input => {
        if (input.value && input.value.trim() !== '') {
          const fieldName = input.name;
          const value = input.value;
          
          // Check if this value should trigger an alert
          let shouldAlert = false;
          let alertType = '';
          
          // Check against WHO LCG alert values
          if (fieldName.includes('Baseline_FHR')) {
            const fhr = parseInt(value);
            if (!isNaN(fhr) && (fhr < 110 || fhr >= 160)) {
              shouldAlert = true;
              alertType = 'FHR';
            }
          } else if (fieldName.includes('Pulse')) {
            const pulse = parseInt(value);
            if (!isNaN(pulse) && (pulse < 60 || pulse >= 120)) {
              shouldAlert = true;
              alertType = 'Pulse';
            }
          } else if (fieldName.includes('Systolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && (bp < 80 || bp >= 140)) {
              shouldAlert = true;
              alertType = 'Systolic BP';
            }
          } else if (fieldName.includes('Diastolic_BP')) {
            const bp = parseInt(value);
            if (!isNaN(bp) && bp >= 90) {
              shouldAlert = true;
              alertType = 'Diastolic BP';
            }
          } else if (fieldName.includes('Temperature_C')) {
            const temp = parseFloat(value);
            if (!isNaN(temp) && (temp < 35.0 || temp >= 37.5)) {
              shouldAlert = true;
              alertType = 'Temperature C';
            }
          } else if (fieldName.includes('Pain_Relief') && value === 'N') {
            shouldAlert = true;
            alertType = 'Pain Relief';
          } else if (fieldName.includes('Mobility') && value === 'SP') {
            shouldAlert = true;
            alertType = 'Mobility';
          } else if (fieldName.includes('FHR_deceleration') && (value === 'L' || value === 'V' || value === 'E')) {
            shouldAlert = true;
            alertType = 'FHR deceleration';
          } else if (fieldName.includes('Contractions_per_10_min')) {
            const contractions = parseInt(value);
            if (!isNaN(contractions) && (contractions < 2 || contractions > 5)) {
              shouldAlert = true;
              alertType = 'Contractions per 10 min';
            }
          } else if (fieldName.includes('Duration_of_contractions')) {
            const duration = parseInt(value);
            if (!isNaN(duration) && (duration < 20 || duration > 50)) {
              shouldAlert = true;
              alertType = 'Duration of contractions';
            }
          }
          
          if (shouldAlert) {
            // Store alert by type, not by individual field values
            alertMap.set(alertType, true);
          }
        }
      });
      
      // Generate recommendations HTML
      console.log(`📊 Unique alert types found: ${alertMap.size}`);
      
      if (alertMap.size > 0) {
        // Create recommendations HTML
        let recommendationsHTML = '<div class="alert alert-info"><strong>🏥 Clinical Recommendations:</strong><ul>';
        
        // Convert Map keys to Array and sort for consistent display
        const sortedAlertTypes = Array.from(alertMap.keys()).sort();
        
        sortedAlertTypes.forEach(alertType => {
          let recommendation = '';
          let translatedAlertType = alertType;
          
          // Translate alert type using languageManager if available
          if (typeof languageManager !== 'undefined' && languageManager.t) {
            translatedAlertType = languageManager.t(alertType, alertType);
          }
          
          // Generate specific recommendations based on alert type
          switch (alertType) {
            case 'Pain Relief':
              recommendation = languageManager && languageManager.t ? languageManager.t('recommendations.supportiveCareRecommendation', 'Review supportive care measures. Ensure adequate pain relief, mobility, and hydration.') : 'Review supportive care measures. Ensure adequate pain relief, mobility, and hydration.';
              break;
            case 'Mobility':
              recommendation = languageManager && languageManager.t ? languageManager.t('recommendations.supportiveCareRecommendation', 'Review supportive care measures. Ensure adequate pain relief, mobility, and hydration.') : 'Review supportive care measures. Ensure adequate pain relief, mobility, and hydration.';
              break;
            case 'FHR deceleration':
              recommendation = languageManager && languageManager.t ? languageManager.t('recommendations.fhrRecommendation', 'Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring if pattern persists.') : 'Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring if pattern persists.';
              break;
            case 'FHR':
              recommendation = languageManager && languageManager.t ? languageManager.t('recommendations.fhrRecommendation', 'Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring if pattern persists.') : 'Monitor fetal heart rate closely. Consider fetal assessment and continuous monitoring if pattern persists.';
              break;
            case 'Pulse':
              recommendation = languageManager && languageManager.t ? languageManager.t('recommendations.pulseRecommendation', 'Monitor maternal pulse. Check for underlying causes and consider cardiovascular assessment.') : 'Monitor maternal pulse. Check for underlying causes and consider cardiovascular assessment.';
              break;
            case 'Systolic BP':
            case 'Diastolic BP':
              recommendation = languageManager && languageManager.t ? languageManager.t('recommendations.bpRecommendation', 'Monitor blood pressure closely. Consider antihypertensive therapy if severe hypertension.') : 'Monitor blood pressure closely. Consider antihypertensive therapy if severe hypertension.';
              break;
            case 'Temperature C':
              recommendation = languageManager && languageManager.t ? languageManager.t('recommendations.temperatureRecommendation', 'Monitor for signs of infection. Consider antibiotics if infection suspected.') : 'Monitor for signs of infection. Consider antibiotics if infection suspected.';
              break;
            case 'Contractions per 10 min':
            case 'Duration of contractions':
              recommendation = languageManager && languageManager.t ? languageManager.t('recommendations.generalRecommendation', 'Monitor and document progress. Consider specialist consultation if needed.') : 'Monitor and document progress. Consider specialist consultation if needed.';
              break;
            default:
              recommendation = languageManager && languageManager.t ? languageManager.t('recommendations.generalRecommendation', 'Monitor closely and document findings. Consider specialist consultation if needed.') : 'Monitor closely and document findings. Consider specialist consultation if needed.';
          }
          
          recommendationsHTML += `<li><strong>${translatedAlertType}:</strong> ${recommendation}</li>`;
        });
        
        recommendationsHTML += '</ul></div>';
        
        recommendationsDiv.innerHTML = recommendationsHTML;
        console.log('✅ Recommendations HTML set with alerts');
      } else {
        // No alerts found
        recommendationsDiv.innerHTML = '<div class="alert alert-success">✅ No active alerts. All parameters within normal ranges.</div>';
        console.log('✅ Recommendations HTML set with no alerts message');
      }
      
      console.log('=== showRecommendations() completed ===');
    }

    // REMOVED: Old recommendations object that was causing duplicates
    // The new showRecommendations() function handles all recommendations dynamically

    // Load data from Firestore
    async function loadData() {
      try {
        console.log('loadData called');
        
        // Get current user and their Firestore profile
        const user = firebase.auth().currentUser;
        if (!user) {
          document.body.innerHTML = '<div class="alert alert-danger">Not authenticated.</div>';
          return;
        }
          
        // Fetch user profile
        const userDoc = await firebase.firestore().collection("users").doc(user.uid).get();
        if (!userDoc.exists) {
          document.body.innerHTML = '<div class="alert alert-danger">User profile not found.</div>';
          return;
        }
        const userData = userDoc.data();

        // Get patient document
        const patientIdFromUrl = getPatientIdFromUrl();
        console.log('Patient ID from getPatientIdFromUrl():', patientIdFromUrl);
        
        if (!patientIdFromUrl) {
          document.body.innerHTML = '<div class="alert alert-danger">Patient ID not found.</div>';
          return;
        }

        const patientDoc = await firebase.firestore().collection("patients").doc(patientIdFromUrl).get({ source: "server" });
        if (!patientDoc.exists) {
          document.body.innerHTML = '<div class="alert alert-danger">Patient not found.</div>';
          return;
        }
        const d = patientDoc.data();

        // Initialize existing data variable
        let existing = {};

        // Access control: Super Admin always allowed, TMO if township matches, Midwife if createdBy matches
        let allowed = false;
          
        if (userData.role === "Super Admin" || userData.role === "admin") {
          allowed = true;
        } else if (userData.role === "TMO") {
          // TMO can access if township matches (handle cases where township might be undefined)
          const patientTownship = d.township || "";
          const userTownship = userData.township || "";
          if (patientTownship && userTownship && patientTownship === userTownship) {
            allowed = true;
          }
        } else if (userData.role === "Midwife" || userData.role === "midwife") {
          // Midwife can access if they created the patient
          // Check both field names for compatibility
          if (d.created_by === user.uid || d.createdBy === user.uid) {
            allowed = true;
          }
        }

        if (!allowed) {
          // Better error message based on role
          let errorMessage = "";
          if (userData.role === "TMO") {
            errorMessage = `Access Denied: You can only access patients in your township (${userData.township || 'undefined'}). This patient is in township: ${d.township || 'undefined'}.`;
          } else if (userData.role === "Midwife" || userData.role === "midwife") {
            errorMessage = `Access Denied: You can only access patients you created. This patient was created by: ${d.created_by || d.createdBy || 'unknown'}.`;
          } else {
            errorMessage = `Access Denied: You do not have permission to view this patient record. Please contact your administrator.`;
          }
          
          document.body.innerHTML = `
            <div class="alert alert-danger">
              <h4>Access Denied</h4>
              <p><strong>Reason:</strong> ${errorMessage}</p>
              <hr>
              <a href="list.html" class="btn btn-primary">← Back to Patient List</a>
            </div>
          `;
          return;
        }

        // Populate patient info
        console.log('Loading patient data:', d);
        console.log('Parity value:', d.parity);
        console.log('Risk factors value:', d.risk_factors);
        
        document.getElementById("p_name").value = d.name || "";
        document.getElementById("p_age").value = d.age || "";
        document.getElementById("p_parity").value = d.parity || "";
        document.getElementById("p_onset").value = d.labour_onset || "";
        document.getElementById("p_active").value = d.active_labour || "";
        document.getElementById("p_membrane").value = d.ruptured_membrane || "";
        document.getElementById("p_risk").value = d.risk_factors || "";
        
        console.log('Fields populated - Parity:', document.getElementById("p_parity").value);
        console.log('Fields populated - Risk Factors:', document.getElementById("p_risk").value);

        // Load starting time and second stage data
        try {
          const startingTimeDoc = await firebase.firestore().collection("patients").doc(patientIdFromUrl).collection("records").doc("startingTime").get();
          if (startingTimeDoc.exists) {
            const startingData = startingTimeDoc.data();
            const savedStartingTime = startingData.startingTime;
            
            // Only set activeFirstStageStartTime if there's actually a saved value
            if (savedStartingTime && savedStartingTime.trim() !== '') {
              activeFirstStageStartTime = savedStartingTime;
              document.getElementById("startingTime").value = activeFirstStageStartTime;
              
              // Generate dynamic time columns based on starting time
              generateDynamicTimeColumns();
              
              // Load existing records from the new structure
              const recordsDoc = await firebase.firestore()
                .collection("patients")
                .doc(patientIdFromUrl)
                .collection("records")
                .doc("summary")
                .get();
              
              if (recordsDoc.exists) {
                const savedData = recordsDoc.data();
                const savedStartingTimeFromSummary = savedData.startingTime;
                
                // Only load data if the starting time matches (preserves data when starting time hasn't changed)
                if (savedStartingTimeFromSummary === activeFirstStageStartTime) {
                  existing = savedData;
                  console.log('Loading existing data with matching starting time:', savedStartingTimeFromSummary);
                } else {
                  console.log('Starting time changed, not loading old data. Old:', savedStartingTimeFromSummary, 'New:', activeFirstStageStartTime);
                  // Data will be cleared since starting time changed
                }
              }

              // Load medication data
              const medicationSnap = await firebase.firestore().collection("patients").doc(patientIdFromUrl).collection("medication").get({ source: "server" });
              medicationSnap.forEach(doc => {
                const d = doc.data();
                const time = d.time;
                
                // Store oxytocin data
                if (d.oxytocin) {
                  existing[`Medication_Oxytocin_${time}`] = d.oxytocin;
                  if (d.oxytocin === "Yes") {
                    existing[`Medication_Oxytocin_${time}_UL`] = d.oxytocin_UL || "";
                    existing[`Medication_Oxytocin_${time}_drops`] = d.oxytocin_drops || "";
                  }
                }
                
                // Store medicine data
                if (d.medicine) {
                  existing[`Medication_Medicine_${time}`] = d.medicine;
                  if (d.medicine === "Y" || d.medicine === "Yes") {
                    existing[`Medication_Medicine_${time}_name`] = d.medicine_name || "";
                    existing[`Medication_Medicine_${time}_dosage`] = d.medicine_dosage || "";
                    existing[`Medication_Medicine_${time}_route`] = d.medicine_route || "";
                    existing[`Medication_Medicine_${time}_frequency`] = d.medicine_frequency || "";
                  }
                }
                
                // Store IV fluids data
                if (d.iv_fluids) {
                  existing[`Medication_IV_Fluids_${time}`] = d.iv_fluids;
                }
              });

              // If starting time exists, show all tables with data
              showAllTables();
              document.getElementById("startingTimeRequirement").style.display = "none";
              
              // Generate the summary table with existing data
              generateSummaryTable(existing);
              
              // Setup alert highlighting for real-time alerts
              addAlertHighlighting();
              
              // Add event listeners for form changes
              document.querySelectorAll('select, input').forEach(el => {
                el.addEventListener('change', function() {
                  checkAndHighlightAlert(this);
                  // Recommendations will be shown when needed, not on every change
                });
              });
              
              // Lock time inputs if they already have values
              checkAndLockTimeInputs();
              
              // Log lock status for debugging
              setTimeout(() => {
                logLockStatus();
              }, 500);
              
            } else {
              // No starting time set, hide all tables and show requirement
              hideAllTables();
              showStartingTimeRequirement();
            }
          
          console.log('🔄 Loading second stage data...');
          
          const secondStageDoc = await firebase.firestore().collection("patients").doc(patientIdFromUrl).collection("records").doc("secondStage").get();
          if (secondStageDoc.exists) {
            const secondStageData = secondStageDoc.data();
            secondStageStartTime = secondStageData.secondStageStartTime;
            isSecondStageActive = secondStageData.isSecondStageActive;
            
            console.log(`  Found second stage data: ${secondStageStartTime}, active: ${isSecondStageActive}`);
            
            if (isSecondStageActive) {
              document.getElementById("secondStageTime").value = secondStageStartTime;
              document.getElementById("secondStageCard").style.display = "block";
              
              // Calculate and display first stage duration
              if (activeFirstStageStartTime && secondStageStartTime) {
                const firstTime = new Date(`2000-01-01T${activeFirstStageStartTime}:00`);
                const secondTime = new Date(`2000-01-01T${secondStageStartTime}:00`);
                const firstStageDuration = Math.round((secondTime - firstTime) / (1000 * 60));
                document.getElementById("firstStageDuration").textContent = `${firstStageDuration} minutes`;
                document.getElementById("secondStageStartDisplay").textContent = secondStageStartTime;
              }
              
              console.log('🔄 Generating hybrid time columns for existing second stage...');
              
              // Generate hybrid time columns for second stage
              generateHybridTimeColumns();
              
              console.log('🔄 Hybrid time columns generated for existing second stage...');
              
              // Note: Tables will be generated in the main flow below
            } else {
              console.log('  Second stage not active');
            }
          } else {
            console.log('  No second stage data found');
          }
        } // Close the if (startingTimeDoc.exists) block
        } catch (error) {
          console.error("Error loading time data:", error);
          // On error, hide all tables and show requirement
          hideAllTables();
          showStartingTimeRequirement();
        }

        // Generate dynamic time columns FIRST (this will be the base)
        // BUT if second stage is active, generate hybrid time columns first
        if (secondStageStartTime && isSecondStageActive) {
          console.log('🔄 Second stage active - generating hybrid time columns first...');
          generateHybridTimeColumns();
        } else {
          console.log('🔄 First stage - generating dynamic time columns...');
          generateDynamicTimeColumns();
        }

        // Event listener for starting time changes is already added below in the try-catch block

        // Load existing records from the new structure
        const recordsDoc = await firebase.firestore()
          .collection("patients")
          .doc(patientIdFromUrl)
          .collection("records")
          .doc("summary")
          .get();
        
        if (recordsDoc.exists) {
          const savedData = recordsDoc.data();
          const savedStartingTime = savedData.startingTime;
          
          // Only load data if the starting time matches (preserves data when starting time hasn't changed)
          if (savedStartingTime === activeFirstStageStartTime) {
            existing = savedData;
            console.log('Loading existing data with matching starting time:', savedStartingTime);
          } else {
            console.log('Starting time changed, not loading old data. Old:', savedStartingTime, 'New:', activeFirstStageStartTime);
            // Data will be cleared since starting time changed
          }
        }

        // Load medication data
        const medicationSnap = await firebase.firestore().collection("patients").doc(patientIdFromUrl).collection("medication").get({ source: "server" });
        medicationSnap.forEach(doc => {
          const d = doc.data();
          const time = d.time;
          
          // Store oxytocin data
          if (d.oxytocin) {
            existing[`Medication_Oxytocin_${time}`] = d.oxytocin;
            if (d.oxytocin === "Yes") {
              existing[`Medication_Oxytocin_${time}_UL`] = d.oxytocin_UL || "";
              existing[`Medication_Oxytocin_${time}_drops`] = d.oxytocin_drops || "";
            }
          }
          
          // Store medicine data
          if (d.medicine) {
            existing[`Medication_Medicine_${time}`] = d.medicine;
            if (d.medicine === "Y" || d.medicine === "Yes") {
              existing[`Medication_Medicine_${time}_name`] = d.medicine_name || "";
              existing[`Medication_Medicine_${time}_dosage`] = d.medicine_dosage || "";
              existing[`Medication_Medicine_${time}_route`] = d.medicine_route || "";
              existing[`Medication_Medicine_${time}_frequency`] = d.medicine_frequency || "";
            }
          }
          
          // Store IV fluids data
          if (d.iv_fluids) {
            existing[`Medication_IV_Fluids_${time}`] = d.iv_fluids;
          }
        });

        console.log('🔄 About to generate summary table...');
        console.log(`  contractionsTimeCols: ${contractionsTimeCols.length} columns`);
        console.log(`  babyBaselineTimeCols: ${babyBaselineTimeCols.length} columns`);
        
        // If we have second stage data, ensure hybrid time columns are used
        if (secondStageStartTime && isSecondStageActive) {
          console.log('🔄 Second stage active - hybrid time columns already generated...');
          
          console.log(`  Current contractionsTimeCols: ${contractionsTimeCols.length} columns`);
          console.log(`  Current babyBaselineTimeCols: ${babyBaselineTimeCols.length} columns`);
          
          // Debug: Check if original time columns are available
          console.log('📊 Debug - Original time columns:');
          console.log(`  originalContractionsTimeCols: ${originalContractionsTimeCols.length} columns:`, originalContractionsTimeCols);
          console.log(`  originalBabyBaselineTimeCols: ${originalBabyBaselineTimeCols.length} columns:`, originalBabyBaselineTimeCols);
          console.log(`  originalCervixPlotTimeCols: ${originalCervixPlotTimeCols.length} columns:`, originalCervixPlotTimeCols);
          
          // Debug: Check existing data keys
          console.log('📊 Debug - Existing data keys:');
          const existingKeys = Object.keys(existing);
          console.log(`  Total existing keys: ${existingKeys.length}`);
          console.log(`  Sample keys:`, existingKeys.slice(0, 10));
          
          // Map existing data to new hybrid time columns
          console.log('🔄 Mapping loaded data to hybrid time columns...');
          
          // Only map if we have original time columns to map from
          if (originalContractionsTimeCols.length > 0) {
            existing = mapDataToNewIntervals(existing, originalContractionsTimeCols, contractionsTimeCols, 'Contractions');
          } else {
            console.log('⚠️ No original contractions time columns available for mapping');
          }
          
          if (originalBabyBaselineTimeCols.length > 0) {
            existing = mapDataToNewIntervals(existing, originalBabyBaselineTimeCols, babyBaselineTimeCols, 'Baseline_FHR');
            existing = mapDataToNewIntervals(existing, originalBabyBaselineTimeCols, babyBaselineTimeCols, 'FHR_deceleration');
          } else {
            console.log('⚠️ No original FHR time columns available for mapping');
          }
          
          if (originalCervixPlotTimeCols.length > 0) {
            existing = mapDataToNewIntervals(existing, originalCervixPlotTimeCols, cervixPlotTimeCols, 'Cervix_Plot');
          } else {
            console.log('⚠️ No original cervix plot time columns available for mapping');
          }
          
          console.log('✅ Data mapping completed for page load');
          
          // Debug: Check mapped data
          console.log('📊 Debug - After mapping:');
          const mappedKeys = Object.keys(existing);
          console.log(`  Total mapped keys: ${mappedKeys.length}`);
          console.log(`  Sample mapped keys:`, mappedKeys.slice(0, 10));
        }
        
        // Generate the summary table
        generateSummaryTable(existing);
        
        // Load treatment status
        await loadTreatmentStatus();
        
        // Update patient status in main collection if treatment was ended
        if (isTreatmentEnded && treatmentOutcome) {
          await updatePatientStatusInMainCollection(treatmentOutcome);
        }
        
        // Setup alert highlighting for real-time alerts
        addAlertHighlighting();
        
        // Add event listeners for form changes
        document.querySelectorAll('select, input').forEach(el => {
          el.addEventListener('change', function() {
            checkAndHighlightAlert(this);
            // Recommendations will be shown when needed, not on every change
          });
        });
        
        // Final check: If there's second stage data, automatically force hybrid generation
        if (secondStageStartTime && isSecondStageActive) {
          console.log('🔄 Final check: Automatically forcing hybrid generation...');
          
          // Automatically call the force function after a short delay to ensure everything is loaded
          setTimeout(() => {
            console.log('🔄 Auto-calling forceHybridGeneration...');
            forceHybridGeneration();
          }, 500);
        }

        // Add event listeners for starting time changes
        document.getElementById("startingTime").addEventListener("change", function() {
          console.log('🕐 Starting time changed:', this.value);
          const newStartingTime = this.value;
          if (newStartingTime) {
            const oldStartingTime = activeFirstStageStartTime;
            activeFirstStageStartTime = newStartingTime;
            
            console.log('🕐 Starting time changed:', this.value);
            // Note: Patient status is now manually controlled by midwives in list.html
            
            // Generate new time columns
            generateDynamicTimeColumns();
            
            // Save the starting time
            saveStartingTime();
            
            // Lock the starting time input after first use
            lockTimeInput("startingTime", "Active First Stage Start Time");
            
            // Hide starting time requirement message
            document.getElementById("startingTimeRequirement").style.display = "none";
            
            // Show all tables immediately
            showAllTables();
            
            // Generate tables with empty data (clear all data since time intervals changed)
            generateSummaryTable({});
            
            // Show warning about data loss
            showDataLossWarning();
          }
        });

        // Add event listener for second stage time input
        document.getElementById("secondStageTime").addEventListener("change", function() {
          const newSecondStageTime = this.value;
          if (newSecondStageTime && activeFirstStageStartTime) {
                    // Validate that second stage is after first stage (handle midnight crossing)
        const firstTime = new Date(`2000-01-01T${activeFirstStageStartTime}:00`);
        const secondTime = new Date(`2000-01-01T${newSecondStageTime}:00`);
        
        // Calculate time difference in minutes, handling midnight crossing
        let timeDiffMinutes = (secondTime - firstTime) / (1000 * 60);
        
        // If second time is earlier in the day, it means it's the next day
        if (timeDiffMinutes < 0) {
          timeDiffMinutes += 24 * 60; // Add 24 hours (1440 minutes)
        }
        
        // Second stage must be at least 30 minutes after first stage
        if (timeDiffMinutes < 30) {
          alert('Second stage must start at least 30 minutes after the active first stage start time.');
          this.value = '';
          return;
        }
            
            // Lock the second stage time input after first use
            lockTimeInput("secondStageTime", "Second Stage Start Time");
            
            // Show the second stage controls
            document.getElementById('secondStageControls').style.display = 'block';
          }
        });

      } catch (error) {
        console.error("Error loading data:", error);
        document.body.innerHTML = `<div class="alert alert-danger">Error loading data: ${error.message}</div>`;
      }
    }

    function generateSummaryTable(existing) {
      
      // Clear existing tables
      document.getElementById("supportiveCareTable").innerHTML = "";
      document.getElementById("fhrTable").innerHTML = "";
      document.getElementById("babyTable").innerHTML = "";
      document.getElementById("womanTable").innerHTML = "";
      document.getElementById("contractionsTable").innerHTML = "";
      document.getElementById("cervixPlotTable").innerHTML = "";
      document.getElementById("descentPlotTable").innerHTML = "";
      document.getElementById("medicationTable").innerHTML = "";
      document.getElementById("decisionMakingTable").innerHTML = "";
      document.getElementById("initialsTable").innerHTML = ""; // Clear initials table

      // Generate each section table
      generateSectionTable("Supportive Care", sections["Supportive Care"], "supportiveCareTable", existing);
      generateSectionTable("FHR", sections["FHR"], "fhrTable", existing);
      generateSectionTable("Baby", sections["Baby"], "babyTable", existing);
      generateSectionTable("Woman", sections["Woman"], "womanTable", existing);
      
      // Generate Contractions table with hybrid time columns
      generateSectionTable("Contractions", sections["Contractions"], "contractionsTable", existing);
      
      // Generate plotting tables (replaces the old canvas charts)
      generateCervixPlotTable("cervixPlotTable", existing);
      generateDescentPlotTable("descentPlotTable", existing);
      
      // Generate Medication table with 1-hour intervals
      generateMedicationTable("medicationTable", existing);
      
      // Generate Shared Decision-Making table with mixed time intervals
      generateSharedDecisionTable("decisionMakingTable", existing);
      
      generateInitialsTable("initialsTable", existing); // Generate initials table
      
      // Add event listeners for form changes
      addFormEventListeners();
      
      // Highlight any existing alert values after tables are generated
      setTimeout(() => {
        const allSelects = document.querySelectorAll('select');
        const allNumberInputs = document.querySelectorAll('input[type="number"]');
        
        allSelects.forEach(select => checkAndHighlightAlert(select));
        allNumberInputs.forEach(input => checkAndHighlightAlert(input));
        
        // Update second stage colors for all tables
        if (secondStageStartTime && isSecondStageActive) {
          updateSecondStageColors();
        }
        
        // Show initial recommendations after tables are generated
        if (document.getElementById('recommendations')) {
          // Clear previous recommendations tracking when tables are regenerated
          shownRecommendations.clear();
          showRecommendations();
        }
      }, 100);
    }

    // Generate a section table with dynamic time columns
    function generateSectionTable(sectionName, fields, tableId, existing) {
      console.log(`🏗️ generateSectionTable() called for: ${sectionName}`);
      
      const table = document.getElementById(tableId);
      if (!table) {
        console.error('Table not found:', tableId);
        return;
      }
      
      // Get the appropriate time columns for this section
      let timeColumns = [];
      switch (sectionName) {
        case "Supportive Care":
          timeColumns = supportiveCareTimeCols;
          break;
        case "FHR":
          timeColumns = babyBaselineTimeCols; // Hybrid intervals for FHR
          console.log(`🔍 FHR table using ${timeColumns.length} time columns:`, timeColumns);
          console.log(`🔍 FHR time columns:`, timeColumns);
          break;
        case "Baby":
          timeColumns = babyOtherTimeCols; // 1-hour intervals for other baby parameters
          break;
        case "Contractions":
          timeColumns = contractionsTimeCols; // Hybrid intervals for contractions
          console.log(`🔍 Contractions table using ${timeColumns.length} time columns:`, timeColumns);
          console.log(`🔍 Contractions time columns:`, timeColumns);
          break;
        case "Woman":
          timeColumns = womanTimeCols;
          break;
        default:
          timeColumns = supportiveCareTimeCols; // fallback
      }
      
      console.log(`  ${sectionName} table will use ${timeColumns.length} time columns`);
      
      // Create table header
      let tableHTML = '<thead><tr>';
      tableHTML += '<th class="sticky-field">Field</th>';
      tableHTML += '<th class="sticky-alert">Alert</th>';
      
      // Add time column headers with second stage highlighting
      timeColumns.forEach(time => {
        const isSecondStage = isSecondStageTime(time);
        const headerClass = isSecondStage ? 'time-header second-stage' : 'time-header';
        tableHTML += `<th class="${headerClass}">${time}</th>`;
      });
      
      tableHTML += '</tr></thead><tbody>';
      
      // Create table rows
      fields.forEach(field => {
        const fieldName = field.replace(/\s+/g, '_');
        // Translate field name for display
        const translatedField = languageManager && languageManager.t ? languageManager.t(fieldName, field) : field;
        tableHTML += '<tr>';
        tableHTML += `<td class="sticky-field">${translatedField}</td>`;
        
        // Add alert value cell
        const alertValue = whoAlertValues[field] || '';
        tableHTML += `<td class="sticky-alert"><span class="alert-value">${alertValue}</span></td>`;
        
        // Add time input cells
        timeColumns.forEach(time => {
          const timeKey = time.replace(':', '_');
          const inputName = `${fieldName}_${timeKey}`;
          const existingValue = existing && existing[inputName] ? existing[inputName] : '';
          
          // Determine input type based on field
          let inputHTML = '';
          if (field === 'Baseline FHR') {
            // Baseline FHR should be a number input
            inputHTML = `<input type="number" name="${inputName}" value="${existingValue}" class="time-cell" placeholder="Enter value" min="60" max="200">`;
          } else if (field.includes('Contractions per 10 min')) {
            // Contractions per 10 min should be a number input
            inputHTML = `<input type="number" name="${inputName}" value="${existingValue}" class="time-cell" placeholder="Enter value" min="0" max="10">`;
          } else if (field.includes('Duration of contractions')) {
            // Duration of contractions should be a number input
            inputHTML = `<input type="number" name="${inputName}" value="${existingValue}" class="time-cell" placeholder="Enter value" min="0" max="120">`;
          } else if (field.includes('Pulse') || field.includes('BP') || field.includes('Temperature')) {
            inputHTML = `<input type="number" name="${inputName}" value="${existingValue}" class="time-cell" placeholder="Enter value">`;
          } else if (field.includes('Urine')) {
            inputHTML = `<select name="${inputName}" class="time-cell">
              <option value="">Select</option>
              <option value="P++" ${existingValue === 'P++' ? 'selected' : ''}>P++</option>
              <option value="A++" ${existingValue === 'A++' ? 'selected' : ''}>A++</option>
              <option value="P+" ${existingValue === 'P+' ? 'selected' : ''}>P+</option>
              <option value="A+" ${existingValue === 'A+' ? 'selected' : ''}>A+</option>
              <option value="P-" ${existingValue === 'P-' ? 'selected' : ''}>P-</option>
              <option value="A-" ${existingValue === 'A-' ? 'selected' : ''}>A-</option>
              <option value="P Trace" ${existingValue === 'P Trace' ? 'selected' : ''}>P Trace</option>
              <option value="A Trace" ${existingValue === 'A Trace' ? 'selected' : ''}>A Trace</option>
              <option value="-/-" ${existingValue === '-/-' ? 'selected' : ''}>-/-</option>
            </select>`;
          } else {
            // Use the correct dropdown options for each field from dropdownOptions
            const fieldOptions = dropdownOptions[field] || ["Y", "N"]; // fallback to Y/N if not defined
            
            inputHTML = `<select name="${inputName}" class="time-cell">
              <option value=""></option>`;
            
            fieldOptions.forEach(option => {
              inputHTML += `<option value="${option}" ${existingValue === option ? 'selected' : ''}>${option}</option>`;
            });
            
            inputHTML += `</select>`;
          }
          
          tableHTML += `<td class="time-cell">${inputHTML}</td>`;
        });
        
        tableHTML += '</tr>';
      });
      
      tableHTML += '</tbody>';
      table.innerHTML = tableHTML;
    }

    // Generate Contractions table (keep as is)
    function generateContractionsTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Create table header
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      
      // Field header
      const fieldHeader = document.createElement("th");
      fieldHeader.className = "field-header sticky-field";
      fieldHeader.textContent = "Field";
      headerRow.appendChild(fieldHeader);
      
      // Alert header
      const alertHeader = document.createElement("th");
      alertHeader.className = "alert-header sticky-alert";
      alertHeader.textContent = "Alert";
      headerRow.appendChild(alertHeader);
      
      // Time headers (30-minute intervals with second stage highlighting)
      contractionsTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        headerRow.appendChild(timeHeader);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement("tbody");
      
      // Contractions per 10 min row
      const contractionsRow = document.createElement("tr");
      
      // Field cell
      const contractionsFieldCell = document.createElement("td");
      contractionsFieldCell.className = "field-cell sticky-field";
      contractionsFieldCell.textContent = "Contractions per 10 min";
      contractionsRow.appendChild(contractionsFieldCell);
      
      // Alert cell
      const contractionsAlertCell = document.createElement("td");
      contractionsAlertCell.className = "alert-cell sticky-alert";
      contractionsAlertCell.innerHTML = '<span class="alert-indicator">>5</span>';
      contractionsRow.appendChild(contractionsAlertCell);
      
      // Time cells for contractions per 10 min
      contractionsTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Contractions_per_10_min_${timeKey}`;
        const value = existing[key] || "";
        
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        ["<2", "2-5", ">5"].forEach(option => {
          const optionElement = document.createElement("option");
          optionElement.value = option;
          optionElement.textContent = option;
          select.appendChild(optionElement);
        });
        
        select.value = value;
        timeCell.appendChild(select);
        contractionsRow.appendChild(timeCell);
      });
      
      tbody.appendChild(contractionsRow);
      
      // Duration of contractions row
      const durationRow = document.createElement("tr");
      
      // Field cell
      const durationFieldCell = document.createElement("td");
      durationFieldCell.className = "field-cell sticky-field";
      durationFieldCell.textContent = "Duration of contractions";
      durationRow.appendChild(durationFieldCell);
      
      // Alert cell
      const durationAlertCell = document.createElement("td");
      durationAlertCell.className = "alert-cell sticky-alert";
              durationAlertCell.innerHTML = '<span class="alert-indicator">>50s</span>';
      durationRow.appendChild(durationAlertCell);
      
      // Time cells for duration of contractions
      contractionsTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Duration_of_contractions_${timeKey}`;
        const value = existing[key] || "";
        
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        ["<20s", "20-50s", ">50s"].forEach(option => {
          const optionElement = document.createElement("option");
          optionElement.value = option;
          optionElement.textContent = option;
          select.appendChild(optionElement);
        });
        
        select.value = value;
        timeCell.appendChild(select);
        durationRow.appendChild(timeCell);
      });
      
      tbody.appendChild(durationRow);
      table.appendChild(tbody);
    }



    function getLatestValue(field) {
  // Go through timeCols in reverse to find the latest non-empty value
  for (let i = timeCols.length - 1; i >= 0; i--) {
    const key = `${timeCols[i]}_${field.replace(/\s+/g, "_")}`;
    const el = document.getElementsByName(key)[0];
    if (el && el.value) return el.value;
  }
  return "";
}

    // REMOVED: Duplicate showRecommendations function that was overriding the correct one
      


      // REMOVED: Old recommendations logic that was causing duplicates
      // The new showRecommendations() function handles all recommendations dynamically
      


    // REMOVED DUPLICATE showRecommendations function that was looking for non-existent "recommendationsBox" element

    async function saveData() {
      try {
        // Validate dates before saving
        if (!validateDates()) {
          console.log('Date validation failed, not saving data');
          return;
        }
        
        const patientIdToSave = getPatientIdFromUrl();
        if (!patientIdToSave) {
          console.error('No patient ID found in URL');
          return;
        }

        const base = firebase.firestore().collection("patients").doc(patientIdToSave);

        // Fetch existing patient data to preserve created_by field
        const patientDoc = await base.get();
        let createdBy = "";
        if (patientDoc.exists) {
          const data = patientDoc.data();
          // Check both field names for compatibility
          createdBy = data.created_by || data.createdBy || "";
        }

        // Save patient info - use update() to preserve existing fields like township
        await base.update({
          name: document.getElementById("p_name").value,
          age: document.getElementById("p_age").value,
          parity: document.getElementById("p_parity").value,
          labour_onset: document.getElementById("p_onset").value,
          active_labour: document.getElementById("p_active").value,
          ruptured_membrane: document.getElementById("p_membrane").value,
          risk_factors: document.getElementById("p_risk").value,
          created_by: createdBy
        });

        // Save starting time if it exists
        if (activeFirstStageStartTime) {
          await saveStartingTime();
        }

        // Save all form data using time-based structure
        const formData = {};
        
        // Save data for each time column in each section
        // Supportive Care
        supportiveCareTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          sections["Supportive Care"].forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Baby - use the correct variable names (handle hybrid time columns)
        babyBaselineTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          // Only Baseline FHR and FHR deceleration use hybrid intervals
          const baselineFields = ["Baseline FHR", "FHR deceleration"];
          baselineFields.forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        babyOtherTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          // Other baby fields use 1-hour intervals
          const otherFields = ["Amniotic fluid", "Fetal position", "Caput", "Moulding"];
          otherFields.forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Woman
        womanTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          sections["Woman"].forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Contractions (handle hybrid time columns)
        contractionsTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          sections["Contractions"].forEach(field => {
            const fieldName = field.replace(/\s+/g, '_');
            const inputName = `${fieldName}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Medication - Fix the data collection
        medicationTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          
          // Oxytocin
          const oxytocinKey = `Medication_Oxytocin_${timeKey}`;
          const oxytocinInput = document.querySelector(`input[name="${oxytocinKey}"], select[name="${oxytocinKey}"]`);
          if (oxytocinInput && oxytocinInput.value) {
            formData[oxytocinKey] = oxytocinInput.value;
            
            // If oxytocin is "Y", save the additional details
            if (oxytocinInput.value === "Y") {
              const uLKey = `${oxytocinKey}_UL`;
              const dropsKey = `${oxytocinKey}_drops`;
              const uLInput = document.querySelector(`input[name="${uLKey}"]`);
              const dropsInput = document.querySelector(`input[name="${dropsKey}"]`);
              
              if (uLInput && uLInput.value) {
                formData[uLKey] = uLInput.value;
              }
              if (dropsInput && dropsInput.value) {
                formData[dropsKey] = dropsInput.value;
              }
            }
          }
          
          // Medicine
          const medicineKey = `Medication_Medicine_${timeKey}`;
          const medicineInput = document.querySelector(`input[name="${medicineKey}"], select[name="${medicineKey}"]`);
          if (medicineInput && medicineInput.value) {
            formData[medicineKey] = medicineInput.value;
            
            // If medicine is "Y", save the detailed inputs
            if (medicineInput.value === "Y") {
              const nameKey = `${medicineKey}_name`;
              const dosageKey = `${medicineKey}_dosage`;
              const routeKey = `${medicineKey}_route`;
              const frequencyKey = `${medicineKey}_frequency`;
              
              const nameInput = document.querySelector(`input[name="${nameKey}"]`);
              const dosageInput = document.querySelector(`input[name="${dosageKey}"]`);
              const routeInput = document.querySelector(`input[name="${routeKey}"]`);
              const frequencyInput = document.querySelector(`input[name="${frequencyKey}"]`);
              
              if (nameInput && nameInput.value) {
                formData[nameKey] = nameInput.value;
              }
              if (dosageInput && dosageInput.value) {
                formData[dosageKey] = dosageInput.value;
              }
              if (routeInput && routeInput.value) {
                formData[routeKey] = routeInput.value;
              }
              if (frequencyInput && frequencyInput.value) {
                formData[frequencyKey] = frequencyInput.value;
              }
            }
          }
          
          // IV Fluids
          const ivFluidsKey = `Medication_IV_Fluids_${timeKey}`;
          const ivFluidsInput = document.querySelector(`input[name="${ivFluidsKey}"], select[name="${ivFluidsKey}"]`);
          if (ivFluidsInput && ivFluidsInput.value) {
            formData[ivFluidsKey] = ivFluidsInput.value;
          }
        });
        
        // Shared Decision Making - Assessment
        const assessmentFields = ["Woman's condition", "Baby's condition", "Labour progress", "Other concerns"];
        assessmentTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          assessmentFields.forEach(field => {
            const fieldKey = field.replace(/\s+/g, '_').replace("'", "");
            const inputName = `ASSESSMENT_${fieldKey}_${timeKey}`;
            const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Plotting data - Cervix Plot
        cervixPlotTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          // Check each cervix value (10, 9, 8, 7, 6, 5)
          const cervixValues = ["10", "9", "8", "7", "6", "5"];
          cervixValues.forEach(value => {
            const inputName = `Cervix_Plot_${value}_${timeKey}`;
            const input = document.querySelector(`select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        // Plotting data - Descent Plot
        descentPlotTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          // Check each descent value (5, 4, 3, 2, 1, 0)
          const descentValues = ["5", "4", "3", "2", "1", "0"];
          descentValues.forEach(value => {
            const inputName = `Descent_Plot_${value}_${timeKey}`;
            const input = document.querySelector(`select[name="${inputName}"]`);
            if (input && input.value) {
              formData[inputName] = input.value;
            }
          });
        });
        
        planTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          const inputName = `PLAN_${timeKey}`;
          const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
          if (input && input.value) {
            formData[inputName] = input.value;
          }
        });
        
        // Initials
        initialsTimeCols.forEach(time => {
          const timeKey = time.replace(':', '_');
          const inputName = `INITIALS_${timeKey}`;
          const input = document.querySelector(`input[name="${inputName}"], select[name="${inputName}"]`);
          if (input && input.value) {
            formData[inputName] = input.value;
          }
        });

        // Save the summary data
        await base.collection("records").doc("summary").set({
          ...formData,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          lastUpdated: new Date().toISOString(),
          startingTime: activeFirstStageStartTime // Save the starting time with the data
        });
        
        console.log('Saved form data:', formData);
        console.log('Total fields saved:', Object.keys(formData).length);

        showSaveSuccess();
      } catch (error) {
        console.error('Save error:', error);
        showSaveError(`Failed to save data: ${error.message}`);
      }
    }

    // Show save success message
    function showSaveSuccess() {
      const successMessage = document.getElementById('successMessage');
      if (successMessage) {
        successMessage.style.display = 'flex';
        successMessage.style.zIndex = '9999';
        console.log('Success message displayed');
        
        setTimeout(() => {
          successMessage.style.display = 'none';
        }, 3000);
      } else {
        console.error('Success message element not found');
      }
    }

    // Show save error message
    function showSaveError(errorMessage) {
      const successMessage = document.getElementById('successMessage');
      if (successMessage) {
        successMessage.innerHTML = '<i class="fas fa-exclamation-triangle"></i><span>Save Error: ' + errorMessage + '</span>';
        successMessage.className = 'success-message error-message';
        successMessage.style.display = 'flex';
        successMessage.style.zIndex = '9999';
        
        setTimeout(() => {
          successMessage.style.display = 'none';
          successMessage.innerHTML = '<i class="fas fa-check-circle"></i><span>Saved Successfully</span>';
          successMessage.className = 'success-message';
        }, 5000);
        
        console.error("Save error:", errorMessage);
      } else {
        console.error('Success message element not found');
      }
    }

    // Generate time columns starting from 00:30
    function generateTimeColumns() {
      const timeCols = [];
      for (let hour = 0; hour <= 15; hour++) {
        for (let minute = 0; minute < 60; minute += 30) {
          if (hour === 0 && minute === 0) continue; // Skip 00:00
          const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
          timeCols.push(timeStr);
        }
      }
      return timeCols;
    }

    // Initialize time columns
    const timeCols = generateTimeColumns();

    // Load data when page loads
    firebase.auth().onAuthStateChanged(function(user) {
      if (!user) {
        // Add a small delay to prevent race condition with auth state
        setTimeout(() => {
          const currentUser = firebase.auth().currentUser;
          if (!currentUser) {
            console.log('No authenticated user found, redirecting to login');
            window.location.href = "login.html";
          }
        }, 100);
      } else {
        console.log('User authenticated:', user.uid, 'patientId from URL:', getPatientIdFromUrl());
        
        // Only load data after user is authenticated
        loadData();
        
        // Set the View Summary button href with the correct patient ID
        const viewSummaryBtn = document.getElementById('viewSummaryBtn');
        const currentPatientId = getPatientIdFromUrl();
        if (viewSummaryBtn && currentPatientId) {
          viewSummaryBtn.href = `summary-view.html?patient=${currentPatientId}`;
          console.log('View Summary button href set to:', viewSummaryBtn.href);
        } else {
          console.log('View Summary button not found or patientId missing:', { viewSummaryBtn, currentPatientId });
        }
        
        // Test recommendations after a delay to ensure everything is loaded
        // Recommendations will be shown when needed, not automatically
      }
    });

    // Populate time columns in the header
    function populateTimeColumns() {
      const timeColumnsContainer = document.getElementById('timeColumns');
      if (timeColumnsContainer) {
        timeColumnsContainer.innerHTML = timeCols.map(t => 
          `<div class="time-column">${t}</div>`
        ).join('');
      }
    }

    // Call this after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Set the View Summary button href immediately
      updateViewSummaryLink();
      
      // Add date validation event listeners
      const activeDiagnosisField = document.getElementById('p_active');
      const rupturedMembranesField = document.getElementById('p_membrane');
      
      if (activeDiagnosisField) {
        activeDiagnosisField.addEventListener('change', validateDates);
      }
      if (rupturedMembranesField) {
        rupturedMembranesField.addEventListener('change', validateDates);
      }
      
      populateTimeColumns();
      initializeFoldedSections(); // Initialize all sections as folded
      addAlertHighlighting(); // Add alert highlighting functionality
      
      // Test if sticky positioning is supported
      testStickySupport();
      
      // Check and lock time inputs if they already have values
      // This will run after the page loads and data is loaded
      setTimeout(() => {
        checkAndLockTimeInputs();
        logLockStatus();
        startLockMonitoring(); // Start periodic lock monitoring
      }, 1000);
    });
    
    // Test if sticky positioning is supported
    function testStickySupport() {
      const testElement = document.createElement('div');
      testElement.style.position = 'sticky';
      testElement.style.top = '0';
      
      if (testElement.style.position === 'sticky') {
        console.log('✅ Sticky positioning is supported');
      } else {
        console.log('❌ Sticky positioning is NOT supported - using fallback');
        // Add fallback CSS class
        document.body.classList.add('no-sticky-support');
      }
    }

    // Toggle patient information section
    function togglePatientInfo() {
      const patientForm = document.getElementById('patientForm');
      const toggleIcon = document.getElementById('toggleIcon');
      
      if (patientForm.style.display === 'none') {
        patientForm.style.display = 'block';
        toggleIcon.className = 'fas fa-chevron-down';
      } else {
        patientForm.style.display = 'none';
        toggleIcon.className = 'fas fa-chevron-right';
      }
    }

    // Toggle section visibility
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (!section) {
        console.log('Section not found:', sectionId);
        return;
      }
      
      const tableWrappers = section.querySelectorAll('.table-wrapper');
      const toggleIcon = section.querySelector('.toggle-icon i');
      
      if (!tableWrappers || tableWrappers.length === 0 || !toggleIcon) {
        console.log('Table wrappers or toggle icon not found in section:', sectionId);
        return;
      }
      
      // Check if any table wrapper is visible
      const isVisible = Array.from(tableWrappers).some(wrapper => 
        wrapper.style.display !== 'none' && wrapper.style.display !== ''
      );
      
      // Toggle all table wrappers
      tableWrappers.forEach(wrapper => {
        if (isVisible) {
          wrapper.style.display = 'none';
        } else {
          wrapper.style.display = 'block';
        }
      });
      
      // Update toggle icon
      if (isVisible) {
        toggleIcon.className = 'fas fa-chevron-right';
      } else {
        toggleIcon.className = 'fas fa-chevron-down';
      }
    }

    // Initialize all sections as folded
    function initializeFoldedSections() {
      // Start with Patient Information folded
      document.getElementById('patientForm').style.display = 'none';
      document.getElementById('toggleIcon').className = 'fas fa-chevron-right';
      
      // Start with all section tables folded
      const sections = ['supportiveCareSection', 'fhrSection', 'babySection', 'womanSection', 'contractionsSection', 'cervixPlotSection', 'descentPlotSection', 'medicationSection', 'decisionMakingSection', 'initialsSection'];
      sections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) {
          const tableWrappers = section.querySelectorAll('.table-wrapper');
          const toggleIcon = section.querySelector('.toggle-icon i');
          
          if (tableWrappers && tableWrappers.length > 0 && toggleIcon) {
            tableWrappers.forEach(wrapper => {
              wrapper.style.display = 'none';
            });
            toggleIcon.className = 'fas fa-chevron-right';
          }
        }
      });
    }

    // Generate Initials table with dynamic time columns
    function generateInitialsTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Create table header
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      
      // Field header
      const fieldHeader = document.createElement("th");
      fieldHeader.className = "field-header sticky-field";
      fieldHeader.textContent = "Field";
      headerRow.appendChild(fieldHeader);
      
      // Time headers (1-hour intervals with second stage highlighting)
      initialsTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        headerRow.appendChild(timeHeader);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement("tbody");
      
      // Single row for initials
      const initialsRow = document.createElement("tr");
      
      // Field cell
      const initialsFieldCell = document.createElement("td");
      initialsFieldCell.className = "field-cell sticky-field";
      initialsFieldCell.textContent = "Initials";
      initialsRow.appendChild(initialsFieldCell);
      
      // Time cells for initials
      initialsTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `INITIALS_${timeKey}`;
        const value = existing[key] || "";
        
        const input = document.createElement("input");
        input.name = key;
        input.type = "text";
        input.className = "form-control form-control-sm";
        input.placeholder = "Enter initials";
        input.value = value;
        timeCell.appendChild(input);
        initialsRow.appendChild(timeCell);
      });
      
      tbody.appendChild(initialsRow);
      table.appendChild(tbody);
    }

    // Plotting data is now handled by table-based system

    // Setup chart with grid and labels
    function setupChart(canvas, type) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw grid
      drawGrid(ctx, width, height, type);
      
      // Draw labels
      drawLabels(ctx, width, height, type);
      
      // Redraw all saved points
      redrawSavedPoints(canvas, type);
      
      // Redraw all unsaved points
      redrawUnsavedPoints(canvas, type);
      
      // Add click/touch event listeners
      addChartEventListeners(canvas, type);
    }

    // Draw grid lines
    function drawGrid(ctx, width, height, type) {
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      
      // Vertical lines (time intervals) - use dynamic time columns
      let timeColumns;
      if (type === 'cervix') {
        timeColumns = cervixPlotTimeCols;
      } else {
        timeColumns = descentPlotTimeCols;
      }
      
      const timeIntervals = timeColumns.length - 1;
      for (let i = 0; i <= timeIntervals; i++) {
        const x = (width * 0.1) + (i * (width * 0.8) / timeIntervals);
        ctx.beginPath();
        ctx.moveTo(x, height * 0.1);
        ctx.lineTo(x, height * 0.9);
        ctx.stroke();
      }
      
      // Horizontal lines (cervix/descent values)
      const valueIntervals = type === 'cervix' ? 6 : 6; // 6 levels
      for (let i = 0; i <= valueIntervals; i++) {
        const y = height * 0.1 + (i * (height * 0.8) / valueIntervals);
        ctx.beginPath();
        ctx.moveTo(width * 0.1, y);
        ctx.lineTo(width * 0.9, y);
        ctx.stroke();
      }
    }

    // Draw chart labels
    function drawLabels(ctx, width, height, type) {
      ctx.fillStyle = '#374151';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      
      // Time labels (x-axis) - use dynamic time columns
      let timeColumns;
      if (type === 'cervix') {
        timeColumns = cervixPlotTimeCols;
      } else {
        timeColumns = descentPlotTimeCols;
      }
      
      // Draw time labels for each time column
      timeColumns.forEach((time, index) => {
        const x = (width * 0.1) + (index * (width * 0.8) / (timeColumns.length - 1));
        const timeLabel = time; // Use actual time like "08:00", "09:00", etc.
        ctx.fillText(timeLabel, x, height * 0.95);
      });
      
      // Value labels (y-axis)
      if (type === 'cervix') {
        const cervixValues = ['10cm', '9cm', '8cm', '7cm', '6cm', '5cm'];
        for (let i = 0; i < cervixValues.length; i++) {
          const y = height * 0.1 + (i * (height * 0.8) / (cervixValues.length - 1));
          ctx.fillText(cervixValues[i], width * 0.05, y + 4);
        }
      } else {
        const descentValues = ['5', '4', '3', '2', '1', '0'];
        for (let i = 0; i < descentValues.length; i++) {
          const y = height * 0.1 + (i * (height * 0.8) / (descentValues.length - 1));
          ctx.fillText(descentValues[i], width * 0.05, y + 4);
        }
      }
      
      // Chart title
      ctx.font = 'bold 16px Arial';
      ctx.fillText(type === 'cervix' ? 'Cervical Dilation Progress' : 'Fetal Descent Progress', width / 2, height * 0.05);
    }

    // Add event listeners for chart interaction
    function addChartEventListeners(canvas, type) {
      // Mouse events
      canvas.addEventListener('click', (e) => handleChartClick(e, canvas, type));
      
      // Touch events for mobile
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        // Create a synthetic event
        const syntheticEvent = {
          offsetX: x,
          offsetY: y
        };
        handleChartClick(syntheticEvent, canvas, type);
      });
    }

    // Handle chart clicks/touches
    function handleChartClick(e, canvas, type) {
      const rect = canvas.getBoundingClientRect();
      const x = e.offsetX;
      const y = e.offsetY;
      
      // Convert pixel coordinates to chart values
      const timeValue = Math.round(((x - rect.width * 0.1) / (rect.width * 0.8)) * 15);
      const valueIndex = Math.round(((y - rect.height * 0.1) / (rect.height * 0.8)) * 5);
      
      if (timeValue >= 0 && timeValue <= 15 && valueIndex >= 0 && valueIndex <= 5) {
        addPlotPoint(canvas, type, timeValue, valueIndex);
      }
    }

    // Add a plot point to the chart (as unsaved)
    function addPlotPoint(canvas, type, time, value) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Calculate pixel coordinates
      const x = (width * 0.1) + (time * (width * 0.8) / 15);
      const y = height * 0.1 + (value * (height * 0.8) / 5);
      
      // Create the data point
      const dataPoint = { time, value, x, y, saved: false };
      
      // Add to unsaved points
      if (type === 'cervix') {
        unsavedCervixPoints.push(dataPoint);
      } else {
        unsavedDescentPoints.push(dataPoint);
      }
      
      // Draw the plot point with unsaved style
      ctx.fillStyle = type === 'cervix' ? '#60a5fa' : '#34d399'; // Lighter color for unsaved
      ctx.font = 'bold 18px Arial'; // Smaller font for unsaved points
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (type === 'cervix') {
        ctx.fillText('X', x, y);
      } else {
        ctx.fillText('O', x, y);
      }
      
      // Update status indicators
      updateChartStatus();
      
      // Check for alerts based on WHO LCG guidelines
      checkPlottingAlerts(type, time, value);
    }

    // Check for plotting alerts based on WHO LCG guidelines
    function checkPlottingAlerts(type, time, value) {
      if (type === 'cervix') {
        // WHO LCG Cervix Alert Guidelines
        const cervixValues = [10, 9, 8, 7, 6, 5];
        const alertThresholds = ['', '≥ 2h', '≥ 2.5h', '≥ 3h', '≥ 5h', '≥ 6h'];
        
        if (alertThresholds[value] && time > 0) {
          console.log(`⚠️ Cervix Alert: ${cervixValues[value]}cm at ${time}h - ${alertThresholds[value]}`);
          // You can add visual alerts here
        }
      } else {
        // WHO LCG Descent Alert Guidelines
        if (time >= 12 && value > 0) {
          console.log(`⚠️ Descent Alert: Second stage - pushing should begin`);
          // You can add visual alerts here
        }
      }
    }

    // Clear only unsaved points (keep saved data)
    function clearCervixChart() {
      if (cervixChart) {
        unsavedCervixPoints = [];
        setupChart(document.getElementById('cervixChart'), 'cervix');
        updateChartStatus();
        console.log('🧹 Cleared unsaved cervix points');
      }
    }

    function clearDescentChart() {
      if (descentChart) {
        unsavedDescentPoints = [];
        setupChart(document.getElementById('descentChart'), 'descent');
        updateChartStatus();
        console.log('🧹 Cleared unsaved descent points');
      }
    }

    // Clear ALL data (both saved and unsaved)
    async function clearAllCervixData() {
      if (confirm('⚠️ This will permanently delete ALL cervix plot data. Are you sure?')) {
        try {
          // Clear from Firestore
          const patientId = getPatientIdFromUrl();
          if (!patientId) return;
          
          const base = firebase.firestore().collection("patients").doc(patientId);
          await base.collection("plotData").doc("cervix").delete();
          
          // Clear local data
          cervixData = [];
          unsavedCervixPoints = [];
          
          // Redraw chart
          setupChart(document.getElementById('cervixChart'), 'cervix');
          updateChartStatus();
          
          console.log('🗑️ Cleared all cervix data');
        } catch (error) {
          console.error('❌ Error clearing cervix data:', error);
        }
      }
    }

    async function clearAllDescentData() {
      if (confirm('⚠️ This will permanently delete ALL descent plot data. Are you sure?')) {
        try {
          // Clear from Firestore
          const patientId = getPatientIdFromUrl();
          if (!patientId) return;
          
          const base = firebase.firestore().collection("patients").doc(patientId);
          await base.collection("plotData").doc("descent").delete();
          
          // Clear local data
          descentData = [];
          unsavedDescentPoints = [];
          
          // Redraw chart
          setupChart(document.getElementById('descentChart'), 'descent');
          updateChartStatus();
          
          console.log('🗑️ Cleared all descent data');
        } catch (error) {
          console.error('❌ Error clearing descent data:', error);
        }
      }
    }

    // Redraw saved points
    function redrawSavedPoints(canvas, type) {
      const data = type === 'cervix' ? cervixData : descentData;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = type === 'cervix' ? '#3b82f6' : '#10b981';
      ctx.font = 'bold 24px Arial'; // Larger font for saved points
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      data.forEach(point => {
        if (type === 'cervix') {
          ctx.fillText('X', point.x, point.y);
        } else {
          ctx.fillText('O', point.x, point.y);
        }
      });
    }

    // Redraw unsaved points
    function redrawUnsavedPoints(canvas, type) {
      const data = type === 'cervix' ? unsavedCervixPoints : unsavedDescentPoints;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = type === 'cervix' ? '#60a5fa' : '#34d399'; // Lighter color for unsaved
      ctx.font = 'bold 18px Arial'; // Smaller font for unsaved points
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      data.forEach(point => {
        if (type === 'cervix') {
          ctx.fillText('X', point.x, point.y);
        } else {
          ctx.fillText('O', point.x, point.y);
        }
      });
    }

    // Save plotting data to Firestore
    async function savePlotData() {
      try {
        // Check if user is authenticated
        if (!firebase.auth().currentUser) {
          throw new Error('User not authenticated');
        }

        const patientId = getPatientIdFromUrl();
        if (!patientId) {
          throw new Error('No patient ID found');
        }

        const base = firebase.firestore().collection("patients").doc(patientId);
        
        // Combine saved and unsaved data
        const allCervixData = [...cervixData, ...unsavedCervixPoints];
        const allDescentData = [...descentData, ...unsavedDescentPoints];
        
        // Save cervix plot data
        if (allCervixData.length > 0) {
          await base.collection("plotData").doc("cervix").set({
            data: allCervixData,
            timestamp: new Date().toISOString(),
            savedBy: firebase.auth().currentUser.uid
          });
          cervixData = allCervixData;
          unsavedCervixPoints = [];
        }
        
        // Save descent plot data
        if (allDescentData.length > 0) {
          await base.collection("plotData").doc("descent").set({
            data: allDescentData,
            timestamp: new Date().toISOString(),
            savedBy: firebase.auth().currentUser.uid
          });
          descentData = allDescentData;
          unsavedDescentPoints = [];
        }
        
        // Show success message
        showSaveSuccess();
        console.log('✅ Plot data saved successfully');
        
        // Redraw charts to show saved state
        if (cervixChart) {
          setupChart(document.getElementById('cervixChart'), 'cervix');
        }
        if (descentChart) {
          setupChart(document.getElementById('descentChart'), 'descent');
        }
        
        // Update status indicators
        updateChartStatus();
        
      } catch (error) {
        console.error('❌ Error saving plot data:', error);
        showSaveError(`Failed to save plot data: ${error.message}`);
      }
    }

    // Load treatment status from Firestore
    async function loadTreatmentStatus() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        const endTreatmentDoc = await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('records')
          .doc('endTreatment')
          .get();
        
        if (endTreatmentDoc.exists) {
          const data = endTreatmentDoc.data();
          isTreatmentEnded = true;
          treatmentOutcome = data.outcome;
          
          // Update button state
          updateEndTreatmentButton();
          
          console.log('Treatment status loaded:', treatmentOutcome);
        }
      } catch (error) {
        console.error('Error loading treatment status:', error);
      }
    }

    // Load plotting data from Firestore
    async function loadPlotData() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        console.log('✅ Plot data loading is now handled by the main data loading process');
        
      } catch (error) {
        console.error('❌ Error loading plot data:', error);
        // Don't show error to user for loading, just log it
      }
    }

    // Alert highlighting function - RESTORED!
    function checkAndHighlightAlert(element) {
      if (!element) return;
      
      const fieldName = element.name;
      const value = element.value;
      
      // Remove any existing alert highlighting
      element.classList.remove('alert-value');
      
      // Check for cervix plot alerts first
      if (fieldName.includes('Cervix_Plot_')) {
        // Extract cervix value and time key from field name
        const parts = fieldName.split('_');
        if (parts.length >= 4) {
          const cervixValue = parts[2]; // e.g., "5", "6", "7", etc.
          const timeKey = parts.slice(3).join('_'); // e.g., "20_49", "21_49", etc.
          
          if (checkCervixPlotAlert(cervixValue, value, timeKey)) {
            element.classList.add('alert-value');
          }
        }
      }
      // Check for other alert conditions
      else if (fieldName.includes('Companion') && value === 'N') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Mobility') && value === 'SP') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Baseline_FHR')) {
        const fhr = parseFloat(value);
        if (fhr < 110 || fhr >= 160) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Pulse')) {
        const pulse = parseFloat(value);
        if (pulse < 60 || pulse >= 120) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Systolic_BP')) {
        const bp = parseFloat(value);
        if (bp < 80 || bp >= 140) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Diastolic_BP')) {
        const bp = parseFloat(value);
        if (bp >= 90) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Temperature_C')) {
        const temp = parseFloat(value);
        if (temp < 35.0 || temp >= 37.5) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('FHR_deceleration') && value === 'L') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Amniotic_fluid') && (value === 'M+++' || value === 'B')) {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Fetal_position') && (value === 'P' || value === 'T')) {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Caput') && value === '+++') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Moulding') && value === '+++') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Pain_Relief') && value === 'N') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Oral_fluids') && value === 'N') {
        element.classList.add('alert-value');
      } else if (fieldName.includes('Contractions_per_10_min')) {
        const contractions = parseFloat(value);
        if (contractions <= 2 || contractions > 5) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Duration_of_contractions')) {
        const duration = parseFloat(value);
        if (duration < 20 || duration > 60) {
          element.classList.add('alert-value');
        }
      } else if (fieldName.includes('Urine')) {
        if (value.includes('P++') || value.includes('A++')) {
          element.classList.add('alert-value');
        }
      }
    }

    // Add alert highlighting to all form elements
    function addAlertHighlighting() {
      // Add event listeners for real-time alert checking
      document.addEventListener('change', function(e) {
        if (e.target.matches('select, input')) {
          checkAndHighlightAlert(e.target);
        }
      });
      
      document.addEventListener('input', function(e) {
        if (e.target.matches('input[type="number"]')) {
          checkAndHighlightAlert(e.target);
        }
      });
    }

    // Update chart status indicators
    function updateChartStatus() {
      // Update cervix chart status
      const cervixSavedElement = document.getElementById('cervixSavedCount');
      const cervixUnsavedElement = document.getElementById('cervixUnsavedCount');
      if (cervixSavedElement) cervixSavedElement.textContent = cervixData.length;
      if (cervixUnsavedElement) cervixUnsavedElement.textContent = unsavedCervixPoints.length;
      
      // Update descent chart status
      const descentSavedElement = document.getElementById('descentSavedCount');
      const descentUnsavedElement = document.getElementById('descentUnsavedCount');
      if (descentSavedElement) descentSavedElement.textContent = descentData.length;
      if (descentUnsavedElement) descentUnsavedElement.textContent = unsavedDescentPoints.length;
    }

    // Generate Medication table with dynamic time columns
    function generateMedicationTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Add CSS class for second stage if active
      if (secondStageStartTime && isSecondStageActive) {
        table.classList.add('second-stage-active');
        console.log('🟢 Medication table: Added second-stage-active class');
      } else {
        table.classList.remove('second-stage-active');
        console.log('🔵 Medication table: Removed second-stage-active class');
      }
      
      // Create table header
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      
      // Field header
      const fieldHeader = document.createElement("th");
      fieldHeader.className = "field-header sticky-field";
      fieldHeader.textContent = "Field";
      headerRow.appendChild(fieldHeader);
      
      // Time headers (1-hour intervals with second stage highlighting)
      console.log(`🔍 Medication table: Checking second stage state - secondStageStartTime: ${secondStageStartTime}, isSecondStageActive: ${isSecondStageActive}`);
      medicationTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
          console.log(`🟢 Medication: Second stage highlighting applied to ${time}`);
          console.log(`🔍 Style applied: backgroundColor=${timeHeader.style.backgroundColor}, color=${timeHeader.style.color}`);
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
          console.log(`🔵 Medication: First stage highlighting applied to ${time}`);
          console.log(`🔍 Style applied: backgroundColor=${timeHeader.style.backgroundColor}, color=${timeHeader.style.color}`);
        }
        
        timeHeader.textContent = time;
        headerRow.appendChild(timeHeader);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement("tbody");
      
      // Row 1: Oxytocin
      const oxytocinRow = document.createElement("tr");
      
      // Field cell
      const oxytocinFieldCell = document.createElement("td");
      oxytocinFieldCell.className = "field-cell sticky-field";
      oxytocinFieldCell.textContent = "Oxytocin";
      oxytocinRow.appendChild(oxytocinFieldCell);
      
      // Time cells for oxytocin
      medicationTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Medication_Oxytocin_${timeKey}`;
        const value = existing[key] || "";
        
        // Create the main container for this cell
        const cellContainer = document.createElement("div");
        cellContainer.className = "medication-cell-container";
        
        if (value === "Y") {
          // Show input fields when Y is selected
          const detailsContainer = document.createElement("div");
          detailsContainer.className = "oxytocin-details";
          
          const uLInput = document.createElement("input");
          uLInput.name = `${key}_UL`;
          uLInput.type = "number";
          uLInput.className = "form-control form-control-sm mb-1";
          uLInput.placeholder = "U/L";
          uLInput.min = "0";
          uLInput.step = "0.1";
          uLInput.value = existing[`${key}_UL`] || "";
          detailsContainer.appendChild(uLInput);
          
          const dropsInput = document.createElement("input");
          dropsInput.name = `${key}_drops`;
          dropsInput.type = "number";
          dropsInput.className = "form-control form-control-sm";
          dropsInput.placeholder = "drops/min";
          dropsInput.min = "0";
          dropsInput.step = "1";
          dropsInput.value = existing[`${key}_drops`] || "";
          detailsContainer.appendChild(dropsInput);
          
          // Add hidden input to store the Y value
          const hiddenInput = document.createElement("input");
          hiddenInput.type = "hidden";
          hiddenInput.name = key;
          hiddenInput.value = "Y";
          detailsContainer.appendChild(hiddenInput);
          
          // Add change to N button
          const changeButton = document.createElement("button");
          changeButton.type = "button";
          changeButton.className = "btn btn-sm btn-outline-secondary mt-1";
          changeButton.textContent = "Change to N";
          changeButton.onclick = function() {
            // Clear the cell and regenerate with N selected
            timeCell.innerHTML = "";
            generateOxytocinCell(timeCell, time, { [key]: "N" });
          };
          detailsContainer.appendChild(changeButton);
          
          cellContainer.appendChild(detailsContainer);
        } else {
          // Show dropdown when N or empty
          const select = document.createElement("select");
          select.name = key;
          select.className = "form-select form-select-sm";
          
          const blankOption = document.createElement("option");
          blankOption.value = "";
          blankOption.textContent = "";
          select.appendChild(blankOption);
          
          const noOption = document.createElement("option");
          noOption.value = "N";
          noOption.textContent = "N";
          select.appendChild(noOption);
          
          const yesOption = document.createElement("option");
          yesOption.value = "Y";
          yesOption.textContent = "Y";
          select.appendChild(yesOption);
          
          select.value = value;
          
          // Add change event listener
          select.addEventListener('change', function() {
            if (this.value === "Y") {
              // Clear the cell and regenerate with Y selected
              timeCell.innerHTML = "";
              generateOxytocinCell(timeCell, time, { [key]: "Y" });
            }
          });
          
          cellContainer.appendChild(select);
        }
        
        timeCell.appendChild(cellContainer);
        oxytocinRow.appendChild(timeCell);
      });
      
      tbody.appendChild(oxytocinRow);
      
      // Row 2: Medicine
      const medicineRow = document.createElement("tr");
      
      // Field cell
      const medicineFieldCell = document.createElement("td");
      medicineFieldCell.className = "field-cell sticky-field";
      medicineFieldCell.textContent = "Medicine";
      medicineRow.appendChild(medicineFieldCell);
      
      // Time cells for medicine
      medicationTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Medication_Medicine_${timeKey}`;
        const value = existing[key] || "";
        
        // Create the main container for this cell
        const cellContainer = document.createElement("div");
        cellContainer.className = "medication-cell-container";
        
        if (value === "Y") {
          // Show detailed input fields when Y is selected
          const detailsContainer = document.createElement("div");
          detailsContainer.className = "medicine-details";
          
          // Add hidden input to store the Y value
          const hiddenInput = document.createElement("input");
          hiddenInput.type = "hidden";
          hiddenInput.name = key;
          hiddenInput.value = "Y";
          detailsContainer.appendChild(hiddenInput);
          
          // Medicine Name input
          const nameInput = document.createElement("input");
          nameInput.name = `${key}_name`;
          nameInput.type = "text";
          nameInput.className = "form-control form-control-sm mb-1";
          nameInput.placeholder = "Medicine Name";
          nameInput.value = existing[`${key}_name`] || "";
          detailsContainer.appendChild(nameInput);
          
          // Dosage input
          const dosageInput = document.createElement("input");
          dosageInput.name = `${key}_dosage`;
          dosageInput.type = "text";
          dosageInput.className = "form-control form-control-sm mb-1";
          dosageInput.placeholder = "Dosage";
          dosageInput.value = existing[`${key}_dosage`] || "";
          detailsContainer.appendChild(dosageInput);
          
          // Route input
          const routeInput = document.createElement("input");
          routeInput.name = `${key}_route`;
          routeInput.type = "text";
          routeInput.className = "form-control form-control-sm mb-1";
          routeInput.placeholder = "Route";
          routeInput.value = existing[`${key}_route`] || "";
          detailsContainer.appendChild(routeInput);
          
          // Frequency input
          const frequencyInput = document.createElement("input");
          frequencyInput.name = `${key}_frequency`;
          frequencyInput.type = "text";
          frequencyInput.className = "form-control form-control-sm mb-1";
          frequencyInput.placeholder = "Frequency";
          frequencyInput.value = existing[`${key}_frequency`] || "";
          detailsContainer.appendChild(frequencyInput);
          
          // Add change to N button
          const changeButton = document.createElement("button");
          changeButton.type = "button";
          changeButton.className = "btn btn-sm btn-outline-secondary mt-1";
          changeButton.textContent = "Change to N";
          changeButton.onclick = function() {
            // Clear the cell and regenerate with N selected
            timeCell.innerHTML = "";
            generateMedicineCell(timeCell, time, { [key]: "N" });
          };
          detailsContainer.appendChild(changeButton);
          
          cellContainer.appendChild(detailsContainer);
        } else {
          // Show dropdown when N or empty
          const select = document.createElement("select");
          select.name = key;
          select.className = "form-select form-select-sm";
          
          const blankOption = document.createElement("option");
          blankOption.value = "";
          blankOption.textContent = "";
          select.appendChild(blankOption);
          
          const noOption = document.createElement("option");
          noOption.value = "N";
          noOption.textContent = "N";
          select.appendChild(noOption);
          
          const yesOption = document.createElement("option");
          yesOption.value = "Y";
          yesOption.textContent = "Y";
          select.appendChild(yesOption);
          
          select.value = value;
          
          // Add change event listener
          select.addEventListener('change', function() {
            console.log('Medicine select changed (first):', this.value);
            if (this.value === "Y") {
              console.log('Generating medicine cell with Y selected (first)');
              // Clear the cell and regenerate with Y selected
              timeCell.innerHTML = "";
              generateMedicineCell(timeCell, time, { [key]: "Y" });
            }
          });
          
          cellContainer.appendChild(select);
        }
        
        timeCell.appendChild(cellContainer);
        medicineRow.appendChild(timeCell);
      });
      
      tbody.appendChild(medicineRow);
      
      // Row 3: IV Fluids
      const ivFluidsRow = document.createElement("tr");
      
      // Field cell
      const ivFluidsFieldCell = document.createElement("td");
      ivFluidsFieldCell.className = "field-cell sticky-field";
      ivFluidsFieldCell.textContent = "IV Fluids";
      ivFluidsRow.appendChild(ivFluidsFieldCell);
      
      // Time cells for IV fluids
      medicationTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Medication_IV_Fluids_${timeKey}`;
        const value = existing[key] || "";
        
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        const noOption = document.createElement("option");
        noOption.value = "N";
        noOption.textContent = "N";
        select.appendChild(noOption);
        
        const yesOption = document.createElement("option");
        yesOption.value = "Y";
        yesOption.textContent = "Y";
        select.appendChild(yesOption);
        
        select.value = value;
        timeCell.appendChild(select);
        ivFluidsRow.appendChild(timeCell);
      });
      
      tbody.appendChild(ivFluidsRow);
      table.appendChild(tbody);
      
      // Debug: Check computed styles after table generation
      setTimeout(() => {
        console.log('🔍 Debugging medication table styles after generation:');
        const timeHeaders = table.querySelectorAll('.time-header');
        timeHeaders.forEach((header, index) => {
          const computedStyle = window.getComputedStyle(header);
          console.log(`Time header ${index}: "${header.textContent}"`);
          console.log(`  Inline style: backgroundColor=${header.style.backgroundColor}, color=${header.style.color}`);
          console.log(`  Computed style: backgroundColor=${computedStyle.backgroundColor}, color=${computedStyle.color}`);
        });
        
        // Force re-application of second stage colors if needed
        if (secondStageStartTime && isSecondStageActive) {
          console.log('🔄 Force re-applying second stage colors to medication table');
          timeHeaders.forEach((header, index) => {
            const timeText = header.textContent;
            if (isSecondStageTime(timeText)) {
              header.style.setProperty('background-color', '#dcfce7', 'important');
              header.style.setProperty('color', '#166534', 'important');
              console.log(`✅ Force applied green to ${timeText}`);
            }
          });
        }
      }, 100);
    }

    // Helper function to generate Oxytocin cell content
    function generateOxytocinCell(timeCell, time, existing) {
      const timeKey = time.replace(':', '_');
      const key = `Medication_Oxytocin_${timeKey}`;
      
      const cellContainer = document.createElement("div");
      cellContainer.className = "medication-cell-container";
      
      if (existing[key] === "Y") {
        // Show input fields when Y is selected
        const detailsContainer = document.createElement("div");
        detailsContainer.className = "oxytocin-details";
        
        const uLInput = document.createElement("input");
        uLInput.name = `${key}_UL`;
        uLInput.type = "number";
        uLInput.className = "form-control form-control-sm mb-1";
        uLInput.placeholder = "U/L";
        uLInput.min = "0";
        uLInput.step = "0.1";
        uLInput.value = existing[`${key}_UL`] || "";
        detailsContainer.appendChild(uLInput);
        
        const dropsInput = document.createElement("input");
        dropsInput.name = `${key}_drops`;
        dropsInput.type = "number";
        dropsInput.className = "form-control form-control-sm";
        dropsInput.placeholder = "drops/min";
        dropsInput.min = "0";
        dropsInput.step = "1";
        dropsInput.value = existing[`${key}_drops`] || "";
        detailsContainer.appendChild(dropsInput);
        
        // Add hidden input to store the Y value
        const hiddenInput = document.createElement("input");
        hiddenInput.type = "hidden";
        hiddenInput.name = key;
        hiddenInput.value = "Y";
        detailsContainer.appendChild(hiddenInput);
        
        // Add change to N button
        const changeButton = document.createElement("button");
        changeButton.type = "button";
        changeButton.className = "btn btn-sm btn-outline-secondary mt-1";
        changeButton.textContent = "Change to N";
        changeButton.onclick = function() {
          // Clear the cell and regenerate with N selected
          timeCell.innerHTML = "";
          generateOxytocinCell(timeCell, time, { [key]: "N" });
        };
        detailsContainer.appendChild(changeButton);
        
        cellContainer.appendChild(detailsContainer);
      } else {
        // Show dropdown when N or empty
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        const noOption = document.createElement("option");
        noOption.value = "N";
        noOption.textContent = "N";
        select.appendChild(noOption);
        
        const yesOption = document.createElement("option");
        yesOption.value = "Y";
        yesOption.textContent = "Y";
        select.appendChild(yesOption);
        
        select.value = existing[key] || "";
        
        // Add change event listener
        select.addEventListener('change', function() {
          if (this.value === "Y") {
            // Clear the cell and regenerate with Y selected
            timeCell.innerHTML = "";
            generateOxytocinCell(timeCell, time, { [key]: "Y" });
          }
        });
        
        cellContainer.appendChild(select);
      }
      
      timeCell.appendChild(cellContainer);
    }

    // Helper function to generate Medicine cell content
    function generateMedicineCell(timeCell, time, existing) {
      console.log('generateMedicineCell called with:', time, existing);
      const timeKey = time.replace(':', '_');
      const key = `Medication_Medicine_${timeKey}`;
      
      const cellContainer = document.createElement("div");
      cellContainer.className = "medication-cell-container";
      
      if (existing[key] === "Y") {
        // Show detailed input fields when Y is selected
        const detailsContainer = document.createElement("div");
        detailsContainer.className = "medicine-details";
        
        // Add hidden input to store the Y value
        const hiddenInput = document.createElement("input");
        hiddenInput.type = "hidden";
        hiddenInput.name = key;
        hiddenInput.value = "Y";
        detailsContainer.appendChild(hiddenInput);
        
        // Medicine Name input
        const nameInput = document.createElement("input");
        nameInput.name = `${key}_name`;
        nameInput.type = "text";
        nameInput.className = "form-control form-control-sm mb-1";
        nameInput.placeholder = "Medicine Name";
        nameInput.value = existing[`${key}_name`] || "";
        detailsContainer.appendChild(nameInput);
        
        // Dosage input
        const dosageInput = document.createElement("input");
        dosageInput.name = `${key}_dosage`;
        dosageInput.type = "text";
        dosageInput.className = "form-control form-control-sm mb-1";
        dosageInput.placeholder = "Dosage";
        dosageInput.value = existing[`${key}_dosage`] || "";
        detailsContainer.appendChild(dosageInput);
        
        // Route input
        const routeInput = document.createElement("input");
        routeInput.name = `${key}_route`;
        routeInput.type = "text";
        routeInput.className = "form-control form-control-sm mb-1";
        routeInput.placeholder = "Route";
        routeInput.value = existing[`${key}_route`] || "";
        detailsContainer.appendChild(routeInput);
        
        // Frequency input
        const frequencyInput = document.createElement("input");
        frequencyInput.name = `${key}_frequency`;
        frequencyInput.type = "text";
        frequencyInput.className = "form-control form-control-sm mb-1";
        frequencyInput.placeholder = "Frequency";
        frequencyInput.value = existing[`${key}_frequency`] || "";
        detailsContainer.appendChild(frequencyInput);
        
        // Add change to N button
        const changeButton = document.createElement("button");
        changeButton.type = "button";
        changeButton.className = "btn btn-sm btn-outline-secondary mt-1";
        changeButton.textContent = "Change to N";
        changeButton.onclick = function() {
          // Clear the cell and regenerate with N selected
          timeCell.innerHTML = "";
          generateMedicineCell(timeCell, time, { [key]: "N" });
        };
        detailsContainer.appendChild(changeButton);
        
        cellContainer.appendChild(detailsContainer);
      } else {
        // Show dropdown when N or empty
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        const noOption = document.createElement("option");
        noOption.value = "N";
        noOption.textContent = "N";
        select.appendChild(noOption);
        
        const yesOption = document.createElement("option");
        yesOption.value = "Y";
        yesOption.textContent = "Y";
        select.appendChild(yesOption);
        
        select.value = existing[key] || "";
        
        // Add change event listener
        select.addEventListener('change', function() {
          console.log('Medicine select changed:', this.value);
          if (this.value === "Y") {
            console.log('Generating medicine cell with Y selected');
            // Clear the cell and regenerate with Y selected
            timeCell.innerHTML = "";
            generateMedicineCell(timeCell, time, { [key]: "Y" });
          }
        });
        
        cellContainer.appendChild(select);
      }
      
      timeCell.appendChild(cellContainer);
    }

    // Shared Decision-Making Table - Following WHO LCG Guidelines
    function generateSharedDecisionTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Create two separate mini-tables for better usability
      
      // ===== ASSESSMENT TABLE =====
      const assessmentTable = document.createElement("div");
      assessmentTable.className = "mini-table-container mb-4";
      
      const assessmentTitle = document.createElement("h5");
      assessmentTitle.className = "mini-table-title";
      assessmentTitle.innerHTML = '<i class="fas fa-clipboard-list"></i> Assessment';
      assessmentTable.appendChild(assessmentTitle);
      
      const assessmentTableElement = document.createElement("table");
      assessmentTableElement.className = "summary-table mini-table";
      
      // Assessment table header
      const assessmentThead = document.createElement("thead");
      const assessmentHeaderRow = document.createElement("tr");
      
      // Field header
      const assessmentFieldHeader = document.createElement("th");
      assessmentFieldHeader.className = "field-header sticky-field";
      assessmentFieldHeader.textContent = "Field";
      assessmentHeaderRow.appendChild(assessmentFieldHeader);
      
      // Time headers (1-hour intervals from 01:00 to 15:00)
      assessmentTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark green text
        }
        
        timeHeader.textContent = time;
        assessmentHeaderRow.appendChild(timeHeader);
      });
      
      assessmentThead.appendChild(assessmentHeaderRow);
      assessmentTableElement.appendChild(assessmentThead);
      
      // Assessment table body
      const assessmentTbody = document.createElement("tbody");
      
      // Assessment data rows
      const assessmentFields = ["Woman's condition", "Baby's condition", "Labour progress", "Other concerns"];
      
      assessmentFields.forEach(field => {
        const row = document.createElement("tr");
        
        // Field cell
        const fieldCell = document.createElement("td");
        fieldCell.className = "field-cell sticky-field";
        fieldCell.textContent = field;
        row.appendChild(fieldCell);
        
        // Time cells for assessment (1-hour intervals)
        assessmentTimeCols.forEach(time => {
          const timeCell = document.createElement("td");
          timeCell.className = "time-cell";
          timeCell.style.minWidth = "60px";
          
          const timeKey = time.replace(':', '_');
          const fieldKey = field.replace(/\s+/g, '_').replace("'", "");
          const key = `ASSESSMENT_${fieldKey}_${timeKey}`;
          const value = existing[key] || "";
          
          const input = document.createElement("input");
          input.name = key;
          input.type = "text";
          input.className = "form-control form-control-sm";
          input.placeholder = "Brief note";
          input.value = value;
          timeCell.appendChild(input);
          row.appendChild(timeCell);
        });
        
        assessmentTbody.appendChild(row);
      });
      
      assessmentTableElement.appendChild(assessmentTbody);
      assessmentTable.appendChild(assessmentTableElement);
      
      // ===== PLAN TABLE =====
      const planTable = document.createElement("div");
      planTable.className = "mini-table-container";
      
      const planTitle = document.createElement("h5");
      planTitle.className = "mini-table-title";
      planTitle.innerHTML = '<i class="fas fa-tasks"></i> Plan';
      planTable.appendChild(planTitle);
      
      const planTableElement = document.createElement("table");
      planTableElement.className = "summary-table mini-table";
      
      // Plan table header
      const planThead = document.createElement("thead");
      const planHeaderRow = document.createElement("tr");
      
      // Field header
      const planFieldHeader = document.createElement("th");
      planFieldHeader.className = "field-header sticky-field";
      planFieldHeader.textContent = "Field";
      planHeaderRow.appendChild(planFieldHeader);
      
      // Time headers (2-hour intervals from 02:00 to 14:00)
      planTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        planHeaderRow.appendChild(timeHeader);
      });
      
      planThead.appendChild(planHeaderRow);
      planTableElement.appendChild(planThead);
      
      // Plan table body
      const planTbody = document.createElement("tbody");
      
      // Single plan row
      const planRow = document.createElement("tr");
      
      // Field cell
      const planFieldCell = document.createElement("td");
      planFieldCell.className = "field-cell sticky-field";
      planFieldCell.textContent = "Plan";
      planRow.appendChild(planFieldCell);
      
      // Time cells for plan (2-hour intervals)
      planTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        timeCell.style.minWidth = "120px";
        
        const timeKey = time.replace(':', '_');
        const key = `PLAN_${timeKey}`;
        const value = existing[key] || "";
        
        const input = document.createElement("input");
        input.name = key;
        input.type = "text";
        input.className = "form-control form-control-sm";
        input.placeholder = "Detailed plan";
        input.value = value;
        timeCell.appendChild(input);
        planRow.appendChild(timeCell);
      });
      
      planTbody.appendChild(planRow);
      planTableElement.appendChild(planTbody);
      planTable.appendChild(planTableElement);
      
      // Add both tables to the main container
      table.appendChild(assessmentTable);
      table.appendChild(planTable);
      
      // Add event listeners for all inputs
      const allInputs = table.querySelectorAll('input[type="text"]');
      allInputs.forEach(input => {
        input.addEventListener('change', function() {
          // Recommendations will be shown when needed, not on every change
        });
        input.addEventListener('input', function() {
          // Recommendations will be shown when needed, not on every change
        });
      });
    }

    // ===== DYNAMIC TIME MANAGEMENT =====
    let activeFirstStageStartTime = null;
    let secondStageStartTime = null;
    let isSecondStageActive = false;
    
    // Default time intervals (will be dynamically generated)
    let supportiveCareTimeCols = [];
    let babyBaselineTimeCols = [];
    let babyOtherTimeCols = [];
    let womanTimeCols = [];
    let contractionsTimeCols = [];
    let cervixPlotTimeCols = [];
    let descentPlotTimeCols = [];
    let medicationTimeCols = [];
    let assessmentTimeCols = [];
    let planTimeCols = [];
    let initialsTimeCols = [];
    
    // Second stage time intervals (15-minute for contractions and FHR)
    let contractionsTimeColsSecondStage = [];
    let babyBaselineTimeColsSecondStage = [];
    let cervixPlotTimeColsSecondStage = [];
    
    // Store original time columns for data mapping
    let originalContractionsTimeCols = [];
    let originalBabyBaselineTimeCols = [];
    let originalCervixPlotTimeCols = [];
    
    // Generate time columns based on starting time
    function generateDynamicTimeColumns() {
      console.log('🚀 generateDynamicTimeColumns() called');
      console.log(`  activeFirstStageStartTime: ${activeFirstStageStartTime}`);
      
      if (!activeFirstStageStartTime) {
        // Default fallback - use current time as starting point
        const now = new Date();
        activeFirstStageStartTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        console.log(`  No starting time, using current time: ${activeFirstStageStartTime}`);
      }
      
      const startHour = parseInt(activeFirstStageStartTime.split(':')[0]);
      const startMinute = parseInt(activeFirstStageStartTime.split(':')[1]);
      
      // Supportive Care: +1 hour intervals for 12 hours
      supportiveCareTimeCols = [];
      for (let i = 0; i <= 12; i++) {
        const hour = (startHour + i) % 24;
        supportiveCareTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
      }
      
      // Baby Baseline & FHR: +30 minute intervals for 12 hours (FIRST STAGE)
      babyBaselineTimeCols = [];
      for (let i = 0; i <= 24; i++) {
        const totalMinutes = startHour * 60 + startMinute + (i * 30);
        const hour = Math.floor(totalMinutes / 60) % 24;
        const minute = totalMinutes % 60;
        babyBaselineTimeCols.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      }
      
      // Baby Baseline & FHR: +15 minute intervals for 12 hours (SECOND STAGE)
      babyBaselineTimeColsSecondStage = [];
      for (let i = 0; i <= 48; i++) {
        const totalMinutes = startHour * 60 + startMinute + (i * 15);
        const hour = Math.floor(totalMinutes / 60) % 24;
        const minute = totalMinutes % 60;
        babyBaselineTimeColsSecondStage.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      }
      
      // Baby Other, Woman, Medication, Assessment, Initials: +1 hour intervals for 12 hours
      babyOtherTimeCols = [];
      womanTimeCols = [];
      medicationTimeCols = [];
      assessmentTimeCols = [];
      initialsTimeCols = [];
      for (let i = 0; i <= 12; i++) {
        const hour = (startHour + i) % 24;
        babyOtherTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        womanTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        medicationTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        assessmentTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        initialsTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
      }
      
      // Contractions: +30 minute intervals for 12 hours (FIRST STAGE)
      contractionsTimeCols = [];
      for (let i = 0; i <= 24; i++) {
        const totalMinutes = startHour * 60 + startMinute + (i * 30);
        const hour = Math.floor(totalMinutes / 60) % 24;
        const minute = totalMinutes % 60;
        contractionsTimeCols.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      }
      
      // Contractions: +15 minute intervals for 12 hours (SECOND STAGE)
      contractionsTimeColsSecondStage = [];
      for (let i = 0; i <= 48; i++) {
        const totalMinutes = startHour * 60 + startMinute + (i * 15);
        const hour = Math.floor(totalMinutes / 60) % 24;
        const minute = totalMinutes % 60;
        contractionsTimeColsSecondStage.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      }
      
      // Cervix & Descent Plot: +1 hour intervals for 12 hours
      cervixPlotTimeCols = [];
      descentPlotTimeCols = [];
      for (let i = 0; i <= 12; i++) {
        const hour = (startHour + i) % 24;
        cervixPlotTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
        descentPlotTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
      }
      
      // Cervix Plot: +15 minute intervals for 12 hours (SECOND STAGE)
      cervixPlotTimeColsSecondStage = [];
      for (let i = 0; i <= 48; i++) {
        const totalMinutes = startHour * 60 + startMinute + (i * 15);
        const hour = Math.floor(totalMinutes / 60) % 24;
        const minute = totalMinutes % 60;
        cervixPlotTimeColsSecondStage.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      }
      
      // Plan: +2 hour intervals for 12 hours
      planTimeCols = [];
      for (let i = 0; i <= 6; i++) {
        const hour = (startHour + (i * 2)) % 24;
        planTimeCols.push(`${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`);
      }
    }
    
    // Check if a time column should be highlighted for second stage
                function isSecondStageTime(time) {
              if (!secondStageStartTime || !isSecondStageActive) {
                console.log(`🔍 isSecondStageTime(${time}): secondStageStartTime=${secondStageStartTime}, isSecondStageActive=${isSecondStageActive}`);
                return false;
              }
              
              // Create Date objects for proper time comparison across midnight
              const baseDate = new Date('2024-01-01'); // Use a common base date
              const timeDate = createTimeDate(time, baseDate);
              const secondStageDate = createTimeDate(secondStageStartTime, baseDate);
              const activeFirstStageDate = createTimeDate(activeFirstStageStartTime, baseDate);
              
              // If second stage is earlier than first stage, it means it's the next day
              if (secondStageDate < activeFirstStageDate) {
                // Second stage is next day, so adjust second stage date
                secondStageDate.setDate(secondStageDate.getDate() + 1);
              }
              
              // If current time is earlier than first stage, it means it's the next day
              if (timeDate < activeFirstStageDate) {
                timeDate.setDate(timeDate.getDate() + 1);
              }
              
              const isSecondStage = timeDate >= secondStageDate;
              console.log(`🔍 isSecondStageTime(${time}): ${time} >= ${secondStageStartTime} = ${isSecondStage} (using EXACT second stage time)`);
              return isSecondStage;
            }
            
            // Helper function to create a Date object from time string
            function createTimeDate(timeStr, baseDate) {
              const [hours, minutes] = timeStr.split(':').map(Number);
              const date = new Date(baseDate);
              date.setHours(hours, minutes, 0, 0);
              return date;
            }
    
    // Generate hybrid time columns: 30-min before second stage, 15-min after
    function generateHybridTimeColumns() {
      console.log('🚀 generateHybridTimeColumns() called');
      console.log(`  activeFirstStageStartTime: ${activeFirstStageStartTime}`);
      console.log(`  secondStageStartTime: ${secondStageStartTime}`);
      console.log(`  isSecondStageActive: ${isSecondStageActive}`);
      console.log(`  Current contractionsTimeCols length: ${contractionsTimeCols.length}`);
      console.log(`  Current babyBaselineTimeCols length: ${babyBaselineTimeCols.length}`);
      
      if (!activeFirstStageStartTime) {
        console.log('❌ No activeFirstStageStartTime, returning early');
        return;
      }
      
      const startHour = parseInt(activeFirstStageStartTime.split(':')[0]);
      const startMinute = parseInt(activeFirstStageStartTime.split(':')[1]);
      console.log(`  Start time: ${startHour}:${startMinute}`);
      
      // Store original time columns before generating hybrid ones
      originalContractionsTimeCols = [...contractionsTimeCols];
      originalBabyBaselineTimeCols = [...babyBaselineTimeCols];
      originalCervixPlotTimeCols = [...cervixPlotTimeCols];
      
      console.log('📊 Original time columns stored for data mapping:');
      console.log(`  Contractions: ${originalContractionsTimeCols.length} columns`);
      console.log(`  FHR: ${originalBabyBaselineTimeCols.length} columns`);
      console.log(`  Cervix Plot: ${originalCervixPlotTimeCols.length} columns`);
      
      // If no second stage, use 30-minute intervals for full 12 hours
      if (!secondStageStartTime || !isSecondStageActive) {
        console.log('📅 No second stage - generating 30-minute intervals only');
        // Keep original 30-minute intervals
        contractionsTimeCols = [];
        babyBaselineTimeCols = [];
        
        for (let i = 0; i <= 24; i++) {
          const totalMinutes = startHour * 60 + startMinute + (i * 30);
          const hour = Math.floor(totalMinutes / 60) % 24;
          const minute = totalMinutes % 60;
          const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
          contractionsTimeCols.push(timeStr);
          babyBaselineTimeCols.push(timeStr);
        }
        
        console.log(`  Generated ${contractionsTimeCols.length} 30-minute intervals:`, contractionsTimeCols);
        return;
      }
      
      console.log('🔄 Second stage active - generating hybrid intervals');
      console.log(`  Starting from first stage time: ${activeFirstStageStartTime}`);
      console.log(`  Switching to 15-min intervals at EXACT second stage time: ${secondStageStartTime}`);
      
      // Create Date objects for proper time comparison across midnight
      const baseDate = new Date('2024-01-01');
      const startTimeDate = createTimeDate(activeFirstStageStartTime, baseDate);
      const secondStageDate = createTimeDate(secondStageStartTime, baseDate);
      
      // If second stage is earlier than first stage, it means it's the next day
      if (secondStageDate < startTimeDate) {
        secondStageDate.setDate(secondStageDate.getDate() + 1);
      }
      
      console.log(`  First stage start: ${startTimeDate.toTimeString().slice(0, 5)}`);
      console.log(`  Second stage start (EXACT): ${secondStageDate.toTimeString().slice(0, 5)}`);
      
      // Generate hybrid contractions time columns
      contractionsTimeCols = [];
      
      // Phase 1: Generate 30-minute intervals up to (but not including) second stage time
      let currentTime = new Date(startTimeDate);
      while (currentTime < secondStageDate) {
        const timeStr = currentTime.toTimeString().slice(0, 5);
        contractionsTimeCols.push(timeStr);
        console.log(`  Added ${timeStr} (30-min interval, before second stage)`);
        currentTime.setMinutes(currentTime.getMinutes() + 30);
      }
      
      // Phase 2: Add the EXACT second stage time
      const exactSecondStageTime = secondStageDate.toTimeString().slice(0, 5);
      contractionsTimeCols.push(exactSecondStageTime);
      console.log(`  Added ${exactSecondStageTime} (EXACT second stage time)`);
      
      // Phase 3: Continue with 15-minute intervals for 4 hours after second stage
      currentTime = new Date(secondStageDate);
      currentTime.setMinutes(currentTime.getMinutes() + 15); // Start 15 minutes after second stage
      const endTime = new Date(secondStageDate);
      endTime.setHours(endTime.getHours() + 4); // 4 hours after second stage
      
      while (currentTime <= endTime) {
        const timeStr = currentTime.toTimeString().slice(0, 5);
        contractionsTimeCols.push(timeStr);
        console.log(`  Added ${timeStr} (15-min interval, after second stage)`);
        currentTime.setMinutes(currentTime.getMinutes() + 15);
      }
      
      // Generate hybrid FHR time columns (same logic as contractions)
      babyBaselineTimeCols = [];
      
      // Phase 1: Generate 30-minute intervals up to (but not including) second stage time
      currentTime = new Date(startTimeDate);
      while (currentTime < secondStageDate) {
        const timeStr = currentTime.toTimeString().slice(0, 5);
        babyBaselineTimeCols.push(timeStr);
        console.log(`  FHR: Added ${timeStr} (30-min interval, before second stage)`);
        currentTime.setMinutes(currentTime.getMinutes() + 30);
      }
      
      // Phase 2: Add the EXACT second stage time
      babyBaselineTimeCols.push(exactSecondStageTime);
      console.log(`  FHR: Added ${exactSecondStageTime} (EXACT second stage time)`);
      
      // Phase 3: Continue with 15-minute intervals for 4 hours after second stage
      currentTime = new Date(secondStageDate);
      currentTime.setMinutes(currentTime.getMinutes() + 15); // Start 15 minutes after second stage
      
      while (currentTime <= endTime) {
        const timeStr = currentTime.toTimeString().slice(0, 5);
        babyBaselineTimeCols.push(timeStr);
        console.log(`  FHR: Added ${timeStr} (15-min interval, after second stage)`);
        currentTime.setMinutes(currentTime.getMinutes() + 15);
      }
      
      // Generate hybrid cervix plot time columns (same logic as contractions)
      cervixPlotTimeCols = [];
      
      // Phase 1: Generate 1-hour intervals up to (but not including) second stage time
      currentTime = new Date(startTimeDate);
      while (currentTime < secondStageDate) {
        const timeStr = currentTime.toTimeString().slice(0, 5);
        cervixPlotTimeCols.push(timeStr);
        console.log(`  Cervix: Added ${timeStr} (1-hour interval, before second stage)`);
        currentTime.setHours(currentTime.getHours() + 1);
      }
      
      // Phase 2: Add the EXACT second stage time
      cervixPlotTimeCols.push(exactSecondStageTime);
      console.log(`  Cervix: Added ${exactSecondStageTime} (EXACT second stage time)`);
      
      // Phase 3: Continue with 15-minute intervals for 4 hours after second stage
      currentTime = new Date(secondStageDate);
      currentTime.setMinutes(currentTime.getMinutes() + 15); // Start 15 minutes after second stage
      
      while (currentTime <= endTime) {
        const timeStr = currentTime.toTimeString().slice(0, 5);
        cervixPlotTimeCols.push(timeStr);
        console.log(`  Cervix: Added ${timeStr} (15-min interval, after second stage)`);
        currentTime.setMinutes(currentTime.getMinutes() + 15);
      }
      
      // Generate other time columns that DON'T switch to 15-minute intervals
      // These should use the original generateDynamicTimeColumns logic
      generateOtherTimeColumns();
      
      console.log('✅ Generated hybrid time columns:');
      console.log(`  Contractions: ${contractionsTimeCols.length} intervals:`, contractionsTimeCols);
      console.log(`  FHR: ${babyBaselineTimeCols.length} intervals:`, babyBaselineTimeCols);
      console.log(`  Cervix Plot: ${cervixPlotTimeCols.length} intervals:`, cervixPlotTimeCols);
      console.log(`  Other tables: Using original intervals (1-hour, 2-hour, 30-min)`);
      console.log(`  Second stage starts at: ${secondStageStartTime}`);
      console.log(`  Start time: ${startTimeDate.toTimeString().slice(0, 5)}`);
      console.log(`  Second stage: ${secondStageDate.toTimeString().slice(0, 5)}`);
    }
    
    // Generate other time columns that DON'T switch to 15-minute intervals
    function generateOtherTimeColumns() {
      console.log('🚀 generateOtherTimeColumns() called');
      console.log(`  activeFirstStageStartTime: ${activeFirstStageStartTime}`);
      
      if (!activeFirstStageStartTime) {
        console.log('❌ No activeFirstStageStartTime, returning early');
        return;
      }
      
      const startHour = parseInt(activeFirstStageStartTime.split(':')[0]);
      const startMinute = parseInt(activeFirstStageStartTime.split(':')[1]);
      console.log(`  Start time: ${startHour}:${startMinute}`);
      
      // Helper function to generate time columns with exact second stage time included
      const generateWithSecondStage = () => {
        const timeCols = [];
        const startTimeDate = new Date(`2000-01-01T${activeFirstStageStartTime}:00`);
        const endTimeDate = new Date(startTimeDate);
        endTimeDate.setHours(endTimeDate.getHours() + 12); // 12-hour horizon
        
        let currentTime = new Date(startTimeDate);
        
        // Add exact second stage time if it exists
        if (secondStageStartTime && isSecondStageActive) {
          const secondStageDate = new Date(`2000-01-01T${secondStageStartTime}:00`);
          const exactSecondStageTime = secondStageStartTime;
          
          // Generate 1-hour intervals up to (but not including) second stage
          while (currentTime < secondStageDate) {
            const timeStr = currentTime.toTimeString().slice(0, 5);
            timeCols.push(timeStr);
            currentTime.setHours(currentTime.getHours() + 1);
          }
          
          // Add the EXACT second stage time
          timeCols.push(exactSecondStageTime);
          console.log(`  Added ${exactSecondStageTime} (EXACT second stage time)`);
          
          // Continue 1-hour intervals after second stage
          currentTime = new Date(secondStageDate);
          currentTime.setHours(currentTime.getHours() + 1);
        }
        
        // Generate remaining 1-hour intervals
        while (currentTime <= endTimeDate) {
          const timeStr = currentTime.toTimeString().slice(0, 5);
          timeCols.push(timeStr);
          currentTime.setHours(currentTime.getHours() + 1);
        }
        
        return timeCols;
      };
      
      // Generate time columns with second stage support
      supportiveCareTimeCols = generateWithSecondStage();
      babyOtherTimeCols = generateWithSecondStage();
      womanTimeCols = generateWithSecondStage();
      medicationTimeCols = generateWithSecondStage();
      assessmentTimeCols = generateWithSecondStage();
      initialsTimeCols = generateWithSecondStage();
      descentPlotTimeCols = generateWithSecondStage();
      
      // Plan: +2 hour intervals for 12 hours
      planTimeCols = [];
      for (let i = 0; i <= 6; i++) {
        const hour = (startHour + (i * 2)) % 24;
        const timeStr = `${hour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`;
        planTimeCols.push(timeStr);
      }
      
      console.log('✅ Generated other time columns:');
      console.log(`  Supportive Care: ${supportiveCareTimeCols.length} intervals (1-hour)`);
      console.log(`  Baby Other: ${babyOtherTimeCols.length} intervals (1-hour)`);
      console.log(`  Woman: ${womanTimeCols.length} intervals (1-hour)`);
      console.log(`  Medication: ${medicationTimeCols.length} intervals (1-hour)`);
      console.log(`  Assessment: ${assessmentTimeCols.length} intervals (1-hour)`);
      console.log(`  Initials: ${initialsTimeCols.length} intervals (1-hour)`);
      console.log(`  Descent Plot: ${descentPlotTimeCols.length} intervals (1-hour)`);
      console.log(`  Plan: ${planTimeCols.length} intervals (2-hour)`);
    }
      
      // Verify the arrays are actually populated
      console.log('🔍 Verification - contractionsTimeCols array:', contractionsTimeCols);
      console.log('🔍 Verification - babyBaselineTimeCols array:', babyBaselineTimeCols);
      console.log('🔍 Verification - cervixPlotTimeCols array:', cervixPlotTimeCols);
      console.log('🔍 Verification - contractionsTimeCols type:', typeof contractionsTimeCols);
      console.log('🔍 Verification - babyBaselineTimeCols type:', typeof babyBaselineTimeCols);
      console.log('🔍 Verification - cervixPlotTimeCols type:', typeof cervixPlotTimeCols);
      
      // Verify the hybrid nature
      const beforeSecondStage = contractionsTimeCols.filter(time => {
        const [hours, minutes] = time.split(':').map(Number);
        const timeMinutes = hours * 60 + minutes;
        const [secondStageHours, secondStageMinutes] = secondStageStartTime.split(':').map(Number);
        const secondStageTotalMinutes = secondStageHours * 60 + secondStageMinutes;
        const [startHours, startMinutes] = activeFirstStageStartTime.split(':').map(Number);
        const startTotalMinutes = startHours * 60 + startMinutes;
        
        // Calculate relative minutes from start time
        let timeRelativeMinutes = timeMinutes - startTotalMinutes;
        let secondStageRelativeMinutes = secondStageTotalMinutes - startTotalMinutes;
        
        // Handle midnight crossing
        if (timeRelativeMinutes < 0) timeRelativeMinutes += 24 * 60;
        if (secondStageRelativeMinutes < 0) secondStageRelativeMinutes += 24 * 60;
        
        return timeRelativeMinutes < secondStageRelativeMinutes;
      });
      const afterSecondStage = contractionsTimeCols.filter(time => {
        const [hours, minutes] = time.split(':').map(Number);
        const timeMinutes = hours * 60 + minutes;
        const [secondStageHours, secondStageMinutes] = secondStageStartTime.split(':').map(Number);
        const secondStageTotalMinutes = secondStageHours * 60 + secondStageMinutes;
        const [startHours, startMinutes] = activeFirstStageStartTime.split(':').map(Number);
        const startTotalMinutes = startHours * 60 + startMinutes;
        
        // Calculate relative minutes from start time
        let timeRelativeMinutes = timeMinutes - startTotalMinutes;
        let secondStageRelativeMinutes = secondStageTotalMinutes - startTotalMinutes;
        
        // Handle midnight crossing
        if (timeRelativeMinutes < 0) timeRelativeMinutes += 24 * 60;
        if (secondStageRelativeMinutes < 0) secondStageRelativeMinutes += 24 * 60;
        
        return timeRelativeMinutes >= secondStageRelativeMinutes;
      });
      console.log(`  Before second stage: ${beforeSecondStage.length} columns (30-min intervals)`);
      console.log(`  After second stage: ${afterSecondStage.length} columns (15-min intervals)`);
      
      // Verify cervix plot hybrid nature
      const cervixBeforeSecondStage = cervixPlotTimeCols.filter(time => {
        const [hours, minutes] = time.split(':').map(Number);
        const timeMinutes = hours * 60 + minutes;
        const [secondStageHours, secondStageMinutes] = secondStageStartTime.split(':').map(Number);
        const secondStageTotalMinutes = secondStageHours * 60 + secondStageMinutes;
        const [startHours, startMinutes] = activeFirstStageStartTime.split(':').map(Number);
        const startTotalMinutes = startHours * 60 + startMinutes;
        
        // Calculate relative minutes from start time
        let timeRelativeMinutes = timeMinutes - startTotalMinutes;
        let secondStageRelativeMinutes = secondStageTotalMinutes - startTotalMinutes;
        
        // Handle midnight crossing
        if (timeRelativeMinutes < 0) timeRelativeMinutes += 24 * 60;
        if (secondStageRelativeMinutes < 0) secondStageRelativeMinutes += 24 * 60;
        
        return timeRelativeMinutes < secondStageRelativeMinutes;
      });
      const cervixAfterSecondStage = cervixPlotTimeCols.filter(time => {
        const [hours, minutes] = time.split(':').map(Number);
        const timeMinutes = hours * 60 + minutes;
        const [secondStageHours, secondStageMinutes] = secondStageStartTime.split(':').map(Number);
        const secondStageTotalMinutes = secondStageHours * 60 + secondStageMinutes;
        const [startHours, startMinutes] = activeFirstStageStartTime.split(':').map(Number);
        const startTotalMinutes = startHours * 60 + startMinutes;
        
        // Calculate relative minutes from start time
        let timeRelativeMinutes = timeMinutes - startTotalMinutes;
        let secondStageRelativeMinutes = secondStageTotalMinutes - startTotalMinutes;
        
        // Handle midnight crossing
        if (timeRelativeMinutes < 0) timeRelativeMinutes += 24 * 60;
        if (secondStageRelativeMinutes < 0) secondStageRelativeMinutes += 24 * 60;
        
        return timeRelativeMinutes >= secondStageRelativeMinutes;
      });
      console.log(`  Cervix Before second stage: ${cervixBeforeSecondStage.length} columns (1-hour intervals)`);
      console.log(`  Cervix After second stage: ${cervixAfterSecondStage.length} columns (15-min intervals)`);
    
    // Confirm second stage
    function confirmSecondStage() {
      console.log('🚀 confirmSecondStage() called');
      
      const secondStageInput = document.getElementById('secondStageTime');
      const secondStageTime = secondStageInput.value;
      
      console.log(`  Second stage time input: ${secondStageTime}`);
      console.log(`  Active first stage time: ${activeFirstStageStartTime}`);
      
      if (!secondStageTime) {
        alert('Please enter the second stage start time first.');
        return;
      }
      
      if (!activeFirstStageStartTime) {
        alert('Please set the active first stage start time first.');
        return;
      }
      
      // Validate that second stage is after first stage (handle midnight crossing)
      const firstTime = new Date(`2000-01-01T${activeFirstStageStartTime}:00`);
      const secondTime = new Date(`2000-01-01T${secondStageTime}:00`);
      
      // Calculate time difference in minutes, handling midnight crossing
      let timeDiffMinutes = (secondTime - firstTime) / (1000 * 60);
      
      // If second time is earlier in the day, it means it's the next day
      if (timeDiffMinutes < 0) {
        timeDiffMinutes += 24 * 60; // Add 24 hours (1440 minutes)
      }
      
      console.log(`  Time difference: ${timeDiffMinutes} minutes`);
      
      // Second stage must be at least 30 minutes after first stage
      if (timeDiffMinutes < 30) {
        alert('Second stage must start at least 30 minutes after the active first stage start time.');
        return;
      }
      
      console.log('✅ Validation passed, setting second stage...');
      
      secondStageStartTime = secondStageTime;
      isSecondStageActive = true;
      
      console.log(`  secondStageStartTime set to: ${secondStageStartTime}`);
      console.log(`  isSecondStageActive set to: ${isSecondStageActive}`);
      
      // Show second stage card
      document.getElementById('secondStageCard').style.display = 'block';
      
      // Hide the second stage controls (button disappears)
      document.getElementById('secondStageControls').style.display = 'none';
      
      // Update display
      const firstStageDuration = Math.round((secondTime - firstTime) / (1000 * 60));
      document.getElementById('firstStageDuration').textContent = `${firstStageDuration} minutes`;
      document.getElementById('secondStageStartDisplay').textContent = secondStageTime;
      
      // Save the second stage time
      saveSecondStageData();
      
      // Lock the second stage time input
      lockTimeInput("secondStageTime", "Second Stage Start Time");
      
      console.log('🔄 Generating hybrid time columns...');
      
      // Generate hybrid time columns (30-min before, 15-min after second stage)
      generateHybridTimeColumns();
      
      console.log('🔄 Regenerating contractions and FHR tables...');
      
      // Collect existing data before regenerating tables
      const currentFormData = {};
      const currentInputs = document.querySelectorAll('input, select');
      currentInputs.forEach(input => {
        if (input.name && input.value) {
          currentFormData[input.name] = input.value;
        }
      });
      
      // Regenerate only contractions and FHR tables with hybrid time columns
      regenerateContractionsAndFHRTables(currentFormData);
      
      console.log('🎨 Updating second stage colors...');
      
      // Update colors for all tables (including the new hybrid columns)
      updateSecondStageColors();
      
      console.log('🔄 Force refreshing all tables...');
      
      // Force refresh of all tables to ensure hybrid columns are displayed
      // But preserve existing data by collecting it first
      const refreshData = {};
      const refreshInputs = document.querySelectorAll('input, select');
      refreshInputs.forEach(input => {
        if (input.name && input.value) {
          refreshData[input.name] = input.value;
        }
      });
      
      setTimeout(() => {
        generateSummaryTable(refreshData);
        updateSecondStageColors();
      }, 200);
      
      // Show success message
      showSaveSuccess();
      
      console.log('✅ Second stage confirmed with hybrid time columns');
    }
    
    // Update second stage colors without regenerating tables
    function updateSecondStageColors() {
      console.log('🎨 updateSecondStageColors() called');
      console.log(`  secondStageStartTime: ${secondStageStartTime}`);
      console.log(`  isSecondStageActive: ${isSecondStageActive}`);
      
      // Update time header colors in all tables
      const allTimeHeaders = document.querySelectorAll('.time-header');
      console.log(`  Found ${allTimeHeaders.length} time headers to update`);
      
      allTimeHeaders.forEach((header, index) => {
        const timeText = header.textContent;
        const isSecondStage = isSecondStageTime(timeText);
        console.log(`  Header ${index}: "${timeText}" - isSecondStage: ${isSecondStage}`);
        
        if (isSecondStage) {
          header.style.setProperty('background-color', '#dcfce7', 'important'); // Light green for second stage
          header.style.setProperty('color', '#166534', 'important'); // Dark green text
          console.log(`🟢 Updated ${timeText} to second stage colors`);
        } else {
          header.style.setProperty('background-color', '#dbeafe', 'important'); // Light blue for first stage
          header.style.setProperty('color', '#1e40af', 'important'); // Dark blue text
          console.log(`🔵 Updated ${timeText} to first stage colors`);
        }
      });
      
      // Also update the medication table CSS class
      const medicationTable = document.getElementById('medicationTable');
      if (medicationTable && secondStageStartTime && isSecondStageActive) {
        medicationTable.classList.add('second-stage-active');
        console.log('🟢 Added second-stage-active class to medication table');
      }
      
      console.log('✅ Second stage colors updated without data loss');
    }
    
    // Save second stage data to Firestore
    async function saveSecondStageData() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) {
          console.error('No patient ID found in URL');
          return;
        }
        
        const secondStageData = {
          secondStageStartTime: secondStageStartTime,
          isSecondStageActive: isSecondStageActive,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('records')
          .doc('secondStage')
          .set(secondStageData);
        
        console.log('Second stage data saved successfully');

        // Update patient status to Postnatal Care
        const statusUpdated = await StatusManager.checkAndUpdateToPostnatalCare(
          patientId, 
          'Second stage time recorded'
        );
        if (statusUpdated) {
          console.log('✅ Patient status updated to Postnatal Care');
        }
      } catch (error) {
        console.error('Error saving second stage data:', error);
      }
    }
    
    // Load second stage data from Firestore
    async function loadSecondStageData() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        const doc = await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('records')
          .doc('secondStage')
          .get();
        
        if (doc.exists) {
          const data = doc.data();
          secondStageStartTime = data.secondStageStartTime;
          isSecondStageActive = data.isSecondStageActive;
          
          if (isSecondStageActive && secondStageStartTime) {
            // Show second stage card
            document.getElementById('secondStageCard').style.display = 'block';
            
            // Update display
            if (activeFirstStageStartTime) {
              const firstTime = new Date(`2000-01-01T${activeFirstStageStartTime}:00`);
              const secondTime = new Date(`2000-01-01T${secondStageStartTime}:00`);
              const firstStageDuration = Math.round((secondTime - firstTime) / (1000 * 60));
              
              document.getElementById('firstStageDuration').textContent = `${firstStageDuration} minutes`;
              document.getElementById('secondStageStartDisplay').textContent = secondStageStartTime;
            }
            
            // Lock the second stage time input
            lockTimeInput("secondStageTime", "Second Stage Start Time");
            
            // Generate hybrid time columns for second stage
            generateHybridTimeColumns();
            
            console.log('🔄 Regenerating tables with hybrid time columns in loadSecondStageData...');
            
            // Regenerate the summary table to use the new hybrid time columns
            // We need to get the existing data first
            try {
              const recordsDoc = await firebase.firestore()
                .collection("patients")
                .doc(patientId)
                .collection("records")
                .doc("summary")
                .get();
              
              let existingData = {};
              if (recordsDoc.exists) {
                existingData = recordsDoc.data();
              }
              
              // Regenerate tables with existing data and hybrid time columns
              generateSummaryTable(existingData);
              
              // Update colors for all tables after generating hybrid columns
              setTimeout(() => {
                updateSecondStageColors();
              }, 100);
            } catch (error) {
              console.error('Error regenerating tables with hybrid time columns:', error);
            }
          }
        }
      } catch (error) {
        console.error('Error loading second stage data:', error);
      }
    }
    
    // Save starting time data
    async function saveStartingTime() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) {
          console.error('No patient ID found in URL');
          return;
        }
        
        await firebase.firestore()
          .collection("patients")
          .doc(patientId)
          .collection("records")
          .doc("startingTime")
          .set({
            startingTime: activeFirstStageStartTime,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
        
        console.log('Starting time saved successfully');

        // Update patient status to Labour Care
        const statusUpdated = await StatusManager.checkAndUpdateToLabourCare(patientId);
        if (statusUpdated) {
          console.log('✅ Patient status updated to Labour Care');
        }
      } catch (error) {
        console.error("Error saving starting time:", error);
      }
    }
    
    // Preserve existing data when starting time changes
    function preserveExistingData() {
      const existingData = {};
      
      // Collect all existing form data before regenerating tables
      const allInputs = document.querySelectorAll('input, select');
      allInputs.forEach(input => {
        if (input.name && input.value) {
          existingData[input.name] = input.value;
        }
      });
      
      return existingData;
    }
    
    // Map existing data to new time columns when intervals change
    function mapDataToNewIntervals(existingData, oldTimeCols, newTimeCols, fieldPrefix) {
      console.log(`🔄 Mapping data for ${fieldPrefix} from ${oldTimeCols.length} to ${newTimeCols.length} time columns`);
      
      if (oldTimeCols.length === 0) {
        console.log(`⚠️ No old time columns for ${fieldPrefix}, skipping mapping`);
        return existingData;
      }
      
      const mappedData = {};
      
      // For each new time column, find the closest old time column
      newTimeCols.forEach(newTime => {
        const newTimeMinutes = convertTimeToMinutes(newTime);
        
        // Find the closest old time column
        let closestOldTime = null;
        let minDifference = Infinity;
        
        oldTimeCols.forEach(oldTime => {
          const oldTimeMinutes = convertTimeToMinutes(oldTime);
          const difference = Math.abs(newTimeMinutes - oldTimeMinutes);
          
          if (difference < minDifference) {
            minDifference = difference;
            closestOldTime = oldTime;
          }
        });
        
        // If we found a close match (within 30 minutes), map the data
        if (closestOldTime && minDifference <= 30) {
          console.log(`  Mapping ${fieldPrefix} data from ${closestOldTime} to ${newTime} (diff: ${minDifference}min)`);
          
          // Map all field values for this time
          Object.keys(existingData).forEach(key => {
            if (key.includes(fieldPrefix) && key.includes(closestOldTime.replace(':', '_'))) {
              // Create new key with new time
              const newKey = key.replace(closestOldTime.replace(':', '_'), newTime.replace(':', '_'));
              mappedData[newKey] = existingData[key];
              console.log(`    ${key} → ${newKey} = ${existingData[key]}`);
            }
          });
        }
      });
      
      // Also preserve any data that doesn't need mapping (non-time-based data)
      Object.keys(existingData).forEach(key => {
        if (!key.includes(fieldPrefix) || !key.includes('_')) {
          mappedData[key] = existingData[key];
        }
      });
      
      console.log(`✅ Mapped ${Object.keys(mappedData).length} fields for ${fieldPrefix}`);
      return mappedData;
    }
    
    // Helper function to convert time string to minutes since midnight
    function convertTimeToMinutes(timeStr) {
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    }
    
    // Regenerate only contractions and FHR tables with hybrid time columns
    function regenerateContractionsAndFHRTables(existingData = null) {
      console.log('🔄 Regenerating contractions and FHR tables with hybrid time columns...');
      
      // Get existing data from Firestore (not just current DOM)
      // We need to preserve all data, not just what's currently in the form
      let dataToUse = existingData || {};
      
      // If no existing data provided, try to get from current DOM elements
      if (!existingData) {
        const allInputs = document.querySelectorAll('input, select');
        allInputs.forEach(input => {
          if (input.name && input.value) {
            dataToUse[input.name] = input.value;
          }
        });
      }
      
      // If we don't have much data from DOM, we need to get it from the saved data
      if (Object.keys(dataToUse).length < 10) {
        console.log('📊 Limited data available, will use what we have');
      }
      
      console.log('📊 Preserving existing data:', Object.keys(dataToUse).length, 'fields');
      console.log('📊 Sample data keys:', Object.keys(dataToUse).slice(0, 10));
      
      // Map data to new time intervals if we're switching to hybrid columns
      if (secondStageStartTime && isSecondStageActive) {
        console.log('🔄 Second stage active - mapping data to hybrid intervals...');
        
        // Use the stored original time columns for mapping
        console.log('📊 Using stored original time columns for mapping:');
        console.log(`  Original Contractions: ${originalContractionsTimeCols.length} columns`);
        console.log(`  Original FHR: ${originalBabyBaselineTimeCols.length} columns`);
        console.log(`  Original Cervix Plot: ${originalCervixPlotTimeCols.length} columns`);
        
        // Map data for each section
        dataToUse = mapDataToNewIntervals(dataToUse, originalContractionsTimeCols, contractionsTimeCols, 'Contractions');
        dataToUse = mapDataToNewIntervals(dataToUse, originalBabyBaselineTimeCols, babyBaselineTimeCols, 'Baseline_FHR');
        dataToUse = mapDataToNewIntervals(dataToUse, originalBabyBaselineTimeCols, babyBaselineTimeCols, 'FHR_deceleration');
        dataToUse = mapDataToNewIntervals(dataToUse, originalCervixPlotTimeCols, cervixPlotTimeCols, 'Cervix_Plot');
      }
      
      // Clear only contractions and FHR tables
      document.getElementById("contractionsTable").innerHTML = "";
      document.getElementById("fhrTable").innerHTML = "";
      document.getElementById("cervixPlotTable").innerHTML = "";
      
      // Generate tables with hybrid time columns and existing data
      generateSectionTable("Contractions", sections["Contractions"], "contractionsTable", dataToUse);
      generateSectionTable("FHR", sections["FHR"], "fhrTable", dataToUse);
      generateCervixPlotTable("cervixPlotTable", dataToUse);
      
      // Add event listeners for the new tables
      addFormEventListeners();
      
      console.log('✅ Contractions and FHR tables regenerated with hybrid time columns and preserved data');
      console.log('📊 Final data check - cervix plot inputs:', document.querySelectorAll('#cervixPlotTable select').length);
    }
    
    // Regenerate all tables (used when second stage is confirmed)
    function regenerateAllTables() {
      // This function should NOT be called for second stage confirmation
      // It's only for when we actually need to regenerate tables
      console.warn('⚠️ regenerateAllTables() called - this should not happen for second stage');
      
      // Clear existing tables
      document.getElementById("supportiveCareTable").innerHTML = "";
      document.getElementById("babyTable").innerHTML = "";
      document.getElementById("contractionsTable").innerHTML = "";
      document.getElementById("medicationTable").innerHTML = "";
      document.getElementById("decisionMakingTable").innerHTML = "";
      document.getElementById("initialsTable").innerHTML = "";
      
      // Generate tables with empty data (fresh start)
      generateSummaryTable({});
      
      // Re-initialize plotting charts
      setTimeout(() => {
        initializePlottingCharts();
        loadPlotData();
      }, 100);
      
      // Add event listeners again
      addFormEventListeners();
    }
    
    // Regenerate all tables with preserved data
    function regenerateAllTablesWithData(preservedData) {
      // Clear existing tables
      document.getElementById('supportiveCareTable').innerHTML = '';
      document.getElementById('babyTable').innerHTML = '';
      document.getElementById('womanTable').innerHTML = '';
      document.getElementById('contractionsTable').innerHTML = '';
      document.getElementById('cervixPlotTable').innerHTML = '';
      document.getElementById('descentPlotTable').innerHTML = '';
      document.getElementById('medicationTable').innerHTML = '';
      document.getElementById('decisionMakingTable').innerHTML = '';
      document.getElementById('initialsTable').innerHTML = '';
      
      // Regenerate tables with preserved data
      generateSummaryTable(preservedData);
    }

    // Generate Cervix Plot table with partograph structure
    function generateCervixPlotTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Create table header
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      
      // Field header
      const fieldHeader = document.createElement("th");
      fieldHeader.className = "field-header sticky-field";
      fieldHeader.textContent = "Cervix [Plot X]";
      headerRow.appendChild(fieldHeader);
      
      // Alert header
      const alertHeader = document.createElement("th");
      alertHeader.className = "alert-header sticky-alert";
      alertHeader.textContent = "Alert";
      headerRow.appendChild(alertHeader);
      
      // Time headers (1-hour intervals with second stage highlighting)
      cervixPlotTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        headerRow.appendChild(timeHeader);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement("tbody");
      
      // Create rows for each cervix value (10cm to 5cm)
      const cervixValues = ["10", "9", "8", "7", "6", "5"];
      const timeThresholds = ["", "≥ 2h", "≥ 2.5h", "≥ 3h", "≥ 5h", "≥ 6h"];
      
      cervixValues.forEach((value, index) => {
        const row = document.createElement("tr");
        
        // Field cell with value
        const fieldCell = document.createElement("td");
        fieldCell.className = "field-cell sticky-field";
        fieldCell.style.backgroundColor = "#f8f9fa"; // Light gray background
        fieldCell.style.fontWeight = "bold";
        fieldCell.textContent = value;
        row.appendChild(fieldCell);
        
        // Alert cell with threshold
        const alertCell = document.createElement("td");
        alertCell.className = "alert-cell sticky-alert";
        alertCell.style.backgroundColor = "#f8f9fa"; // Light gray background
        alertCell.innerHTML = `<span class="alert-value">${timeThresholds[index]}</span>`;
        row.appendChild(alertCell);
        
        // Time cells for this cervix value
        cervixPlotTimeCols.forEach(time => {
          const timeCell = document.createElement("td");
          timeCell.className = "time-cell";
          timeCell.style.textAlign = "center";
          
          const timeKey = time.replace(':', '_');
          const key = `Cervix_Plot_${value}_${timeKey}`;
          const savedValue = existing[key] || "";
          
          // Create dropdown with "", "X", and "P" options
          const select = document.createElement("select");
          select.name = key;
          select.className = "form-select form-select-sm";
          
          const blankOption = document.createElement("option");
          blankOption.value = "";
          blankOption.textContent = "";
          select.appendChild(blankOption);
          
          const xOption = document.createElement("option");
          xOption.value = "X";
          xOption.textContent = "X";
          select.appendChild(xOption);
          
          const pOption = document.createElement("option");
          pOption.value = "P";
          pOption.textContent = "P";
          select.appendChild(pOption);
          
          select.value = savedValue;
          
          // Check if this cervix plot value should be highlighted as an alert based on time thresholds
          if (checkCervixPlotAlert(value, savedValue, timeKey)) {
            select.classList.add('alert-value');
          }
          
          timeCell.appendChild(select);
          row.appendChild(timeCell);
        });
        
        tbody.appendChild(row);
      });
      
      table.appendChild(tbody);
    }

    // Generate Descent Plot table with partograph structure
    function generateDescentPlotTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // Create table header
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      
      // Field header
      const fieldHeader = document.createElement("th");
      fieldHeader.className = "field-header sticky-field";
      fieldHeader.textContent = "Descent [Plot O]";
      headerRow.appendChild(fieldHeader);
      
      // Time headers (1-hour intervals with second stage highlighting)
      descentPlotTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        headerRow.appendChild(timeHeader);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement("tbody");
      
      // Create rows for each descent value (5 to 0)
      const descentValues = ["5", "4", "3", "2", "1", "0"];
      
      descentValues.forEach((value) => {
        const row = document.createElement("tr");
        
        // Field cell with value
        const fieldCell = document.createElement("td");
        fieldCell.className = "field-cell sticky-field";
        fieldCell.style.backgroundColor = "#f8f9fa"; // Light gray background
        fieldCell.style.fontWeight = "bold";
        fieldCell.textContent = value;
        row.appendChild(fieldCell);
        
        // Time cells for this descent value
        descentPlotTimeCols.forEach(time => {
          const timeCell = document.createElement("td");
          timeCell.className = "time-cell";
          timeCell.style.textAlign = "center";
          
          const timeKey = time.replace(':', '_');
          const key = `Descent_Plot_${value}_${timeKey}`;
          const savedValue = existing[key] || "";
          
          // Create dropdown with "" and "O" options
          const select = document.createElement("select");
          select.name = key;
          select.className = "form-select form-select-sm";
          
          const blankOption = document.createElement("option");
          blankOption.value = "";
          blankOption.textContent = "";
          select.appendChild(blankOption);
          
          const oOption = document.createElement("option");
          oOption.value = "O";
          oOption.textContent = "O";
          select.appendChild(oOption);
          
          select.value = savedValue;
          timeCell.appendChild(select);
          row.appendChild(timeCell);
        });
        
        tbody.appendChild(row);
      });
      
      table.appendChild(tbody);
    }
    // This function is kept for backward compatibility but is no longer used
    function generateBabyTable(tableId, existing) {
      const table = document.getElementById(tableId);
      
      // ===== FHR TABLE (30-min intervals) =====
      const fhrTable = document.createElement("table");
      fhrTable.className = "summary-table mb-4";
      
      // FHR table header
      const fhrThead = document.createElement("thead");
      const fhrHeaderRow = document.createElement("tr");
      
      // Field header
      const fhrFieldHeader = document.createElement("th");
      fhrFieldHeader.className = "field-header sticky-field";
      fhrFieldHeader.textContent = "Field";
      fhrHeaderRow.appendChild(fhrFieldHeader);
      
      // Alert header
      const fhrAlertHeader = document.createElement("th");
      fhrAlertHeader.className = "alert-header sticky-alert";
      fhrAlertHeader.textContent = "Alert";
      fhrHeaderRow.appendChild(fhrAlertHeader);
      
      // Time headers (30-min intervals with second stage highlighting)
      babyBaselineTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        fhrHeaderRow.appendChild(timeHeader);
      });
      
      fhrThead.appendChild(fhrHeaderRow);
      fhrTable.appendChild(fhrThead);
      
      // FHR table body
      const fhrTbody = document.createElement("tbody");
      
      // Baseline FHR row
      const baselineFHRRow = document.createElement("tr");
      
      // Field cell
      const baselineFHRFieldCell = document.createElement("td");
      baselineFHRFieldCell.className = "field-cell sticky-field";
      baselineFHRFieldCell.textContent = "Baseline FHR";
      baselineFHRRow.appendChild(baselineFHRFieldCell);
      
      // Alert cell
      const baselineFHRAlertCell = document.createElement("td");
      baselineFHRAlertCell.className = "alert-cell sticky-alert";
      baselineFHRAlertCell.innerHTML = '<span class="alert-indicator"><110, ≥160</span>';
      baselineFHRRow.appendChild(baselineFHRAlertCell);
      
      // Time cells for Baseline FHR
      babyBaselineTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `Baseline_FHR_${timeKey}`;
        const value = existing[key] || "";
        
        const input = document.createElement("input");
        input.name = key;
        input.type = "number";
        input.className = "form-control form-control-sm";
        input.placeholder = "FHR";
        input.min = "60";
        input.max = "200";
        input.value = value;
        timeCell.appendChild(input);
        baselineFHRRow.appendChild(timeCell);
      });
      
      fhrTbody.appendChild(baselineFHRRow);
      
      // FHR Deceleration row
      const decelerationRow = document.createElement("tr");
      
      // Field cell
      const decelerationFieldCell = document.createElement("td");
      decelerationFieldCell.className = "field-cell sticky-field";
      decelerationFieldCell.textContent = "FHR deceleration";
      decelerationRow.appendChild(decelerationFieldCell);
      
      // Alert cell
      const decelerationAlertCell = document.createElement("td");
      decelerationAlertCell.className = "alert-cell sticky-alert";
      decelerationAlertCell.innerHTML = '<span class="alert-indicator">L</span>';
      decelerationRow.appendChild(decelerationAlertCell);
      
      // Time cells for FHR deceleration
      babyBaselineTimeCols.forEach(time => {
        const timeCell = document.createElement("td");
        timeCell.className = "time-cell";
        
        const timeKey = time.replace(':', '_');
        const key = `FHR_deceleration_${timeKey}`;
        const value = existing[key] || "";
        
        const select = document.createElement("select");
        select.name = key;
        select.className = "form-select form-select-sm";
        
        const blankOption = document.createElement("option");
        blankOption.value = "";
        blankOption.textContent = "";
        select.appendChild(blankOption);
        
        ["N", "E", "L", "V"].forEach(option => {
          const optionElement = document.createElement("option");
          optionElement.value = option;
          optionElement.textContent = option;
          select.appendChild(optionElement);
        });
        
        select.value = value;
        timeCell.appendChild(select);
        decelerationRow.appendChild(timeCell);
      });
      
      fhrTbody.appendChild(decelerationRow);
      fhrTable.appendChild(fhrTbody);
      
      // ===== BABY TABLE (1-hour intervals) =====
      const babyTable = document.createElement("table");
      babyTable.className = "summary-table";
      
      // Baby table header
      const babyThead = document.createElement("thead");
      const babyHeaderRow = document.createElement("tr");
      
      // Field header
      const babyFieldHeader = document.createElement("th");
      babyFieldHeader.className = "field-header sticky-field";
      babyFieldHeader.textContent = "Field";
      babyHeaderRow.appendChild(babyFieldHeader);
      
      // Alert header
      const babyAlertHeader = document.createElement("th");
      babyAlertHeader.className = "alert-header sticky-alert";
      babyAlertHeader.textContent = "Alert";
      babyHeaderRow.appendChild(babyAlertHeader);
      
      // Time headers (1-hour intervals with second stage highlighting)
      babyOtherTimeCols.forEach(time => {
        const timeHeader = document.createElement("th");
        timeHeader.className = "time-header";
        
        // Apply second stage highlighting
        if (isSecondStageTime(time)) {
          timeHeader.style.backgroundColor = "#dcfce7"; // Light green for second stage
          timeHeader.style.color = "#166534"; // Dark green text
        } else {
          timeHeader.style.backgroundColor = "#dbeafe"; // Light blue for first stage
          timeHeader.style.color = "#1e40af"; // Dark blue text
        }
        
        timeHeader.textContent = time;
        babyHeaderRow.appendChild(timeHeader);
      });
      
      babyThead.appendChild(babyHeaderRow);
      babyTable.appendChild(babyThead);
      
      // Baby table body
      const babyTbody = document.createElement("tbody");
      
      // Baby fields
      const babyFields = ["Amniotic fluid", "Fetal position", "Caput", "Moulding"];
      
      babyFields.forEach(field => {
        const row = document.createElement("tr");
        
        // Field cell
        const fieldCell = document.createElement("td");
        fieldCell.className = "field-cell sticky-field";
        fieldCell.textContent = field;
        row.appendChild(fieldCell);
        
        // Alert cell
        const alertCell = document.createElement("td");
        alertCell.className = "alert-cell sticky-alert";
        const alertValue = whoAlertValues[field] || "";
        alertCell.innerHTML = `<span class="alert-indicator">${alertValue}</span>`;
        row.appendChild(alertCell);
        
        // Time cells
        babyOtherTimeCols.forEach(time => {
          const timeCell = document.createElement("td");
          timeCell.className = "time-cell";
          
          const timeKey = time.replace(':', '_');
          const key = `${field.replace(/\s+/g, "_")}_${timeKey}`;
          const value = existing[key] || "";
          
          const select = document.createElement("select");
          select.name = key;
          select.className = "form-select form-select-sm";
          
          const blankOption = document.createElement("option");
          blankOption.value = "";
          blankOption.textContent = "";
          select.appendChild(blankOption);
          
          // Add options based on field
          let options = [];
          switch(field) {
            case "Amniotic fluid":
              options = ["I", "C", "M", "M+", "M++", "M+++", "B"];
              break;
            case "Fetal position":
              options = ["A", "P", "T"];
              break;
            case "Caput":
            case "Moulding":
              options = ["0", "+", "++", "+++"];
              break;
          }
          
          options.forEach(option => {
            const optionElement = document.createElement("option");
            optionElement.value = option;
            optionElement.textContent = option;
            select.appendChild(optionElement);
          });
          
          select.value = value;
          timeCell.appendChild(select);
          row.appendChild(timeCell);
        });
        
        babyTbody.appendChild(row);
      });
      
      babyTable.appendChild(babyTbody);
      
      // Add both tables to the main container
      table.appendChild(fhrTable);
      table.appendChild(babyTable);
    }

    // Hide all tables initially
    function hideAllTables() {
      const allSections = [
        'supportiveCareSection', 'fhrSection', 'babySection', 'womanSection', 'contractionsSection', 'cervixPlotSection', 'descentPlotSection', 
        'medicationSection', 'decisionMakingSection', 'initialsSection'
      ];
      
      allSections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) {
          section.style.display = 'none';
        }
      });
      
      // Also hide second stage card and clinical recommendations
      const secondStageCard = document.getElementById('secondStageCard');
      if (secondStageCard) {
        secondStageCard.style.display = 'none';
      }
      
      const recommendationsSection = document.querySelector('.recommendations-section');
      if (recommendationsSection) {
        recommendationsSection.style.display = 'none';
      }
    }

    // Show all tables after starting time is set
    function showAllTables() {
      const allSections = [
        'supportiveCareSection', 'fhrSection', 'babySection', 'womanSection', 'contractionsSection', 'cervixPlotSection', 'descentPlotSection', 
        'medicationSection', 'decisionMakingSection', 'initialsSection'
      ];
      
      allSections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) {
          section.style.display = 'block';
        }
      });
      
      // Show clinical recommendations
      const recommendationsSection = document.querySelector('.recommendations-section');
      if (recommendationsSection) {
        recommendationsSection.style.display = 'block';
      }
      
      // Recommendations will be shown when needed, not automatically
    }

    // Show starting time requirement message
    function showStartingTimeRequirement() {
      const requirementDiv = document.getElementById('startingTimeRequirement');
      if (requirementDiv) {
        requirementDiv.style.display = 'block';
      }
    }

    // Lock time input fields to prevent changes after initial input
    function lockTimeInput(inputId, fieldName) {
      const input = document.getElementById(inputId);
      if (!input) return;
      
      // Don't lock if the input is empty or has no meaningful value
      if (!input.value || input.value.trim() === '') {
        console.log(`⚠️ ${fieldName} has no value, not locking`);
        return;
      }
      
      // Check if already locked
      if (isInputLocked(inputId)) {
        console.log(`🔒 ${fieldName} is already locked`);
        return;
      }
      
      // Disable the input
      input.disabled = true;
      input.readOnly = true;
      
      // Add visual styling to show it's locked
      input.classList.add('locked-input');
      input.style.backgroundColor = '#f8f9fa';
      input.style.color = '#6c757d';
      input.style.cursor = 'not-allowed';
      
      // Add a lock icon and "Locked" text
      const lockIcon = document.createElement('div');
      lockIcon.className = 'lock-indicator';
      lockIcon.innerHTML = '<i class="fas fa-lock"></i> Locked';
      lockIcon.style.cssText = `
        position: absolute;
        top: 50%;
        right: 10px;
        transform: translateY(-50%);
        color: #6c757d;
        font-size: 12px;
        pointer-events: none;
        z-index: 10;
      `;
      
      // Make the parent container relative positioned if it isn't already
      const parent = input.parentElement;
      if (parent.style.position !== 'relative') {
        parent.style.position = 'relative';
      }
      
      // Remove any existing lock indicators
      const existingLock = parent.querySelector('.lock-indicator');
      if (existingLock) {
        existingLock.remove();
      }
      
      // Add the lock indicator
      parent.appendChild(lockIcon);
      
      // Note: Help text removed as requested by user
      
      // Add a locked badge to the label if it exists
      const label = input.parentElement.querySelector('label');
      if (label) {
        const lockedBadge = document.createElement('span');
        lockedBadge.className = 'badge bg-secondary ms-2';
        lockedBadge.innerHTML = '<i class="fas fa-lock"></i> Locked';
        lockedBadge.style.fontSize = '0.75em';
        label.appendChild(lockedBadge);
      }
      
      // Add event listeners to prevent any changes
      input.addEventListener('keydown', preventInput);
      input.addEventListener('input', preventInput);
      input.addEventListener('paste', preventInput);
      input.addEventListener('drop', preventInput);
      
      // Prevent focus and selection
      input.addEventListener('focus', preventFocus);
      input.addEventListener('click', preventFocus);
      
      // Additional security: prevent context menu and selection
      input.addEventListener('contextmenu', preventInput);
      input.addEventListener('selectstart', preventInput);
      
      // Prevent drag and drop
      input.draggable = false;
      
      // Set tabindex to -1 to prevent tab navigation
      input.tabIndex = -1;
      
      console.log(`🔒 ${fieldName} has been locked`);
    }
    
    // Prevent any input on locked fields
    function preventInput(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // Show a brief message that the field is locked
      showLockedMessage(e.target);
      
      return false;
    }
    
    // Show message when trying to modify locked input
    function showLockedMessage(input) {
      // Create or get existing message element
      let messageDiv = document.getElementById('lockedMessage');
      if (!messageDiv) {
        messageDiv = document.createElement('div');
        messageDiv.id = 'lockedMessage';
        messageDiv.className = 'alert alert-warning alert-dismissible fade show';
        messageDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 9999;
          max-width: 300px;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        `;
        messageDiv.innerHTML = `
          <i class="fas fa-lock"></i>
          <strong>Field Locked</strong><br>
          This field has been locked and cannot be modified.
          <button type="button" class="btn-close" onclick="this.parentElement.style.display='none'"></button>
        `;
        document.body.appendChild(messageDiv);
        
        // Add event listener for close button
        const closeBtn = messageDiv.querySelector('.btn-close');
        if (closeBtn) {
          closeBtn.addEventListener('click', function() {
            messageDiv.style.display = 'none';
          });
        }
      }
      
      // Show the message
      messageDiv.style.display = 'block';
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        if (messageDiv) {
          messageDiv.style.display = 'none';
        }
      }, 3000);
    }
    
    // Prevent focus on locked fields
    function preventFocus(e) {
      e.preventDefault();
      e.target.blur();
      return false;
    }

    // Check if time inputs should be locked on page load
    function checkAndLockTimeInputs() {
      // Only lock starting time if it has a saved value from Firestore
      if (activeFirstStageStartTime && activeFirstStageStartTime !== '') {
        // Check if this is actually a saved value, not just an empty string
        const startingTimeInput = document.getElementById("startingTime");
        if (startingTimeInput && startingTimeInput.value && startingTimeInput.value.trim() !== '') {
          lockTimeInput("startingTime", "Active First Stage Start Time");
        }
      }
      
      // Only lock second stage time if it has a saved value from Firestore
      if (secondStageStartTime && isSecondStageActive && secondStageStartTime !== '') {
        const secondStageInput = document.getElementById("secondStageTime");
        if (secondStageInput && secondStageInput.value && secondStageInput.value.trim() !== '') {
          lockTimeInput("secondStageTime", "Second Stage Start Time");
        }
      }
    }
    
    // Check if an input is already locked
    function isInputLocked(inputId) {
      const input = document.getElementById(inputId);
      return input && input.classList.contains('locked-input');
    }
    
    // Unlock an input (for administrators only)
    function unlockTimeInput(inputId, fieldName) {
      const input = document.getElementById(inputId);
      if (!input) return;
      
      if (!isInputLocked(inputId)) {
        console.log(`🔓 ${fieldName} is not locked`);
        return;
      }
      
      // Re-enable the input
      input.disabled = false;
      input.readOnly = false;
      
      // Remove locked styling
      input.classList.remove('locked-input');
      input.style.backgroundColor = '';
      input.style.color = '';
      input.style.cursor = '';
      
      // Remove lock indicator
      const lockIndicator = input.parentElement.querySelector('.lock-indicator');
      if (lockIndicator) {
        lockIndicator.remove();
      }
      
      // Note: Help text removal code removed as it's no longer needed
      
      // Remove locked badge from label
      const label = input.parentElement.querySelector('label');
      if (label) {
        const lockedBadge = label.querySelector('.badge');
        if (lockedBadge) {
          lockedBadge.remove();
        }
      }
      
      // Remove event listeners
      input.removeEventListener('keydown', preventInput);
      input.removeEventListener('input', preventInput);
      input.removeEventListener('paste', preventInput);
      input.removeEventListener('drop', preventInput);
      input.removeEventListener('focus', preventFocus);
      input.removeEventListener('click', preventFocus);
      
      console.log(`🔓 ${fieldName} has been unlocked`);
    }
    
    // Log current lock status for debugging
    function logLockStatus() {
      console.log('🔒 Current Lock Status:');
      console.log(`  Starting Time: ${isInputLocked('startingTime') ? 'LOCKED' : 'UNLOCKED'}`);
      console.log(`  Second Stage Time: ${isInputLocked('secondStageTime') ? 'LOCKED' : 'UNLOCKED'}`);
      console.log(`  Active First Stage Start Time: ${activeFirstStageStartTime || 'NOT SET'}`);
      console.log(`  Second Stage Start Time: ${secondStageStartTime || 'NOT SET'}`);
      console.log(`  Is Second Stage Active: ${isSecondStageActive}`);
    }
    
    // Periodic check to ensure inputs remain locked
    function startLockMonitoring() {
      setInterval(() => {
        // Check if locked inputs are still properly locked
        const startingTimeInput = document.getElementById("startingTime");
        if (activeFirstStageStartTime && activeFirstStageStartTime !== '' && 
            startingTimeInput && startingTimeInput.value && startingTimeInput.value.trim() !== '' && 
            !isInputLocked('startingTime')) {
          console.log('⚠️ Starting time input was unlocked, re-locking...');
          lockTimeInput("startingTime", "Active First Stage Start Time");
        }
        
        const secondStageInput = document.getElementById("secondStageTime");
        if (secondStageStartTime && isSecondStageActive && secondStageStartTime !== '' && 
            secondStageInput && secondStageInput.value && secondStageInput.value.trim() !== '' && 
            !isInputLocked('secondStageTime')) {
          console.log('⚠️ Second stage time input was unlocked, re-locking...');
          lockTimeInput("secondStageTime", "Second Stage Start Time");
        }
      }, 5000); // Check every 5 seconds
    }

    // ===== END TREATMENT FUNCTIONS =====
    let selectedEndTreatmentOption = null;
    let isTreatmentEnded = false;
    let treatmentOutcome = null;

    // Handle end treatment button click
    // Update View Summary link with current patient ID
    function updateViewSummaryLink() {
      const patientId = getPatientIdFromUrl();
      const viewSummaryBtn = document.getElementById('viewSummaryBtn');
      
      if (patientId && viewSummaryBtn) {
        viewSummaryBtn.href = `summary-view.html?patient=${patientId}`;
      }
    }

    // Open View Summary in new browser tab (not PWA)
    function openViewSummary(event) {
      event.preventDefault();
      
      const patientId = getPatientIdFromUrl();
      if (!patientId) {
        alert('Patient ID not found.');
        return;
      }
      
      // Create a new window with specific parameters to ensure it opens as a browser tab
      const summaryUrl = `summary-view.html?patient=${patientId}`;
      
      // Use window.open with specific parameters to force browser tab behavior
      const newWindow = window.open(summaryUrl, '_blank', 'noopener,noreferrer');
      
      // Ensure the new window opens
      if (!newWindow) {
        alert('Please allow pop-ups for this site to view the summary.');
        // Fallback: redirect in current window
        window.location.href = summaryUrl;
      }
    }

    // Language toggle function
    function toggleLanguage() {
      const toggle = document.getElementById('languageToggle');
      if (toggle.textContent === 'EN') {
        toggle.textContent = 'MM';
        // Add logic to switch to Myanmar language if needed
      } else {
        toggle.textContent = 'EN';
        // Add logic to switch to English language if needed
      }
    }



    // Load medication data from Firestore
    async function loadMedicationData() {
      try {
        const patientId = getPatientIdFromUrl();
        if (!patientId) return;
        
        const medicationSnap = await firebase.firestore()
          .collection('patients')
          .doc(patientId)
          .collection('medication')
          .get();
        
        medicationSnap.forEach(doc => {
          const data = doc.data();
          const time = data.time;
          
          // Store medication data in existing records
          if (data.oxytocin) {
            existing[`Medication_Oxytocin_${time}`] = data.oxytocin;
            if (data.oxytocin === "Yes") {
              existing[`Medication_Oxytocin_${time}_UL`] = data.oxytocin_UL || "";
              existing[`Medication_Oxytocin_${time}_drops`] = data.oxytocin_drops || "";
            }
          }
          
          if (data.medicine) {
            existing[`Medication_Medicine_${time}`] = data.medicine;
            if (data.medicine === "Y" || data.medicine === "Yes") {
              existing[`Medication_Medicine_${time}_name`] = data.medicine_name || "";
              existing[`Medication_Medicine_${time}_dosage`] = data.medicine_dosage || "";
              existing[`Medication_Medicine_${time}_route`] = data.medicine_route || "";
              existing[`Medication_Medicine_${time}_frequency`] = data.medicine_frequency || "";
            }
          }
          
          if (data.iv_fluids) {
            existing[`Medication_IV_Fluids_${time}`] = data.iv_fluids;
          }
        });
      } catch (error) {
        console.error('Error loading medication data:', error);
      }
    }

    // Update patient status to "labour" when first stage is started
    // Function removed - patient status is now manually controlled by midwives

    // Show notification when status changes
    function showStatusChangeNotification() {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #059669, #047857);
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 10000;
        font-weight: 600;
        animation: slideIn 0.3s ease-out;
      `;
      
      notification.innerHTML = `
        <i class="fas fa-heartbeat me-2"></i>
        Patient status changed to <strong>Labour Care</strong>
      `;
      
      // Add animation keyframes
      if (!document.getElementById('statusChangeAnimation')) {
        const style = document.createElement('style');
        style.id = 'statusChangeAnimation';
        style.textContent = `
          @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
          }
        `;
        document.head.appendChild(style);
      }
      
      document.body.appendChild(notification);
      
      // Remove notification after 3 seconds
      setTimeout(() => {
        notification.style.animation = 'slideIn 0.3s ease-out reverse';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }

    // Show warning about data loss when starting time changes
    function showDataLossWarning() {
      // Create warning message if it doesn't exist
      let warningDiv = document.getElementById('dataLossWarning');
      if (!warningDiv) {
        warningDiv = document.createElement('div');
        warningDiv.id = 'dataLossWarning';
        warningDiv.className = 'alert alert-warning';
        warningDiv.innerHTML = `
          <i class="fas fa-exclamation-triangle"></i>
          <strong>Warning:</strong> You have changed the Active First Stage Start Time. 
          All previously saved data has been cleared because the time intervals are now different. 
          Please re-enter the patient data for the new time schedule.
        `;
        
        // Insert after the starting time requirement div
        const startingTimeRequirement = document.getElementById('startingTimeRequirement');
        if (startingTimeRequirement) {
          startingTimeRequirement.parentNode.insertBefore(warningDiv, startingTimeRequirement.nextSibling);
        }
      }
      
      // Show the warning
      warningDiv.style.display = 'block';
      
      // Auto-hide after 15 seconds (longer since it's important)
      setTimeout(() => {
        warningDiv.style.display = 'none';
      }, 15000);
    }

  </script>
</body>
</html>
